Code bundle from project: taskflow
================================================================================

DIRECTORY STRUCTURE
--------------------------------------------------------------------------------
taskflow/
├── .gitignore
├── App.tsx
├── README.md
├── constants.tsx
├── index.html
├── index.tsx
├── metadata.json
├── package.json
├── tsconfig.json
├── types.ts
└── vite.config.ts
├── components/
│   ├── achievements/
│   │   ├── AchievementBadge.tsx
│   │   └── AchievementsView.tsx
│   ├── auth/
│   │   ├── LoginView.tsx
│   │   ├── ProfileDropdown.tsx
│   │   └── RegisterView.tsx
│   ├── board/
│   │   ├── BoardColumn.tsx
│   │   ├── BoardTaskCard.tsx
│   │   └── BoardView.tsx
│   ├── briefing/
│   │   └── DailyBriefingModal.tsx
│   ├── calendar/
│   │   ├── CalendarView.tsx
│   │   ├── MonthView.tsx
│   │   ├── WeekAgendaView.tsx
│   │   └── WeekView.tsx
│   ├── chatbot/
│   │   └── Chatbot.tsx
│   ├── collaboration/
│   │   ├── AssigneePicker.tsx
│   │   ├── CommentSection.tsx
│   │   └── ShareListModal.tsx
│   ├── countdown/
│   │   └── CountdownView.tsx
│   ├── dashboard/
│   │   ├── DashboardView.tsx
│   │   └── ProductivityHeatmap.tsx
│   ├── habit/
│   │   └── HabitView.tsx
│   ├── landing/
│   │   └── LandingPage.tsx
│   ├── layout/
│   │   ├── BottomNavBar.tsx
│   │   ├── FeatureBar.tsx
│   │   ├── MainContent.tsx
│   │   └── Sidebar.tsx
│   ├── matrix/
│   │   └── MatrixView.tsx
│   ├── pomodoro/
│   │   ├── FocusTaskPicker.tsx
│   │   ├── PomodoroTimer.tsx
│   │   └── PomodoroView.tsx
│   ├── profile/
│   │   ├── EditProfileModal.tsx
│   │   └── ProfileView.tsx
│   ├── search/
│   │   └── SearchModal.tsx
│   ├── settings/
│   │   └── SettingsView.tsx
│   ├── task/
│   │   ├── TaskDetail.tsx
│   │   ├── TaskForm.tsx
│   │   ├── TaskItem.tsx
│   │   └── TaskList.tsx
│   ├── ui/
│   │   ├── Avatar.tsx
│   │   ├── ConfirmationModal.tsx
│   │   ├── DatePicker.tsx
│   │   ├── LanguageSwitcher.tsx
│   │   ├── RecurrencePicker.tsx
│   │   ├── ReminderSetter.tsx
│   │   ├── Spinner.tsx
│   │   └── Toast.tsx
├── hooks/
│   ├── useConfirmation.tsx
│   ├── useGemini.tsx
│   ├── useI18n.tsx
│   ├── useSettings.tsx
│   ├── useTaskManager.tsx
│   ├── useToast.tsx
│   └── useUser.tsx
├── locales/
│   ├── en.json
│   └── vi.json
├── services/
│   └── geminiService.ts

================================================================================

--- FILE: .gitignore ---

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?


================================================================================

--- FILE: App.tsx ---



import React, { useState, useEffect } from 'react';
import Sidebar from './components/layout/Sidebar';
import MainContent from './components/layout/MainContent';
import TaskDetail from './components/task/TaskDetail';
import Chatbot from './components/chatbot/Chatbot';
import { useTaskManager } from './hooks/useTaskManager';
import FeatureBar from './components/layout/FeatureBar';
import SearchModal from './components/search/SearchModal';
import CalendarView from './components/calendar/CalendarView';
import PomodoroView from './components/pomodoro/PomodoroView';
import MatrixView from './components/matrix/MatrixView';
import HabitView from './components/habit/HabitView';
import CountdownView from './components/countdown/CountdownView';
import SettingsView from './components/settings/SettingsView';
import { useSettings } from './hooks/useSettings';
import DailyBriefingModal from './components/briefing/DailyBriefingModal';
import { ToastContainer } from './components/ui/Toast';
import ConfirmationModal from './components/ui/ConfirmationModal';
import DashboardView from './components/dashboard/DashboardView';
import { useGemini } from './hooks/useGemini';
import { useUser } from './hooks/useUser';
import LoginView from './components/auth/LoginView';
import LandingPage from './components/landing/LandingPage';
import ShareListModal from './components/collaboration/ShareListModal';
import AchievementsView from './components/achievements/AchievementsView';
import BoardView from './components/board/BoardView';
import TaskForm from './components/task/TaskForm';
import RegisterView from './components/auth/RegisterView';
import ProfileView from './components/profile/ProfileView';
import { MenuIcon } from './constants';
import BottomNavBar from './components/layout/BottomNavBar';


const AppContent: React.FC = () => {
    const { state } = useTaskManager();
    const { theme } = useSettings();
    const { isAvailable: isGeminiAvailable } = useGemini();
    const [isChatbotOpen, setChatbotOpen] = useState(false);
    const [isSidebarOpen, setSidebarOpen] = useState(window.innerWidth > 768);
    const [isSearchOpen, setSearchOpen] = useState(false);
    const [isBriefingOpen, setBriefingOpen] = useState(false);
    const [shareListModal, setShareListModal] = useState<{ isOpen: boolean; listId: string | null }>({ isOpen: false, listId: null });
    const [taskForm, setTaskForm] = useState<{ isOpen: boolean; defaultValues?: { listId?: string; columnId?: string; } }>({ isOpen: false });

    const handleOpenTaskForm = (defaultValues?: { listId?: string; columnId?: string; }) => {
        setTaskForm({ isOpen: true, defaultValues });
    };

    const handleCloseTaskForm = () => {
        setTaskForm({ isOpen: false });
    };
    
    useEffect(() => {
        const body = window.document.body;
        body.classList.remove('light', 'dark');
        body.classList.add(theme);
    }, [theme]);

    const renderView = () => {
        switch(state.view) {
            case 'dashboard':
                return <DashboardView onBriefingToggle={() => setBriefingOpen(true)} />;
            case 'list':
                return <MainContent onSearchToggle={() => setSearchOpen(true)} onBriefingToggle={() => setBriefingOpen(true)} onOpenTaskForm={handleOpenTaskForm} />;
            case 'board':
                return <BoardView onOpenTaskForm={handleOpenTaskForm} />;
            case 'calendar':
                return <CalendarView />;
            case 'pomodoro':
                return <PomodoroView />;
            case 'matrix':
                return <MatrixView />;
            case 'habit':
                return <HabitView />;
            case 'countdown':
                return <CountdownView />;
            case 'settings':
                return <SettingsView />;
            case 'achievements':
                return <AchievementsView />;
            // FIX: Add case for 'profile' view to render the ProfileView component.
            case 'profile':
                return <ProfileView />;
            default:
                 return <DashboardView onBriefingToggle={() => setBriefingOpen(true)} />;
        }
    }

    const listToShare = state.lists.find(l => l.id === shareListModal.listId);

    return (
        <div className="flex h-screen bg-background text-foreground overflow-hidden">
            {!isGeminiAvailable && (
                <div className="bg-yellow-500/20 text-yellow-800 dark:text-yellow-300 text-center text-xs py-1 fixed top-0 w-full z-50">
                    Gemini API key not found. AI features are disabled.
                </div>
            )}
            <FeatureBar 
                onSidebarToggle={() => setSidebarOpen(prev => !prev)}
            />
            <Sidebar 
                isOpen={isSidebarOpen} 
                onClose={() => setSidebarOpen(false)}
                onChatbotToggle={() => {
                    setChatbotOpen(prev => !prev);
                    setSidebarOpen(false);
                }}
                onShareList={(listId) => setShareListModal({ isOpen: true, listId })}
            />
            
            <div className="flex-1 flex flex-col overflow-hidden relative">
                 <header className="md:hidden flex-shrink-0 p-4 border-b border-border flex items-center justify-between z-10 bg-card/80 backdrop-blur-lg">
                    <button onClick={() => setSidebarOpen(true)} aria-label="Open sidebar">
                        <MenuIcon className="h-6 w-6" />
                    </button>
                    <div className="flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256" className="h-6 w-6 text-primary"><rect width="256" height="256" fill="none"></rect><path d="M128,24a104,104,0,1,0,104,104A104.11,104.11,0,0,0,128,24Zm45.15,122.34-8.6-14.9a4,4,0,0,0-6.92,0l-22.1,38.28a4,4,0,0,1-3.46,2H92a4,4,0,0,1-3.46-6l25.56-44.28a4,4,0,0,0-3.46-6H65.75a4,4,0,0,1,0-8h42.39a4,4,0,0,1,3.46,6l-25.56,44.28a4,4,0,0,0,3.46,6h22.54a4,4,0,0,1,3.46-2l22.1-38.28a4,4,0,0,0-3.46-6H134.25a4,4,0,0,1,0-8h42.39a4,4,0,0,1,3.46,2l8.6,14.9a4,4,0,0,1-3.46,6H173.15a4,4,0,0,1,0,8h-3.46a4,4,0,0,1-3.46-2Z"></path></svg>
                        <h1 className="font-bold text-lg">TaskFlow</h1>
                    </div>
                    <div></div>{/* Placeholder for centering title */}
                </header>

                <div className="flex-1 flex overflow-hidden">
                     <div className="flex-1 flex min-w-0">
                        {renderView()}
                    </div>
                    <div className={`
                        fixed inset-0 z-20 md:relative md:z-auto md:inset-auto transition-transform duration-300 ease-in-out bg-card md:bg-transparent
                        ${state.selectedTaskId ? 'translate-x-0' : 'translate-x-full'}
                    `}>
                        {state.selectedTaskId && <TaskDetail taskId={state.selectedTaskId} />}
                    </div>
                </div>
            </div>

            <BottomNavBar />

            {isChatbotOpen && <Chatbot onClose={() => setChatbotOpen(false)} />}
            {isSearchOpen && <SearchModal onClose={() => setSearchOpen(false)} />}
            {isBriefingOpen && <DailyBriefingModal onClose={() => setBriefingOpen(false)} />}
            {taskForm.isOpen && <TaskForm onClose={handleCloseTaskForm} defaultValues={taskForm.defaultValues} />}
            {shareListModal.isOpen && listToShare && (
                <ShareListModal 
                    list={listToShare} 
                    onClose={() => setShareListModal({ isOpen: false, listId: null })} 
                />
            )}
            <ToastContainer />
            <ConfirmationModal />
        </div>
    );
};

const App: React.FC = () => {
    const { isAuthenticated } = useUser();
    const [isLaunched, setIsLaunched] = useState(() => sessionStorage.getItem('appLaunched') === 'true');
    const [authView, setAuthView] = useState<'login' | 'register'>('login');

    const handleLaunch = () => {
        sessionStorage.setItem('appLaunched', 'true');
        setIsLaunched(true);
    };

    if (!isLaunched) {
        return <LandingPage onLaunch={handleLaunch} />;
    }
    
    if (!isAuthenticated) {
        switch (authView) {
            case 'register':
                return <RegisterView onSwitchToLogin={() => setAuthView('login')} />;
            default:
                return <LoginView onSwitchToRegister={() => setAuthView('register')} />;
        }
    }

    return <AppContent />;
};

export default App;

================================================================================

--- FILE: README.md ---

<div align="center">
<img width="1200" height="475" alt="GHBanner" src="https://github.com/user-attachments/assets/0aa67016-6eaf-458a-adb2-6e31a0763ed6" />
</div>

# Run and deploy your AI Studio app

This contains everything you need to run your app locally.

View your app in AI Studio: https://ai.studio/apps/drive/1M-oiXUua1CzhGrbPxn-aHNdxLFdDNcHo

## Run Locally

**Prerequisites:**  Node.js


1. Install dependencies:
   `npm install`
2. Set the `GEMINI_API_KEY` in [.env.local](.env.local) to your Gemini API key
3. Run the app:
   `npm run dev`


================================================================================

--- FILE: components/achievements/AchievementBadge.tsx ---

import React from 'react';
import { Achievement } from '../../types';
import { useTranslation } from '../../hooks/useI18n';

interface AchievementBadgeProps {
    achievement: Achievement;
    isUnlocked: boolean;
}

const AchievementBadge: React.FC<AchievementBadgeProps> = ({ achievement, isUnlocked }) => {
    const { t } = useTranslation();
    const Icon = achievement.icon;

    return (
        <div 
            className={`
                bg-card border border-border rounded-lg p-6 flex flex-col items-center justify-center text-center
                transition-all duration-300
                ${isUnlocked ? 'opacity-100 shadow-md' : 'opacity-50 filter grayscale'}
            `}
            title={isUnlocked ? t(achievement.description) : t('achievements.locked.description')}
        >
            <div className={`
                p-4 rounded-full mb-4
                ${isUnlocked ? 'bg-primary/10 text-primary' : 'bg-secondary'}
            `}>
                <Icon className="h-10 w-10" />
            </div>
            <h3 className="font-bold">{t(achievement.title)}</h3>
            {!isUnlocked && <p className="text-xs text-muted-foreground mt-1">{t('achievements.locked.status')}</p>}
        </div>
    );
};

export default AchievementBadge;

================================================================================

--- FILE: components/achievements/AchievementsView.tsx ---

import React from 'react';
import { useTaskManager } from '../../hooks/useTaskManager';
import { useTranslation } from '../../hooks/useI18n';
import { ALL_ACHIEVEMENTS } from '../../constants';
import AchievementBadge from './AchievementBadge';

const AchievementsView: React.FC = () => {
    const { state } = useTaskManager();
    const { t } = useTranslation();

    const unlockedSet = new Set(state.unlockedAchievements);
    const sortedAchievements = [...ALL_ACHIEVEMENTS].sort((a, b) => {
        const aUnlocked = unlockedSet.has(a.id);
        const bUnlocked = unlockedSet.has(b.id);
        if (aUnlocked && !bUnlocked) return -1;
        if (!aUnlocked && bUnlocked) return 1;
        return 0;
    });

    return (
        <div className="flex-1 flex flex-col overflow-hidden">
            <header className="p-6 border-b border-border flex-shrink-0">
                <h1 className="text-2xl font-bold">{t('achievements.title')}</h1>
                <p className="text-muted-foreground">{t('achievements.subtitle')}</p>
            </header>
            <main className="flex-1 p-4 md:p-6 overflow-y-auto pb-20 md:pb-6">
                 <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
                    {sortedAchievements.map(achievement => (
                        <AchievementBadge 
                            key={achievement.id}
                            achievement={achievement}
                            isUnlocked={unlockedSet.has(achievement.id)}
                        />
                    ))}
                </div>
            </main>
        </div>
    );
};

export default AchievementsView;

================================================================================

--- FILE: components/auth/LoginView.tsx ---

import React, { useState } from 'react';
import { useUser } from '../../hooks/useUser';
import { useTranslation } from '../../hooks/useI18n';
import LanguageSwitcher from '../ui/LanguageSwitcher';
import { AuthIllustration, GoogleIcon, GitHubIcon } from '../../constants';

interface LoginViewProps {
    onSwitchToRegister: () => void;
}

const LoginView: React.FC<LoginViewProps> = ({ onSwitchToRegister }) => {
    const { login } = useUser();
    const { t } = useTranslation();
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        // For the mock, any input will log in the user
        login(email, password);
    };

    const handleSocialLogin = () => {
        // Mock social login
        login('social@example.com', 'password');
    }

    return (
        <div className="min-h-screen grid grid-cols-1 lg:grid-cols-2 bg-background">
            {/* Left Column (Branding) */}
            <div className="hidden lg:flex flex-col items-center justify-center bg-secondary p-12 text-center">
                <AuthIllustration className="w-full max-w-md" />
                 <h2 className="text-3xl font-bold mt-8">TaskFlow</h2>
                 <p className="text-muted-foreground mt-2 max-w-sm">
                    {t('auth.tagline')}
                </p>
            </div>

            {/* Right Column (Form) */}
            <div className="flex items-center justify-center p-6 sm:p-8 relative">
                 <LanguageSwitcher className="absolute top-6 right-6" />
                 <div className="w-full max-w-sm space-y-6">
                    <div className="text-center lg:hidden">
                        <div className="flex justify-center items-center gap-2 mb-2">
                             <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256" className="h-8 w-8 text-primary">
                                <rect width="256" height="256" fill="none"></rect>
                                <path d="M128,24a104,104,0,1,0,104,104A104.11,104.11,0,0,0,128,24Zm45.15,122.34-8.6-14.9a4,4,0,0,0-6.92,0l-22.1,38.28a4,4,0,0,1-3.46,2H92a4,4,0,0,1-3.46-6l25.56-44.28a4,4,0,0,0-3.46-6H65.75a4,4,0,0,1,0-8h42.39a4,4,0,0,1,3.46,6l-25.56,44.28a4,4,0,0,0,3.46,6h22.54a4,4,0,0,1,3.46-2l22.1-38.28a4,4,0,0,0-3.46-6H134.25a4,4,0,0,1,0-8h42.39a4,4,0,0,1,3.46,2l8.6,14.9a4,4,0,0,1-3.46,6H173.15a4,4,0,0,1,0,8h-3.46a4,4,0,0,1-3.46-2Z"></path>
                            </svg>
                            <h1 className="text-3xl font-bold">TaskFlow</h1>
                        </div>
                    </div>
                    <div className="text-center">
                        <h1 className="text-2xl font-bold">{t('auth.welcome')}</h1>
                    </div>

                    <div className="grid grid-cols-2 gap-3">
                        <button onClick={handleSocialLogin} className="w-full inline-flex items-center justify-center py-2 px-4 border border-border rounded-md shadow-sm bg-card hover:bg-secondary text-sm font-medium">
                            <GoogleIcon className="w-5 h-5 mr-2" />
                            {t('auth.signInWithGoogle')}
                        </button>
                        <button onClick={handleSocialLogin} className="w-full inline-flex items-center justify-center py-2 px-4 border border-border rounded-md shadow-sm bg-card hover:bg-secondary text-sm font-medium">
                            <GitHubIcon className="w-5 h-5 mr-2" />
                            {t('auth.signInWithGitHub')}
                        </button>
                    </div>

                     <div className="relative">
                        <div className="absolute inset-0 flex items-center">
                            <div className="w-full border-t border-border"></div>
                        </div>
                        <div className="relative flex justify-center text-xs">
                            <span className="bg-background px-2 text-muted-foreground">{t('auth.orContinueWith')}</span>
                        </div>
                    </div>

                    <form onSubmit={handleSubmit} className="space-y-4">
                        <div>
                            <label htmlFor="email" className="text-sm font-medium text-muted-foreground sr-only">
                                {t('auth.emailLabel')}
                            </label>
                            <input
                                id="email"
                                name="email"
                                type="email"
                                autoComplete="email"
                                required
                                value={email}
                                onChange={(e) => setEmail(e.target.value)}
                                placeholder={t('auth.emailLabel')}
                                className="w-full p-3 bg-secondary/80 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50"
                            />
                        </div>
                        <div>
                            <label htmlFor="password"className="text-sm font-medium text-muted-foreground sr-only">
                                {t('auth.passwordLabel')}
                            </label>
                            <input
                                id="password"
                                name="password"
                                type="password"
                                autoComplete="current-password"
                                required
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                placeholder={t('auth.passwordLabel')}
                                className="w-full p-3 bg-secondary/80 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50"
                            />
                        </div>
                        <div>
                            <button
                                type="submit"
                                className="w-full px-4 py-3 font-semibold text-primary-foreground bg-primary rounded-md hover:bg-primary/90 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-background focus:ring-primary"
                            >
                                {t('auth.signIn')}
                            </button>
                        </div>
                    </form>
                     <p className="text-center text-sm text-muted-foreground">
                        {t('auth.noAccount')}{' '}
                        <button type="button" onClick={onSwitchToRegister} className="font-semibold text-primary hover:underline">
                            {t('auth.signUp')}
                        </button>
                    </p>
                    <p className="text-center text-xs text-muted-foreground pt-4">
                        {t('auth.mockLoginInfo')}
                    </p>
                </div>
            </div>
        </div>
    );
};

export default LoginView;

================================================================================

--- FILE: components/auth/ProfileDropdown.tsx ---

import React from 'react';
import { useUser } from '../../hooks/useUser';
import { useTaskManager } from '../../hooks/useTaskManager';
import { User } from '../../types';
import { SettingsIcon, ArrowLeftOnRectangleIcon, TrophyIcon, UserCircleIcon } from '../../constants';
import Avatar from '../ui/Avatar';
import { useTranslation } from '../../hooks/useI18n';

interface ProfileDropdownProps {
    user: User | null;
    onClose: () => void;
}

const ProfileDropdown: React.FC<ProfileDropdownProps> = ({ user, onClose }) => {
    const { logout } = useUser();
    const { dispatch } = useTaskManager();
    const { t } = useTranslation();

    const handleViewProfileClick = () => {
        dispatch({ type: 'SET_VIEW', payload: 'profile' });
        onClose();
    };

    const handleSettingsClick = () => {
        dispatch({ type: 'SET_VIEW', payload: 'settings' });
        onClose();
    };

    const handleAchievementsClick = () => {
        dispatch({ type: 'SET_VIEW', payload: 'achievements' });
        onClose();
    };

    const handleLogoutClick = () => {
        logout();
        onClose();
    };

    if (!user) return null;

    return (
        <div className="
            absolute bottom-full mb-2 md:bottom-4 md:left-full md:ml-2 md:mb-0
            w-64 bg-popover rounded-lg shadow-2xl border border-border
            animate-fade-in
            origin-bottom md:origin-bottom-left z-50
        ">
            <button
                onClick={handleViewProfileClick}
                className="w-full text-left p-4 border-b border-border flex items-center gap-3 hover:bg-secondary transition-colors"
            >
                <Avatar user={user} className="w-10 h-10 flex-shrink-0" />
                <div className="overflow-hidden">
                    <p className="font-semibold text-sm truncate">{user.name}</p>
                    <p className="text-xs text-muted-foreground truncate">{user.email}</p>
                </div>
            </button>
            <div className="p-2">
                <button
                    onClick={handleViewProfileClick}
                    className="w-full flex items-center gap-3 px-3 py-2 text-sm rounded-md hover:bg-secondary"
                >
                    <UserCircleIcon className="w-5 h-5 text-muted-foreground" />
                    <span>{t('profile.viewProfile')}</span>
                </button>
                <button
                    onClick={handleSettingsClick}
                    className="w-full flex items-center gap-3 px-3 py-2 text-sm rounded-md hover:bg-secondary"
                >
                    <SettingsIcon className="w-5 h-5 text-muted-foreground" />
                    <span>{t('profile.settings')}</span>
                </button>
                <button
                    onClick={handleAchievementsClick}
                    className="w-full flex items-center gap-3 px-3 py-2 text-sm rounded-md hover:bg-secondary"
                >
                    <TrophyIcon className="w-5 h-5 text-muted-foreground" />
                    <span>{t('profile.achievements')}</span>
                </button>
            </div>
            <div className="p-2 border-t border-border">
                 <button
                    onClick={handleLogoutClick}
                    className="w-full flex items-center gap-3 px-3 py-2 text-sm rounded-md hover:bg-secondary"
                >
                    <ArrowLeftOnRectangleIcon className="w-5 h-5 text-muted-foreground" />
                    <span>{t('profile.logout')}</span>
                </button>
            </div>
        </div>
    );
};

export default ProfileDropdown;

================================================================================

--- FILE: components/auth/RegisterView.tsx ---

import React, { useState } from 'react';
import { useUser } from '../../hooks/useUser';
import { useTranslation } from '../../hooks/useI18n';
import LanguageSwitcher from '../ui/LanguageSwitcher';
import { AuthIllustration, GoogleIcon, GitHubIcon } from '../../constants';

interface RegisterViewProps {
    onSwitchToLogin: () => void;
}

const RegisterView: React.FC<RegisterViewProps> = ({ onSwitchToLogin }) => {
    const { register } = useUser();
    const { t } = useTranslation();
    const [name, setName] = useState('');
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        // For the mock, any input will "register" and log in the user
        register(name, email, password);
    };
    
    const handleSocialLogin = () => {
        // Mock social login
        register('Social User', 'social@example.com', 'password');
    }

    return (
        <div className="min-h-screen grid grid-cols-1 lg:grid-cols-2 bg-background">
            {/* Left Column (Branding) */}
            <div className="hidden lg:flex flex-col items-center justify-center bg-secondary p-12 text-center">
                <AuthIllustration className="w-full max-w-md" />
                 <h2 className="text-3xl font-bold mt-8">TaskFlow</h2>
                 <p className="text-muted-foreground mt-2 max-w-sm">
                    {t('auth.tagline')}
                </p>
            </div>

            {/* Right Column (Form) */}
            <div className="flex items-center justify-center p-6 sm:p-8 relative">
                 <LanguageSwitcher className="absolute top-6 right-6" />
                 <div className="w-full max-w-sm space-y-6">
                     <div className="text-center lg:hidden">
                        <div className="flex justify-center items-center gap-2 mb-2">
                             <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256" className="h-8 w-8 text-primary">
                                <rect width="256" height="256" fill="none"></rect>
                                <path d="M128,24a104,104,0,1,0,104,104A104.11,104.11,0,0,0,128,24Zm45.15,122.34-8.6-14.9a4,4,0,0,0-6.92,0l-22.1,38.28a4,4,0,0,1-3.46,2H92a4,4,0,0,1-3.46-6l25.56-44.28a4,4,0,0,0-3.46-6H65.75a4,4,0,0,1,0-8h42.39a4,4,0,0,1,3.46,6l-25.56,44.28a4,4,0,0,0,3.46,6h22.54a4,4,0,0,1,3.46-2l22.1-38.28a4,4,0,0,0-3.46-6H134.25a4,4,0,0,1,0-8h42.39a4,4,0,0,1,3.46,2l8.6,14.9a4,4,0,0,1-3.46,6H173.15a4,4,0,0,1,0,8h-3.46a4,4,0,0,1-3.46-2Z"></path>
                            </svg>
                            <h1 className="text-3xl font-bold">TaskFlow</h1>
                        </div>
                    </div>
                    <div className="text-center">
                        <h1 className="text-2xl font-bold">{t('auth.createAccountPrompt')}</h1>
                    </div>

                    <div className="grid grid-cols-2 gap-3">
                        <button onClick={handleSocialLogin} className="w-full inline-flex items-center justify-center py-2 px-4 border border-border rounded-md shadow-sm bg-card hover:bg-secondary text-sm font-medium">
                            <GoogleIcon className="w-5 h-5 mr-2" />
                            {t('auth.signInWithGoogle')}
                        </button>
                        <button onClick={handleSocialLogin} className="w-full inline-flex items-center justify-center py-2 px-4 border border-border rounded-md shadow-sm bg-card hover:bg-secondary text-sm font-medium">
                            <GitHubIcon className="w-5 h-5 mr-2" />
                            {t('auth.signInWithGitHub')}
                        </button>
                    </div>

                     <div className="relative">
                        <div className="absolute inset-0 flex items-center">
                            <div className="w-full border-t border-border"></div>
                        </div>
                        <div className="relative flex justify-center text-xs">
                            <span className="bg-background px-2 text-muted-foreground">{t('auth.orContinueWith')}</span>
                        </div>
                    </div>

                    <form onSubmit={handleSubmit} className="space-y-4">
                        <div>
                            <label htmlFor="name" className="text-sm font-medium text-muted-foreground sr-only">
                                {t('auth.fullNameLabel')}
                            </label>
                            <input
                                id="name"
                                name="name"
                                type="text"
                                autoComplete="name"
                                required
                                value={name}
                                onChange={(e) => setName(e.target.value)}
                                placeholder={t('auth.fullNameLabel')}
                                className="w-full p-3 bg-secondary/80 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50"
                            />
                        </div>
                        <div>
                            <label htmlFor="email" className="text-sm font-medium text-muted-foreground sr-only">
                                {t('auth.emailLabel')}
                            </label>
                            <input
                                id="email"
                                name="email"
                                type="email"
                                autoComplete="email"
                                required
                                value={email}
                                onChange={(e) => setEmail(e.target.value)}
                                placeholder={t('auth.emailLabel')}
                                className="w-full p-3 bg-secondary/80 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50"
                            />
                        </div>
                        <div>
                            <label htmlFor="password"className="text-sm font-medium text-muted-foreground sr-only">
                                {t('auth.passwordLabel')}
                            </label>
                            <input
                                id="password"
                                name="password"
                                type="password"
                                autoComplete="new-password"
                                required
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                placeholder={t('auth.passwordLabel')}
                                className="w-full p-3 bg-secondary/80 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50"
                            />
                        </div>
                        <div>
                            <button
                                type="submit"
                                className="w-full px-4 py-3 font-semibold text-primary-foreground bg-primary rounded-md hover:bg-primary/90 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-background focus:ring-primary"
                            >
                                {t('auth.signUp')}
                            </button>
                        </div>
                    </form>
                     <p className="text-center text-sm text-muted-foreground">
                        {t('auth.alreadyHaveAccount')}{' '}
                        <button type="button" onClick={onSwitchToLogin} className="font-semibold text-primary hover:underline">
                            {t('auth.signIn')}
                        </button>
                    </p>
                </div>
            </div>
        </div>
    );
};

export default RegisterView;

================================================================================

--- FILE: components/board/BoardColumn.tsx ---

import React, { useState, useRef, useEffect } from 'react';
import { Column, Task } from '../../types';
import BoardTaskCard from './BoardTaskCard';
import { PlusIcon, TrashIcon, GripVerticalIcon } from '../../constants';
import { useTaskManager } from '../../hooks/useTaskManager';
import { useConfirmation } from '../../hooks/useConfirmation';
import { useToast } from '../../hooks/useToast';
import { useTranslation } from '../../hooks/useI18n';


interface BoardColumnProps {
    column: Column;
    tasks: Task[];
    onTaskDragStart: (taskId: string) => void;
    onTaskDragEnd: () => void;
    onDropOnColumn: (columnId: string) => void;
    onOpenTaskForm: (defaultValues: { listId: string; columnId: string; }) => void;
    onColumnDragStart: (columnId: string) => void;
}

const ColumnMenu: React.FC<{ column: Column, onRenameStart: () => void, onClose: () => void }> = ({ column, onRenameStart, onClose }) => {
    const { dispatch } = useTaskManager();
    const { confirm } = useConfirmation();
    const addToast = useToast();
    const { t } = useTranslation();
    const menuRef = useRef<HTMLDivElement>(null);

     useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
                onClose();
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, [onClose]);

    const handleDelete = async () => {
        onClose();
        const isConfirmed = await confirm({
            title: t('board.column.deleteConfirm.title', { columnName: column.name }),
            message: t('board.column.deleteConfirm.message'),
            confirmText: t('board.column.deleteConfirm.confirmText'),
        });
        if (isConfirmed) {
            dispatch({ type: 'DELETE_COLUMN', payload: { columnId: column.id, listId: column.listId } });
            addToast(t('board.column.deleteSuccess', { columnName: column.name }), 'success');
        }
    };

    return (
        <div ref={menuRef} className="absolute top-8 right-2 w-40 bg-popover rounded-md shadow-lg border border-border z-10">
            <div className="p-1">
                <button onClick={() => { onRenameStart(); onClose(); }} className="w-full text-left text-sm px-2 py-1.5 hover:bg-secondary rounded-sm">{t('board.column.menu.rename')}</button>
                <button onClick={handleDelete} className="w-full text-left text-sm px-2 py-1.5 hover:bg-destructive/10 text-destructive rounded-sm">{t('board.column.menu.delete')}</button>
            </div>
        </div>
    );
};

const BoardColumn: React.FC<BoardColumnProps> = ({ column, tasks, onTaskDragStart, onTaskDragEnd, onDropOnColumn, onOpenTaskForm, onColumnDragStart }) => {
    const { dispatch } = useTaskManager();
    const { t } = useTranslation();
    const [isDragOver, setIsDragOver] = useState(false);
    const [isMenuOpen, setIsMenuOpen] = useState(false);
    const [isRenaming, setIsRenaming] = useState(false);
    const [columnName, setColumnName] = useState(column.name);
    
    useEffect(() => {
        setColumnName(column.name)
    }, [column.name]);

    const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
        e.preventDefault();
        setIsDragOver(true);
    };

    const handleDragLeave = () => {
        setIsDragOver(false);
    };

    const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {
        e.preventDefault();
        onDropOnColumn(column.id);
        setIsDragOver(false);
    };
    
    const handleRenameSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (columnName.trim() && columnName.trim() !== column.name) {
            dispatch({ type: 'UPDATE_COLUMN', payload: { columnId: column.id, name: columnName.trim() }});
        }
        setIsRenaming(false);
    }
    
    return (
        <div
            className={`
                w-72 flex-shrink-0 rounded-lg flex flex-col h-full max-h-full
                transition-colors duration-200
                ${isDragOver ? 'bg-primary/10' : 'bg-secondary'}
            `}
            onDragOver={handleDragOver}
            onDragLeave={handleDragLeave}
            onDrop={handleDrop}
        >
            <div 
                className="p-3 flex items-center gap-1"
            >
                <div 
                    draggable 
                    onDragStart={() => onColumnDragStart(column.id)}
                    className="cursor-grab text-muted-foreground/50 hover:text-muted-foreground p-1 -ml-1"
                    aria-label={t('board.column.dragHandle')}
                >
                    <GripVerticalIcon className="h-5 w-5" />
                </div>
                {isRenaming ? (
                    <form onSubmit={handleRenameSubmit} className="flex-grow">
                        <input
                            type="text"
                            value={columnName}
                            onChange={(e) => setColumnName(e.target.value)}
                            onBlur={handleRenameSubmit}
                            autoFocus
                            className="font-semibold text-sm p-1 -m-1 bg-card rounded-md focus:outline-none focus:ring-2 focus:ring-primary w-full"
                        />
                    </form>
                ) : (
                    <h3 className="font-semibold text-sm cursor-pointer flex-grow" onClick={() => setIsRenaming(true)}>
                        {column.name} <span className="text-muted-foreground ml-1">{tasks.length}</span>
                    </h3>
                )}
                <div className="relative">
                     <button onClick={() => setIsMenuOpen(prev => !prev)} className="p-1 rounded-md hover:bg-muted">
                        <svg className="w-4 h-4 text-muted-foreground" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path></svg>
                    </button>
                    {isMenuOpen && <ColumnMenu column={column} onRenameStart={() => setIsRenaming(true)} onClose={() => setIsMenuOpen(false)} />}
                </div>
            </div>
            <div className="flex-1 p-2 space-y-2 overflow-y-auto">
                {tasks.map(task => (
                    <BoardTaskCard
                        key={task.id}
                        task={task}
                        onDragStart={onTaskDragStart}
                        onDragEnd={onTaskDragEnd}
                    />
                ))}
            </div>
            <div className="p-2">
                 <button
                    onClick={() => onOpenTaskForm({ listId: column.listId, columnId: column.id })}
                    className="w-full flex items-center gap-2 p-2 rounded-md text-muted-foreground hover:bg-muted hover:text-primary transition-colors"
                >
                    <PlusIcon className="h-4 w-4" />
                    <span className="text-sm">{t('board.column.addCard')}</span>
                </button>
            </div>
        </div>
    );
};

export default BoardColumn;

================================================================================

--- FILE: components/board/BoardTaskCard.tsx ---

import React from 'react';
import { Task } from '../../types';
import { useTaskManager } from '../../hooks/useTaskManager';
import { useUser } from '../../hooks/useUser';
import Avatar from '../ui/Avatar';
import { PRIORITY_MAP, RepeatIcon, CheckCircleIcon, ChatBubbleOvalLeftEllipsisIcon } from '../../constants';

interface BoardTaskCardProps {
    task: Task;
    onDragStart: (taskId: string) => void;
    onDragEnd: () => void;
}

const BoardTaskCard: React.FC<BoardTaskCardProps> = ({ task, onDragStart, onDragEnd }) => {
    const { dispatch } = useTaskManager();
    const { allUsers } = useUser();

    const assignee = allUsers.find(u => u.id === task.assigneeId);
    const completedSubtasks = task.subtasks.filter(st => st.completed).length;

    const handleDragStart = (e: React.DragEvent<HTMLDivElement>) => {
        e.dataTransfer.effectAllowed = 'move';
        onDragStart(task.id);
    };

    const handleSelect = () => {
        const originalId = task.id.split('_')[0];
        dispatch({ type: 'SET_SELECTED_TASK', payload: originalId });
    };

    const isPast = (date: Date): boolean => {
        const today = new Date();
        today.setHours(0, 0, 0, 0); // Compare with start of today
        return date.getTime() < today.getTime();
    };
    
    const dueDateLabel = () => {
        if (!task.dueDate) return null;
        const date = new Date(task.dueDate);
        const isDuePast = isPast(date) && !task.completed;
        const color = isDuePast ? 'bg-destructive text-destructive-foreground' : 'bg-muted text-muted-foreground';
        
        return <span className={`text-xs px-2 py-0.5 rounded-full ${color}`}>
            {date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' })}
        </span>;
    };


    return (
        <div
            draggable
            onDragStart={handleDragStart}
            onDragEnd={onDragEnd}
            onClick={handleSelect}
            className="bg-card p-3 rounded-lg border border-border shadow-sm cursor-pointer hover:bg-muted hover:shadow-md"
        >
            <p className="text-sm font-medium mb-2">{task.title}</p>
            <div className="flex items-center justify-between">
                <div className="flex items-center gap-3 text-xs text-muted-foreground">
                    {task.subtasks.length > 0 && (
                        <span className={`flex items-center gap-1 ${completedSubtasks === task.subtasks.length && task.subtasks.length > 0 ? 'text-green-500' : ''}`}>
                            <CheckCircleIcon className="h-4 w-4" />
                            {completedSubtasks}/{task.subtasks.length}
                        </span>
                    )}
                    {task.comments && task.comments.length > 0 && (
                        <span className="flex items-center gap-1">
                            <ChatBubbleOvalLeftEllipsisIcon className="h-4 w-4" />
                            {task.comments.length}
                        </span>
                    )}
                </div>
                <div className="flex items-center gap-2">
                    {dueDateLabel()}
                    {assignee && <Avatar user={assignee} className="w-6 h-6" />}
                </div>
            </div>
        </div>
    );
};

export default BoardTaskCard;

================================================================================

--- FILE: components/board/BoardView.tsx ---



import React, { useState, useMemo } from 'react';
import { useTaskManager } from '../../hooks/useTaskManager';
import BoardColumn from './BoardColumn';
import { List, Column } from '../../types';
import { PlusIcon } from '../../constants';
import { useTranslation } from '../../hooks/useI18n';

interface BoardViewProps {
    onOpenTaskForm: (defaultValues?: { listId?: string; columnId?: string; }) => void;
}

const BoardView: React.FC<BoardViewProps> = ({ onOpenTaskForm }) => {
    const { state, dispatch } = useTaskManager();
    const { t } = useTranslation();
    const [selectedListId, setSelectedListId] = useState<string>(() => state.lists[0]?.id || '');
    const [draggedTaskId, setDraggedTaskId] = useState<string | null>(null);
    const [draggedColumnId, setDraggedColumnId] = useState<string | null>(null);
    const [dragOverColumnId, setDragOverColumnId] = useState<string | null>(null);
    const [newColumnName, setNewColumnName] = useState('');
    const [isAddingColumn, setIsAddingColumn] = useState(false);

    const availableLists = useMemo(() => state.lists.filter(l => l.id !== 'inbox'), [state.lists]);

    const handleListChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
        setSelectedListId(e.target.value);
    };

    const columnsForList = useMemo(() => {
        return state.columns.filter(c => c.listId === selectedListId);
    }, [state.columns, selectedListId]);

    const tasksForList = useMemo(() => {
        return state.tasks.filter(t => t.listId === selectedListId);
    }, [state.tasks, selectedListId]);

    const handleTaskDragStart = (taskId: string) => {
        setDraggedTaskId(taskId);
    };
    
    const handleTaskDragEnd = () => {
        setDraggedTaskId(null);
    };

    const handleDropOnColumn = (columnId: string) => {
        if (draggedTaskId) {
            dispatch({ type: 'MOVE_TASK_TO_COLUMN', payload: { taskId: draggedTaskId, newColumnId: columnId, listId: selectedListId } });
        }
        setDraggedTaskId(null);
    };
    
    const handleColumnDragStart = (columnId: string) => {
        setDraggedColumnId(columnId);
    }

    const handleColumnDrop = (droppedOnId: string) => {
        if (draggedColumnId && draggedColumnId !== droppedOnId) {
            dispatch({ type: 'REORDER_COLUMNS', payload: { listId: selectedListId, draggedId: draggedColumnId, droppedOnId } });
        }
        setDraggedColumnId(null);
        setDragOverColumnId(null);
    }
    
    const handleAddColumn = (e: React.FormEvent) => {
        e.preventDefault();
        if (newColumnName.trim() && selectedListId) {
            dispatch({ type: 'ADD_COLUMN', payload: { listId: selectedListId, name: newColumnName.trim() }});
            setNewColumnName('');
            setIsAddingColumn(false);
        }
    }
    
    if (availableLists.length === 0) {
        return (
            <div className="flex-1 flex flex-col items-center justify-center text-center p-4">
                <h2 className="text-xl font-semibold text-muted-foreground">{t('board.noLists')}</h2>
                <p className="text-sm text-muted-foreground">{t('board.noListsSubtitle')}</p>
            </div>
        );
    }
    
    // Effect to handle case where selected list is deleted
    React.useEffect(() => {
        if (!availableLists.find(l => l.id === selectedListId)) {
            if(availableLists.length > 0) {
                setSelectedListId(availableLists[0].id);
            } else {
                setSelectedListId('');
            }
        }
    }, [selectedListId, availableLists]);

    return (
        <div className="flex-1 flex flex-col min-w-0">
            <header className="flex-shrink-0 flex items-center justify-between p-4 border-b border-border">
                <h1 className="text-2xl font-bold">{t('board.title')}</h1>
                {availableLists.length > 0 && selectedListId && (
                    <select
                        value={selectedListId}
                        onChange={handleListChange}
                        className="p-2 bg-secondary/50 rounded-md text-sm font-semibold focus:outline-none focus:ring-2 focus:ring-primary/50"
                    >
                        {availableLists.map(list => (
                            <option key={list.id} value={list.id}>{list.name}</option>
                        ))}
                    </select>
                )}
            </header>
            <main className="flex-1 flex gap-4 overflow-x-auto bg-background p-4 md:p-6 pb-20 md:pb-6" onDragEnd={() => { setDraggedColumnId(null); setDragOverColumnId(null); }}>
                {columnsForList.map(column => (
                    <div 
                        key={column.id} 
                        onDrop={() => {
                            handleColumnDrop(column.id);
                            setDragOverColumnId(null);
                        }}
                        onDragOver={(e) => {
                            e.preventDefault();
                            if (draggedColumnId && draggedColumnId !== column.id) {
                                setDragOverColumnId(column.id);
                            }
                        }}
                        onDragLeave={() => {
                            setDragOverColumnId(null);
                        }}
                        className={`
                            transition-all duration-200 p-1 rounded-lg
                            ${draggedColumnId === column.id ? 'opacity-30' : ''}
                            ${draggedColumnId && dragOverColumnId === column.id ? 'bg-primary/10' : ''}
                        `}
                    >
                        <BoardColumn
                            column={column}
                            tasks={tasksForList.filter(t => t.columnId === column.id || (!t.columnId && columnsForList.findIndex(c => c.id === column.id) === 0))}
                            onTaskDragStart={handleTaskDragStart}
                            onTaskDragEnd={handleTaskDragEnd}
                            onDropOnColumn={handleDropOnColumn}
                            onOpenTaskForm={onOpenTaskForm}
                            onColumnDragStart={handleColumnDragStart}
                        />
                    </div>
                ))}
                 <div className="w-72 flex-shrink-0">
                    {isAddingColumn ? (
                        <form onSubmit={handleAddColumn} className="bg-secondary p-2 rounded-lg">
                            <input
                                autoFocus
                                type="text"
                                value={newColumnName}
                                onChange={e => setNewColumnName(e.target.value)}
                                placeholder={t('board.column.namePlaceholder')}
                                className="w-full p-2 bg-card rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50"
                            />
                            <div className="flex items-center gap-2 mt-2">
                                <button type="submit" className="px-3 py-1.5 bg-primary text-primary-foreground rounded-md text-sm font-semibold">{t('board.column.addColumn')}</button>
                                <button type="button" onClick={() => setIsAddingColumn(false)} className="text-sm text-muted-foreground">{t('board.column.cancel')}</button>
                            </div>
                        </form>
                    ) : (
                        <button 
                            onClick={() => setIsAddingColumn(true)}
                            className="w-full flex items-center gap-2 p-3 rounded-lg text-primary bg-primary/5 hover:bg-primary/10 transition-colors"
                        >
                            <PlusIcon className="h-5 w-5" />
                            <span className="text-sm font-semibold">{t('board.addColumn')}</span>
                        </button>
                    )}
                </div>
            </main>
        </div>
    );
};

export default BoardView;

================================================================================

--- FILE: components/briefing/DailyBriefingModal.tsx ---

import React, { useState, useEffect } from 'react';
import { useTaskManager } from '../../hooks/useTaskManager';
import { generateDailyBriefing } from '../../services/geminiService';
import { CloseIcon, SparklesIcon } from '../../constants';
import Spinner from '../ui/Spinner';
import { useGemini } from '../../hooks/useGemini';
import { useToast } from '../../hooks/useToast';
import { useTranslation } from '../../hooks/useI18n';

interface DailyBriefingModalProps {
    onClose: () => void;
}

// A simple markdown to HTML converter for the briefing
const MarkdownRenderer: React.FC<{ content: string }> = ({ content }) => {
    const htmlContent = content
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
        .replace(/\n/g, '<br />'); // Newlines

    return <div className="prose prose-sm max-w-none text-foreground" dangerouslySetInnerHTML={{ __html: htmlContent }} />;
};


const DailyBriefingModal: React.FC<DailyBriefingModalProps> = ({ onClose }) => {
    const { state } = useTaskManager();
    const { ai, isAvailable } = useGemini();
    const { t } = useTranslation();
    const addToast = useToast();
    const [briefing, setBriefing] = useState<string | null>(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const fetchBriefing = async () => {
            if (!ai || !isAvailable) {
                setError(t('briefing.error.unavailable'));
                setIsLoading(false);
                return;
            }
            try {
                const response = await generateDailyBriefing(ai, state.tasks, state.habits);
                setBriefing(response);
            } catch (err: any) {
                setError(err.message || 'An unknown error occurred.');
                addToast(err.message || t('briefing.error.failed'), 'error');
            } finally {
                setIsLoading(false);
            }
        };

        fetchBriefing();
    }, [state.tasks, state.habits, ai, isAvailable, addToast, t]);

    return (
        <div className="fixed inset-0 bg-black/50 z-40 flex items-center justify-center p-4 animate-fade-in">
            <div className="bg-card rounded-lg shadow-xl w-full max-w-2xl flex flex-col h-full max-h-[85vh]">
                <header className="p-4 border-b border-border flex items-center justify-between">
                    <div className="flex items-center gap-3">
                        <SparklesIcon className="h-6 w-6 text-primary" />
                        <h2 className="text-lg font-semibold">{t('briefing.title')}</h2>
                    </div>
                    <button onClick={onClose} className="p-1 rounded-full hover:bg-secondary">
                        <CloseIcon className="h-5 w-5 text-muted-foreground" />
                    </button>
                </header>

                <div className="flex-grow p-6 overflow-y-auto">
                    {isLoading && (
                        <div className="flex flex-col items-center justify-center h-full text-center">
                            <Spinner className="h-8 w-8" />
                            <p className="mt-4 text-muted-foreground">{t('briefing.loading')}</p>
                        </div>
                    )}
                    {error && !isLoading && (
                        <div className="text-center text-destructive">
                            <h3 className="font-semibold">{t('briefing.error.failed')}</h3>
                            <p className="text-sm">{error}</p>
                        </div>
                    )}
                    {briefing && !isLoading && (
                        <MarkdownRenderer content={briefing} />
                    )}
                </div>
                 <footer className="p-4 border-t border-border flex justify-end">
                    <button onClick={onClose} className="px-4 py-2 bg-primary text-primary-foreground rounded-md text-sm font-semibold hover:bg-primary/90">
                        {t('briefing.button.gotIt')}
                    </button>
                </footer>
            </div>
        </div>
    );
};

export default DailyBriefingModal;

================================================================================

--- FILE: components/calendar/CalendarView.tsx ---

import React, { useState } from 'react';
import { useTaskManager } from '../../hooks/useTaskManager';
import { ChevronLeftIcon, ChevronRightIcon } from '../../constants';
import MonthView from './MonthView';
import WeekView from './WeekView';
import { useTranslation } from '../../hooks/useI18n';
import WeekAgendaView from './WeekAgendaView';

type CalendarViewType = 'month' | 'week';

const CalendarView: React.FC = () => {
    const { state } = useTaskManager();
    const { t } = useTranslation();
    const [currentDate, setCurrentDate] = useState(new Date());
    const [viewType, setViewType] = useState<CalendarViewType>('month');

    const next = () => {
        setCurrentDate(prev => {
            const newDate = new Date(prev);
            if (viewType === 'month') {
                newDate.setMonth(newDate.getMonth() + 1);
            } else {
                newDate.setDate(newDate.getDate() + 7);
            }
            return newDate;
        });
    };

    const prev = () => {
        setCurrentDate(prev => {
            const newDate = new Date(prev);
            if (viewType === 'month') {
                 newDate.setMonth(newDate.getMonth() - 1);
            } else {
                newDate.setDate(newDate.getDate() - 7);
            }
            return newDate;
        });
    };
    
    const goToToday = () => setCurrentDate(new Date());

    const getHeaderText = () => {
        if (viewType === 'month') {
            return currentDate.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
        }
        const weekStart = new Date(currentDate);
        weekStart.setDate(weekStart.getDate() - (weekStart.getDay() || 7) + 1);
        const weekEnd = new Date(weekStart);
        weekEnd.setDate(weekEnd.getDate() + 6);

        if (weekStart.getMonth() === weekEnd.getMonth()) {
            return currentDate.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
        }
        return `${weekStart.toLocaleDateString(undefined, { month: 'short' })} - ${weekEnd.toLocaleDateString(undefined, { month: 'short', year: 'numeric' })}`;
    };

    return (
        <div className="flex-1 flex flex-col">
            <header className="flex flex-col md:flex-row items-center justify-between p-4 border-b border-border gap-4">
                <div className="flex items-center gap-4 w-full md:w-auto">
                    <h1 className="text-xl md:text-2xl font-bold truncate">{getHeaderText()}</h1>
                    <div className="flex items-center gap-1">
                        <button onClick={prev} className="p-2 rounded-md hover:bg-secondary">
                            <ChevronLeftIcon className="h-5 w-5 text-muted-foreground" />
                        </button>
                        <button onClick={goToToday} className="px-3 py-1.5 text-sm font-semibold rounded-md hover:bg-secondary border border-border">
                            {t('calendar.today')}
                        </button>
                        <button onClick={next} className="p-2 rounded-md hover:bg-secondary">
                            <ChevronRightIcon className="h-5 w-5 text-muted-foreground" />
                        </button>
                    </div>
                </div>
                <div className="flex items-center gap-2 bg-secondary p-1 rounded-md">
                     <button 
                        onClick={() => setViewType('month')}
                        className={`px-3 py-1 text-sm font-semibold rounded ${viewType === 'month' ? 'bg-background shadow-sm' : 'hover:bg-background/50'}`}
                    >
                        {t('calendar.month')}
                    </button>
                    <button 
                        onClick={() => setViewType('week')}
                        className={`px-3 py-1 text-sm font-semibold rounded ${viewType === 'week' ? 'bg-background shadow-sm' : 'hover:bg-background/50'}`}
                    >
                        {t('calendar.week')}
                    </button>
                </div>
            </header>
            <div className="flex-1 overflow-y-auto md:overflow-hidden">
                {viewType === 'month' ? (
                    <MonthView currentDate={currentDate} tasks={state.tasks} lists={state.lists} />
                ) : (
                    <>
                        <div className="hidden md:block h-full">
                           <WeekView currentDate={currentDate} tasks={state.tasks} lists={state.lists} />
                        </div>
                         <div className="block md:hidden">
                           <WeekAgendaView currentDate={currentDate} tasks={state.tasks} lists={state.lists} />
                        </div>
                    </>
                )}
            </div>
        </div>
    );
};

export default CalendarView;

================================================================================

--- FILE: components/calendar/MonthView.tsx ---

import React from 'react';
import { useTaskManager } from '../../hooks/useTaskManager';
import { Task, List } from '../../types';
import { useTranslation } from '../../hooks/useI18n';

interface MonthViewProps {
    currentDate: Date;
    tasks: Task[];
    lists: List[];
}

// Helper functions to replace date-fns
const addDays = (date: Date, amount: number): Date => {
    const newDate = new Date(date);
    newDate.setDate(newDate.getDate() + amount);
    return newDate;
};

const isSameMonth = (date1: Date, date2: Date): boolean => {
    return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth();
};

const isToday = (date: Date): boolean => {
    const today = new Date();
    return date.getDate() === today.getDate() &&
           date.getMonth() === today.getMonth() &&
           date.getFullYear() === today.getFullYear();
};

const MonthView: React.FC<MonthViewProps> = ({ currentDate, tasks, lists }) => {
    const { dispatch } = useTaskManager();
    const { t } = useTranslation();
    
    const monthStart = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
    const monthEnd = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);

    const startDate = new Date(monthStart);
    startDate.setDate(startDate.getDate() - (startDate.getDay() || 7) + 1); // Start week on Monday
    
    const endDate = new Date(monthEnd);
    if (endDate.getDay() !== 0) { // end week on Sunday
        endDate.setDate(endDate.getDate() + (7 - endDate.getDay()));
    }


    const listColorMap = new Map(lists.map(l => [l.id, l.color]));

    const handleDragStart = (e: React.DragEvent<HTMLDivElement>, taskId: string) => {
        e.dataTransfer.setData("taskId", taskId);
    };

    const handleDrop = (e: React.DragEvent<HTMLDivElement>, day: Date) => {
        e.preventDefault();
        const taskId = e.dataTransfer.getData("taskId");
        const task = tasks.find(t => t.id === taskId);
        if (task) {
            const originalDate = task.dueDate ? new Date(task.dueDate) : new Date();
            const newDueDate = new Date(day);
            // Preserve the original time
            newDueDate.setHours(originalDate.getHours());
            newDueDate.setMinutes(originalDate.getMinutes());
            newDueDate.setSeconds(originalDate.getSeconds());

            dispatch({
                type: 'UPDATE_TASK',
                payload: { ...task, dueDate: newDueDate.toISOString() }
            });
        }
    };

    const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
        e.preventDefault();
    };

    const renderCells = () => {
        const rows = [];
        let days = [];
        let day = new Date(startDate);

        while (day <= endDate) {
            for (let i = 0; i < 7; i++) {
                const cloneDay = new Date(day);
                const tasksForDay = tasks.filter(task =>
                    task.dueDate && new Date(task.dueDate).toDateString() === cloneDay.toDateString()
                );

                days.push(
                    <div
                        key={day.toString()}
                        className={`flex-1 border-r border-b border-border p-2 min-h-[100px] sm:min-h-[120px] overflow-hidden ${!isSameMonth(day, monthStart) ? 'bg-muted/30 text-muted-foreground' : ''}`}
                        onDrop={(e) => handleDrop(e, cloneDay)}
                        onDragOver={handleDragOver}
                    >
                        <span className={`text-sm ${isToday(day) ? 'bg-primary text-primary-foreground rounded-full px-2 py-1 font-bold' : ''}`}>
                            {cloneDay.getDate()}
                        </span>
                        <div className="mt-2">
                             <div className="hidden sm:block space-y-1">
                                {tasksForDay.slice(0, 2).map(task => (
                                    <div
                                        key={task.id}
                                        draggable
                                        onDragStart={(e) => handleDragStart(e, task.id)}
                                        onClick={() => dispatch({ type: 'SET_SELECTED_TASK', payload: task.id })}
                                        className={`text-xs p-1 rounded-md text-white cursor-pointer truncate ${listColorMap.get(task.listId) || 'bg-gray-500'}`}
                                        title={task.title}
                                    >
                                        {task.title}
                                    </div>
                                ))}
                            </div>
                             <div className="flex flex-wrap items-center gap-1 sm:hidden">
                                {tasksForDay.slice(0, 5).map(task => (
                                    <div key={task.id} className={`w-2 h-2 rounded-full ${listColorMap.get(task.listId) || 'bg-gray-500'}`} title={task.title} />
                                ))}
                            </div>
                            {tasksForDay.length > 2 && (
                                <div className="text-xs text-muted-foreground mt-1 hidden sm:block">
                                    {t('calendar.moreTasks', { count: tasksForDay.length - 2 })}
                                </div>
                            )}
                            {tasksForDay.length > 5 && (
                                <div className="text-xs text-muted-foreground mt-1 sm:hidden">
                                    {t('calendar.moreTasks', { count: tasksForDay.length - 5 })}
                                </div>
                            )}
                        </div>
                    </div>
                );
                day = addDays(day, 1);
            }
            rows.push(
                <div className="flex" key={day.toString()}>
                    {days}
                </div>
            );
            days = [];
        }
        return rows;
    };
    
    const dayNames = Array.from({ length: 7 }, (_, i) => {
        const day = new Date(2024, 0, 1 + i); // 2024-01-01 is a Monday
        return day.toLocaleDateString(undefined, { weekday: 'short' });
    });

    return (
        <div className="flex flex-col h-full">
            <div className="flex border-b border-border">
                {dayNames.map(name => (
                    <div key={name} className="flex-1 text-center font-semibold text-sm py-2 border-r border-border last:border-r-0">
                        {name}
                    </div>
                ))}
            </div>
            <div className="flex-grow">{renderCells()}</div>
        </div>
    );
};

export default MonthView;

================================================================================

--- FILE: components/calendar/WeekAgendaView.tsx ---

import React from 'react';
// FIX: Import 'List' type to resolve type error.
import { Task, List } from '../../types';
import TaskItem from '../task/TaskItem';

interface WeekAgendaViewProps {
    currentDate: Date;
    tasks: Task[];
    lists: List[];
}

const addDays = (date: Date, amount: number): Date => {
    const newDate = new Date(date);
    newDate.setDate(newDate.getDate() + amount);
    return newDate;
};

const isSameDay = (date1: Date, date2: Date): boolean => {
    if (!date1 || !date2) return false;
    return date1.getFullYear() === date2.getFullYear() &&
           date1.getMonth() === date2.getMonth() &&
           date1.getDate() === date2.getDate();
};

const WeekAgendaView: React.FC<WeekAgendaViewProps> = ({ currentDate, tasks }) => {
    const weekStart = new Date(currentDate);
    weekStart.setDate(weekStart.getDate() - (weekStart.getDay() || 7) + 1); // Start week on Monday

    const days = Array.from({ length: 7 }, (_, i) => addDays(weekStart, i));

    return (
        <div className="p-4 space-y-6 pb-20">
            {days.map(day => {
                const tasksForDay = tasks
                    .filter(task => task.dueDate && isSameDay(new Date(task.dueDate), day))
                    .sort((a, b) => {
                        const dateA = a.dueDate ? new Date(a.dueDate).getTime() : 0;
                        const dateB = b.dueDate ? new Date(b.dueDate).getTime() : 0;
                        return dateA - dateB;
                    });
                
                const isToday = isSameDay(day, new Date());

                return (
                    <div key={day.toISOString()}>
                        <div className="flex items-baseline gap-3 mb-2">
                             <h2 className={`font-bold text-lg ${isToday ? 'text-primary' : ''}`}>
                                {day.toLocaleDateString(undefined, { weekday: 'long' })}
                            </h2>
                            <p className={`text-sm ${isToday ? 'text-primary' : 'text-muted-foreground'}`}>
                                {day.toLocaleDateString(undefined, { month: 'short', day: 'numeric' })}
                            </p>
                        </div>
                        {tasksForDay.length > 0 ? (
                            <div className="space-y-2 border-l-2 border-border pl-4 ml-2">
                                {tasksForDay.map(task => (
                                    <TaskItem key={task.id} task={task} isDraggable={false} />
                                ))}
                            </div>
                        ) : (
                            <p className="text-sm text-muted-foreground italic pl-4 ml-2">No tasks scheduled.</p>
                        )}
                    </div>
                );
            })}
        </div>
    );
};

export default WeekAgendaView;

================================================================================

--- FILE: components/calendar/WeekView.tsx ---


import React, { useState } from 'react';
import { useTaskManager } from '../../hooks/useTaskManager';
import { Task, List } from '../../types';
import { useTranslation } from '../../hooks/useI18n';

interface WeekViewProps {
    currentDate: Date;
    tasks: Task[];
    lists: List[];
}

// Helper functions to replace date-fns
const addDays = (date: Date, amount: number): Date => {
    const newDate = new Date(date);
    newDate.setDate(newDate.getDate() + amount);
    return newDate;
};

const isSameDay = (date1: Date, date2: Date): boolean => {
    if (!date1 || !date2) return false;
    return date1.getFullYear() === date2.getFullYear() &&
           date1.getMonth() === date2.getMonth() &&
           date1.getDate() === date2.getDate();
};

const WeekView: React.FC<WeekViewProps> = ({ currentDate, tasks, lists }) => {
    const { dispatch } = useTaskManager();
    const { t } = useTranslation();
    const [dragOverSlot, setDragOverSlot] = useState<{ day: Date; hour: number } | null>(null);
    
    const weekStart = new Date(currentDate);
    weekStart.setDate(weekStart.getDate() - (weekStart.getDay() || 7) + 1); // Start week on Monday
    
    const days = Array.from({ length: 7 }, (_, i) => addDays(weekStart, i));
    const hours = Array.from({ length: 24 }, (_, i) => i);

    const listColorMap = new Map(lists.map(l => [l.id, l.color]));

    const tasksWithTime = tasks.filter(t => {
        if (!t.dueDate) return false;
        const d = new Date(t.dueDate);
        // Exclude tasks that might be midnight by convention but are all-day
        return d.getHours() !== 0 || d.getMinutes() !== 0;
    });

    const allDayTasks = tasks.filter(t => t.dueDate && !tasksWithTime.some(twt => twt.id === t.id));

    const handleDragStart = (e: React.DragEvent<HTMLDivElement>, taskId: string) => {
        e.dataTransfer.setData("taskId", taskId);
    };

    const handleDrop = (e: React.DragEvent<HTMLDivElement>, day: Date, hour?: number) => {
        e.preventDefault();
        const taskId = e.dataTransfer.getData("taskId");
        const task = tasks.find(t => t.id === taskId);
        if (task) {
            let newDueDate = new Date(day);
            if (hour !== undefined) {
                 newDueDate.setHours(hour, 0, 0, 0);
            } else {
                // Dropped in all-day section, keep original time or set to noon
                 const originalDate = task.dueDate ? new Date(task.dueDate) : new Date(day);
                 newDueDate.setHours(originalDate.getHours() || 12, originalDate.getMinutes(), 0, 0);
            }
           
            dispatch({
                type: 'UPDATE_TASK',
                payload: { ...task, dueDate: newDueDate.toISOString() }
            });
        }
        setDragOverSlot(null);
    };

    const handleDragOver = (e: React.DragEvent<HTMLDivElement>, day: Date, hour?: number) => {
        e.preventDefault();
        if (hour !== undefined) {
             setDragOverSlot({ day, hour });
        }
    };

    return (
        <div className="flex flex-col h-full overflow-hidden">
            {/* Header row */}
            <div className="grid grid-cols-[auto_1fr] flex-shrink-0">
                <div className="w-14 text-xs text-center p-2 border-b border-border"></div>
                <div className="grid grid-cols-7 border-b border-border">
                    {days.map((day, dayIndex) => (
                        <div key={dayIndex} className="border-l border-border p-2 text-center">
                            <span className="font-semibold text-sm">{day.toLocaleDateString(undefined, { weekday: 'short' })}</span>
                            <p className={`text-xl font-bold ${isSameDay(day, new Date()) ? 'text-primary' : ''}`}>{day.getDate()}</p>
                        </div>
                    ))}
                </div>
            </div>
             {/* All-day section */}
            <div className="grid grid-cols-[auto_1fr] flex-shrink-0 border-b border-border">
                <div className="w-14 text-xs text-center py-2 flex items-center justify-center">{t('calendar.allDay')}</div>
                <div className="grid grid-cols-7">
                    {days.map((day, dayIndex) => (
                        <div key={dayIndex} className="border-l border-border p-1 overflow-hidden"
                            onDrop={(e) => handleDrop(e, day)}
                            onDragOver={(e) => e.preventDefault()}
                        >
                            <div className="space-y-1 min-h-[20px]">
                                {allDayTasks
                                    .filter(t => isSameDay(new Date(t.dueDate!), day))
                                    .map(task => (
                                        <div
                                            key={task.id}
                                            draggable
                                            onDragStart={(e) => handleDragStart(e, task.id)}
                                            onClick={() => dispatch({ type: 'SET_SELECTED_TASK', payload: task.id })}
                                            className={`text-xs p-1 rounded-md text-white cursor-pointer truncate ${listColorMap.get(task.listId) || 'bg-gray-500'}`}
                                            title={task.title}
                                        >
                                            {task.title}
                                        </div>
                                    ))}
                            </div>
                        </div>
                    ))}
                </div>
            </div>


            {/* Timed section wrapper */}
            <div className="flex-1 overflow-y-auto">
                <div className="grid grid-cols-[auto_1fr] min-w-[700px] md:min-w-full">
                    {/* Time column */}
                    <div className="w-14 grid grid-rows-24">
                        {hours.map(hour => (
                            <div key={hour} className="row-start-auto text-xs text-right pr-2 text-muted-foreground h-16 border-t border-border flex items-start justify-end pt-1">
                                {hour > 0 ? new Date(0, 0, 0, hour).toLocaleTimeString(undefined, { hour: 'numeric', hour12: true }).toLowerCase() : ''}
                            </div>
                        ))}
                    </div>
                    {/* Main grid for timed events */}
                    <div className="grid grid-cols-7">
                        {days.map((day, dayIndex) => (
                            <div key={dayIndex} className="col-start-auto grid grid-rows-24 divide-y divide-border border-l border-border relative">
                                {hours.map(hour => (
                                    <div
                                        key={hour}
                                        className={`row-start-auto h-full transition-colors ${dragOverSlot?.day.getTime() === day.getTime() && dragOverSlot.hour === hour ? 'bg-primary/10' : ''}`}
                                        onDrop={(e) => handleDrop(e, day, hour)}
                                        onDragOver={(e) => handleDragOver(e, day, hour)}
                                        onDragLeave={() => setDragOverSlot(null)}
                                    ></div>
                                ))}
                                {tasksWithTime
                                    .filter(t => isSameDay(new Date(t.dueDate!), day))
                                    .map(task => {
                                        const taskDate = new Date(task.dueDate!);
                                        const taskHour = taskDate.getHours();
                                        const taskMinutes = taskDate.getMinutes();
                                        const top = ((taskHour * 60 + taskMinutes) / (24 * 60)) * 100;
                                        return (
                                            <div
                                                key={task.id}
                                                draggable
                                                onDragStart={(e) => handleDragStart(e, task.id)}
                                                onClick={() => dispatch({ type: 'SET_SELECTED_TASK', payload: task.id })}
                                                className={`absolute w-[calc(100%-4px)] text-xs p-1 rounded-md text-white cursor-pointer ml-[2px] z-10 overflow-hidden ${listColorMap.get(task.listId) || 'bg-gray-500'}`}
                                                style={{ top: `${top}%`, height: `4.166%` }} // 1 hour height
                                                title={task.title}
                                            >
                                                <p className="font-semibold truncate">{task.title}</p>
                                                <p>{taskDate.toLocaleTimeString(undefined, { hour: 'numeric', minute: '2-digit', hour12: true })}</p>
                                            </div>
                                        );
                                })}
                            </div>
                        ))}
                    </div>
                </div>
            </div>
        </div>
    );
};

export default WeekView;


================================================================================

--- FILE: components/chatbot/Chatbot.tsx ---

import React, { useState, useRef, useEffect } from 'react';
import { CloseIcon, PaperAirplaneIcon, CubeTransparentIcon, GlobeAltIcon, SparklesIcon } from '../../constants';
import { ChatMessage, GroundingSource } from '../../types';
import { getChatResponseStream } from '../../services/geminiService';
import Spinner from '../ui/Spinner';
import { useGemini } from '../../hooks/useGemini';
import { useToast } from '../../hooks/useToast';
import { useTranslation } from '../../hooks/useI18n';

interface ChatbotProps {
    onClose: () => void;
}

const Chatbot: React.FC<ChatbotProps> = ({ onClose }) => {
    const [messages, setMessages] = useState<ChatMessage[]>([]);
    const [input, setInput] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [useThinkingMode, setUseThinkingMode] = useState(false);
    const [useSearchGrounding, setUseSearchGrounding] = useState(false);
    const messagesEndRef = useRef<HTMLDivElement>(null);
    const { ai, isAvailable } = useGemini();
    const addToast = useToast();
    const { t } = useTranslation();

    const scrollToBottom = () => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    };

    useEffect(scrollToBottom, [messages]);
    
    useEffect(() => {
      setMessages([{
        id: 'initial',
        role: 'model',
        text: t('chatbot.initialMessage'),
        timestamp: Date.now()
      }])
    }, [t]);

    const handleSend = async () => {
        if (input.trim() === '' || isLoading || !ai) return;

        const userMessage: ChatMessage = {
            id: Date.now().toString(),
            role: 'user',
            text: input,
            timestamp: Date.now(),
        };

        const currentInput = input;
        setInput('');
        setIsLoading(true);
        setMessages(prev => [...prev, userMessage]);
        
        const modelMessageId = (Date.now() + 1).toString();
        // Add a placeholder for the model's response
        setMessages(prev => [...prev, { id: modelMessageId, role: 'model', text: '', timestamp: Date.now() }]);

        try {
            const history = messages.map(m => ({
                role: m.role,
                parts: [{ text: m.text }],
            }));

            const stream = await getChatResponseStream(ai, history, currentInput, { useThinkingMode, useSearchGrounding });
            
            let finalSources: GroundingSource[] = [];
            for await (const chunk of stream) {
                const chunkText = chunk.text;
                const chunkSources = (chunk.candidates?.[0]?.groundingMetadata?.groundingChunks || [])
                    .map((c: any) => ({ uri: c.web?.uri, title: c.web?.title }))
                    .filter((s: GroundingSource) => s.uri);

                if (chunkSources.length > 0) {
                    finalSources = chunkSources;
                }

                setMessages(prev => prev.map(m => 
                    m.id === modelMessageId 
                        ? { ...m, text: m.text + chunkText, groundingSources: finalSources } 
                        : m
                ));
            }

        } catch (error: any) {
            addToast(error.message || 'An error occurred.', 'error');
            setMessages(prev => prev.filter(m => m.id !== modelMessageId)); // Remove placeholder
        } finally {
            setIsLoading(false);
        }
    };
    
    return (
        <div className="fixed inset-0 bg-black/50 z-40 flex items-center justify-center p-4 animate-fade-in">
             <div className="bg-card rounded-lg shadow-xl w-full max-w-2xl flex flex-col h-[80vh]">
                <header className="p-4 border-b border-border flex items-center justify-between">
                    <div className="flex items-center gap-2">
                        <CubeTransparentIcon className="h-6 w-6 text-primary" />
                        <h2 className="text-lg font-semibold">{t('chatbot.title')}</h2>
                    </div>
                    <button onClick={onClose} className="p-1 rounded-full hover:bg-secondary">
                        <CloseIcon className="h-5 w-5 text-muted-foreground" />
                    </button>
                </header>

                <div className="flex-grow p-4 overflow-y-auto space-y-4">
                    {messages.map((msg) => (
                        <div key={msg.id}>
                            <div className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
                                <div className={`max-w-md p-3 rounded-lg ${msg.role === 'user' ? 'bg-primary text-primary-foreground' : 'bg-secondary'}`}>
                                    <p className="text-sm whitespace-pre-wrap">{msg.text || '...'}</p>
                                </div>
                            </div>
                            {msg.groundingSources && msg.groundingSources.length > 0 && (
                                <div className="max-w-md mt-2 text-xs text-muted-foreground">
                                    <h4 className="font-semibold mb-1">{t('chatbot.sources')}</h4>
                                    <ul className="list-disc list-inside space-y-1">
                                        {msg.groundingSources.map(source => (
                                            <li key={source.uri}>
                                                <a href={source.uri} target="_blank" rel="noopener noreferrer" className="hover:underline text-blue-500">
                                                    {source.title}
                                                </a>
                                            </li>
                                        ))}
                                    </ul>
                                </div>
                            )}
                        </div>
                    ))}
                    {isLoading && messages[messages.length-1]?.role === 'model' && !messages[messages.length-1]?.text && (
                        <div className="flex justify-start">
                             <div className="max-w-md p-3 rounded-lg bg-secondary">
                                <Spinner />
                            </div>
                        </div>
                    )}
                    <div ref={messagesEndRef} />
                </div>

                <footer className="p-4 border-t border-border">
                    <div className="flex items-center justify-start flex-wrap gap-x-4 gap-y-2 mb-2">
                        <label htmlFor="thinking-mode" className="flex items-center gap-2 text-xs text-muted-foreground cursor-pointer">
                            <input
                                id="thinking-mode"
                                type="checkbox"
                                checked={useThinkingMode}
                                onChange={(e) => {
                                    setUseThinkingMode(e.target.checked);
                                    if (e.target.checked) setUseSearchGrounding(false);
                                }}
                                className="h-4 w-4 rounded text-primary focus:ring-primary"
                            />
                            <SparklesIcon className="h-4 w-4" /> {t('chatbot.thinkingMode')}
                        </label>
                        <label htmlFor="search-grounding" className="flex items-center gap-2 text-xs text-muted-foreground cursor-pointer">
                            <input
                                id="search-grounding"
                                type="checkbox"
                                checked={useSearchGrounding}
                                onChange={(e) => {
                                    setUseSearchGrounding(e.target.checked);
                                    if (e.target.checked) setUseThinkingMode(false);
                                }}
                                className="h-4 w-4 rounded text-primary focus:ring-primary"
                            />
                            <GlobeAltIcon className="h-4 w-4" /> {t('chatbot.searchWeb')}
                        </label>
                    </div>
                    <div className="relative">
                        <textarea
                            value={input}
                            onChange={(e) => setInput(e.target.value)}
                            onKeyDown={(e) => {
                                if (e.key === 'Enter' && !e.shiftKey) {
                                    e.preventDefault();
                                    handleSend();
                                }
                            }}
                            placeholder={t('chatbot.placeholder')}
                            className="w-full p-3 pr-12 bg-secondary/50 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50 resize-none"
                            rows={1}
                            style={{ height: 'auto', maxHeight: '100px' }}
                        />
                        <button onClick={handleSend} disabled={isLoading || !isAvailable} className="absolute right-2 top-1/2 -translate-y-1/2 p-2 rounded-full bg-primary text-primary-foreground hover:bg-primary/90 disabled:bg-muted disabled:cursor-not-allowed">
                           {isLoading ? <Spinner /> : <PaperAirplaneIcon className="h-5 w-5" />}
                        </button>
                    </div>
                </footer>
            </div>
        </div>
    );
};

export default Chatbot;

================================================================================

--- FILE: components/collaboration/AssigneePicker.tsx ---

import React, { useState, useRef, useEffect } from 'react';
import { useUser } from '../../hooks/useUser';
import { User } from '../../types';
import Avatar from '../ui/Avatar';
import { UserPlusIcon, CheckCircleIcon, CloseIcon } from '../../constants';
import { useTranslation } from '../../hooks/useI18n';

interface AssigneePickerProps {
    currentAssigneeId?: string;
    onAssign: (userId: string | null) => void;
}

const AssigneePicker: React.FC<AssigneePickerProps> = ({ currentAssigneeId, onAssign }) => {
    const { allUsers } = useUser();
    const { t } = useTranslation();
    const [isOpen, setIsOpen] = useState(false);
    const containerRef = useRef<HTMLDivElement>(null);

    const currentAssignee = allUsers.find(u => u.id === currentAssigneeId);

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (containerRef.current && !containerRef.current.contains(event.target as Node)) {
                setIsOpen(false);
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, []);

    const handleSelect = (userId: string | null) => {
        onAssign(userId);
        setIsOpen(false);
    };

    return (
        <div className="relative mt-1" ref={containerRef}>
            <label className="text-sm font-medium text-muted-foreground absolute -top-5">{t('assigneePicker.label')}</label>
            <button
                type="button"
                onClick={() => setIsOpen(!isOpen)}
                className="w-full flex items-center gap-2 p-2 bg-secondary/50 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50"
            >
                {currentAssignee ? (
                    <>
                        <Avatar user={currentAssignee} className="w-5 h-5" />
                        <span className="text-foreground">{currentAssignee.name}</span>
                    </>
                ) : (
                    <>
                        <UserPlusIcon className="h-5 w-5 text-muted-foreground" />
                        <span className="text-muted-foreground">{t('assigneePicker.unassigned')}</span>
                    </>
                )}
            </button>
            {isOpen && (
                <div className="absolute z-10 mt-2 w-full bg-popover text-popover-foreground rounded-md border border-border shadow-lg animate-fade-in max-h-60 overflow-y-auto">
                    <ul className="p-1">
                        <li 
                            onClick={() => handleSelect(null)}
                            className="flex items-center justify-between px-3 py-2 text-sm rounded-md cursor-pointer hover:bg-secondary"
                        >
                            {t('assigneePicker.unassign')}
                            {!currentAssigneeId && <CheckCircleIcon className="h-4 w-4 text-primary" />}
                        </li>
                        {allUsers.map(user => (
                            <li
                                key={user.id}
                                onClick={() => handleSelect(user.id)}
                                className="flex items-center justify-between px-3 py-2 text-sm rounded-md cursor-pointer hover:bg-secondary"
                            >
                                <div className="flex items-center gap-2">
                                    <Avatar user={user} className="w-5 h-5" />
                                    <span>{user.name}</span>
                                </div>
                                {currentAssigneeId === user.id && <CheckCircleIcon className="h-4 w-4 text-primary" />}
                            </li>
                        ))}
                    </ul>
                </div>
            )}
        </div>
    );
};

export default AssigneePicker;

================================================================================

--- FILE: components/collaboration/CommentSection.tsx ---

import React, { useState } from 'react';
import { Comment } from '../../types';
import { useUser } from '../../hooks/useUser';
import Avatar from '../ui/Avatar';
import { PaperAirplaneIcon, ChatBubbleOvalLeftEllipsisIcon } from '../../constants';
import { useTranslation } from '../../hooks/useI18n';

interface CommentSectionProps {
    comments: Comment[];
    onAddComment: (content: string) => void;
}

const CommentSection: React.FC<CommentSectionProps> = ({ comments, onAddComment }) => {
    const { user: currentUser, allUsers } = useUser();
    const { t } = useTranslation();
    const [newComment, setNewComment] = useState('');

    const timeAgo = (date: string): string => {
        const seconds = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
        let interval = seconds / 31536000;
        if (interval > 1) return t('timeAgo.year', { count: Math.floor(interval) });
        interval = seconds / 2592000;
        if (interval > 1) return t('timeAgo.month', { count: Math.floor(interval) });
        interval = seconds / 86400;
        if (interval > 1) return t('timeAgo.day', { count: Math.floor(interval) });
        interval = seconds / 3600;
        if (interval > 1) return t('timeAgo.hour', { count: Math.floor(interval) });
        interval = seconds / 60;
        if (interval > 1) return t('timeAgo.minute', { count: Math.floor(interval) });
        return t('timeAgo.now');
    };

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (newComment.trim()) {
            onAddComment(newComment.trim());
            setNewComment('');
        }
    };

    return (
        <div>
            <h3 className="text-sm font-medium text-muted-foreground mb-4 flex items-center gap-2">
                <ChatBubbleOvalLeftEllipsisIcon className="h-5 w-5" />
                {t('comments.title')}
            </h3>
            <div className="space-y-4">
                {comments.length > 0 ? (
                    comments.map(comment => {
                        const commenter = allUsers.find(u => u.id === comment.userId);
                        return (
                            <div key={comment.id} className="flex items-start gap-3">
                                <Avatar user={commenter || null} className="w-8 h-8 flex-shrink-0" />
                                <div>
                                    <div className="flex items-baseline gap-2">
                                        <span className="font-semibold text-sm">{commenter?.name || t('comments.unknownUser')}</span>
                                        <span className="text-xs text-muted-foreground">{timeAgo(comment.createdAt)}</span>
                                    </div>
                                    <p className="text-sm bg-secondary p-2 rounded-lg mt-1">{comment.content}</p>
                                </div>
                            </div>
                        );
                    }).reverse()
                ) : (
                    <p className="text-xs text-muted-foreground text-center py-4">{t('comments.empty')}</p>
                )}
            </div>
            <form onSubmit={handleSubmit} className="mt-4 flex items-start gap-3">
                <Avatar user={currentUser} className="w-8 h-8 flex-shrink-0" />
                <div className="relative flex-grow">
                    <textarea
                        value={newComment}
                        onChange={e => setNewComment(e.target.value)}
                        placeholder={t('comments.placeholder')}
                        rows={1}
                        className="w-full p-2 pr-10 bg-secondary/50 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50 resize-none"
                    />
                    <button type="submit" className="absolute right-1 top-1/2 -translate-y-1/2 p-1.5 rounded-full text-primary hover:bg-primary/10 disabled:opacity-50" disabled={!newComment.trim()}>
                        <PaperAirplaneIcon className="h-5 w-5" />
                    </button>
                </div>
            </form>
        </div>
    );
};

export default CommentSection;

================================================================================

--- FILE: components/collaboration/ShareListModal.tsx ---

import React, { useState } from 'react';
import { List, User } from '../../types';
import { useTaskManager } from '../../hooks/useTaskManager';
import { useUser } from '../../hooks/useUser';
import { CloseIcon, PlusIcon, TrashIcon } from '../../constants';
import Avatar from '../ui/Avatar';
import { useTranslation } from '../../hooks/useI18n';

interface ShareListModalProps {
    list: List;
    onClose: () => void;
}

const ShareListModal: React.FC<ShareListModalProps> = ({ list, onClose }) => {
    const { dispatch } = useTaskManager();
    const { t } = useTranslation();
    const { allUsers, user: currentUser } = useUser();
    const [memberIds, setMemberIds] = useState<string[]>(list.members || []);
    
    const handleAddMember = (userId: string) => {
        if (!memberIds.includes(userId)) {
            setMemberIds([...memberIds, userId]);
        }
    };
    
    const handleRemoveMember = (userId: string) => {
        // Prevent removing the current user (owner)
        if (userId === currentUser?.id) return;
        setMemberIds(memberIds.filter(id => id !== userId));
    };
    
    const handleSave = () => {
        dispatch({ type: 'UPDATE_LIST_MEMBERS', payload: { listId: list.id, memberIds } });
        onClose();
    };

    const potentialMembers = allUsers.filter(u => !memberIds.includes(u.id));

    return (
        <div className="fixed inset-0 bg-black/50 z-40 flex items-center justify-center p-4">
            <div className="bg-card rounded-lg shadow-xl w-full max-w-md">
                <header className="p-4 border-b border-border flex items-center justify-between">
                    <div>
                        <h2 className="text-lg font-semibold">{t('shareList.title', { listName: list.name })}</h2>
                        <p className="text-sm text-muted-foreground">{t('shareList.subtitle')}</p>
                    </div>
                    <button onClick={onClose} className="p-1 rounded-full hover:bg-secondary">
                        <CloseIcon className="h-5 w-5 text-muted-foreground" />
                    </button>
                </header>

                <div className="p-6 max-h-[60vh] overflow-y-auto">
                    <h3 className="text-sm font-medium text-muted-foreground mb-2">{t('shareList.members')}</h3>
                    <div className="space-y-3">
                        {memberIds.map(id => {
                            const member = allUsers.find(u => u.id === id);
                            if (!member) return null;
                            return (
                                <div key={id} className="flex items-center justify-between">
                                    <div className="flex items-center gap-3">
                                        <Avatar user={member} className="w-8 h-8" />
                                        <div>
                                            <p className="font-semibold text-sm">{member.name}</p>
                                            <p className="text-xs text-muted-foreground">{member.email}</p>
                                        </div>
                                    </div>
                                    {member.id !== currentUser?.id ? (
                                        <button onClick={() => handleRemoveMember(id)} className="p-1.5 rounded-md hover:bg-destructive/10 text-muted-foreground hover:text-destructive">
                                            <TrashIcon className="h-4 w-4" />
                                        </button>
                                    ) : (
                                        <span className="text-xs text-muted-foreground pr-2">{t('shareList.owner')}</span>
                                    )}
                                </div>
                            );
                        })}
                    </div>

                    <div className="mt-6">
                         <h3 className="text-sm font-medium text-muted-foreground mb-2">{t('shareList.invite')}</h3>
                         {potentialMembers.length > 0 ? (
                            <div className="space-y-2">
                                {potentialMembers.map(user => (
                                    <div key={user.id} className="flex items-center justify-between p-2 rounded-md hover:bg-secondary">
                                        <div className="flex items-center gap-3">
                                            <Avatar user={user} className="w-8 h-8" />
                                            <div>
                                                <p className="font-semibold text-sm">{user.name}</p>
                                            </div>
                                        </div>
                                        <button onClick={() => handleAddMember(user.id)} className="p-1.5 rounded-md hover:bg-primary/10 text-muted-foreground hover:text-primary">
                                            <PlusIcon className="h-4 w-4" />
                                        </button>
                                    </div>
                                ))}
                            </div>
                         ) : (
                            <p className="text-xs text-muted-foreground text-center py-4">{t('shareList.empty')}</p>
                         )}
                    </div>
                </div>

                <footer className="p-4 bg-secondary/50 rounded-b-lg flex justify-end">
                    <button 
                        onClick={handleSave} 
                        className="px-4 py-2 bg-primary text-primary-foreground rounded-md text-sm font-semibold hover:bg-primary/90"
                    >
                        {t('shareList.done')}
                    </button>
                </footer>
            </div>
        </div>
    );
};

export default ShareListModal;

================================================================================

--- FILE: components/countdown/CountdownView.tsx ---

import React, { useState } from 'react';
import { useTaskManager } from '../../hooks/useTaskManager';
import { CountdownEvent } from '../../types';
import { PlusIcon, TrashIcon, CloseIcon } from '../../constants';
import { useConfirmation } from '../../hooks/useConfirmation';
import { useToast } from '../../hooks/useToast';
import { useTranslation } from '../../hooks/useI18n';

const AddCountdownModal: React.FC<{ onClose: () => void }> = ({ onClose }) => {
    const { dispatch } = useTaskManager();
    const { t } = useTranslation();
    const [name, setName] = useState('');
    const [targetDate, setTargetDate] = useState('');

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (name.trim() && targetDate) {
            const newEvent: CountdownEvent = {
                id: Date.now().toString(),
                name: name.trim(),
                targetDate: new Date(targetDate).toISOString(),
            };
            dispatch({ type: 'ADD_COUNTDOWN', payload: newEvent });
            onClose();
        }
    };
    
    return (
        <div className="fixed inset-0 bg-black/50 z-30 flex items-center justify-center p-4">
            <div className="bg-card rounded-lg shadow-xl w-full max-w-md">
                 <header className="p-4 border-b border-border flex items-center justify-between">
                    <h2 className="text-lg font-semibold">{t('countdown.modal.title')}</h2>
                    <button onClick={onClose} className="p-1 rounded-full hover:bg-secondary">
                        <CloseIcon className="h-5 w-5 text-muted-foreground" />
                    </button>
                </header>
                 <form onSubmit={handleSubmit} className="p-6 space-y-4">
                    <div>
                        <label className="text-sm font-medium text-muted-foreground">{t('countdown.modal.nameLabel')}</label>
                        <input
                            type="text"
                            value={name}
                            onChange={e => setName(e.target.value)}
                            placeholder={t('countdown.modal.namePlaceholder')}
                            className="mt-1 w-full p-2 bg-secondary/50 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50"
                            required
                        />
                    </div>
                    <div>
                        <label className="text-sm font-medium text-muted-foreground">{t('countdown.modal.dateLabel')}</label>
                        <input
                            type="date"
                            value={targetDate}
                            onChange={e => setTargetDate(e.target.value)}
                            className="mt-1 w-full p-2 bg-secondary/50 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50"
                            required
                        />
                    </div>
                     <footer className="pt-2 flex justify-end">
                        <button type="submit" className="px-4 py-2 bg-primary text-primary-foreground rounded-md text-sm font-semibold hover:bg-primary/90">
                            {t('countdown.modal.create')}
                        </button>
                    </footer>
                </form>
            </div>
        </div>
    );
};

const CountdownCard: React.FC<{ event: CountdownEvent }> = ({ event }) => {
    const { dispatch } = useTaskManager();
    const { t } = useTranslation();
    const { confirm } = useConfirmation();
    const addToast = useToast();
    const target = new Date(event.targetDate);
    const now = new Date();
    
    // Set time to 0 to count full days
    target.setHours(0,0,0,0);
    now.setHours(0,0,0,0);

    const diffTime = target.getTime() - now.getTime();
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

    const handleDelete = async () => {
        const isConfirmed = await confirm({
            title: t('countdown.deleteConfirm.title', { eventName: event.name }),
            message: t('countdown.deleteConfirm.message'),
            confirmText: t('countdown.deleteConfirm.confirmText'),
        });
        if(isConfirmed) {
            dispatch({ type: 'DELETE_COUNTDOWN', payload: event.id });
            addToast(t('countdown.deleteSuccess', { eventName: event.name }), 'success');
        }
    }

    return (
        <div className="bg-card border border-border rounded-lg p-6 flex flex-col justify-between relative group">
            <div>
                <h3 className="text-lg font-bold">{event.name}</h3>
                <p className="text-sm text-muted-foreground">
                    {new Date(event.targetDate).toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' })}
                </p>
            </div>
            <div className="text-right mt-4">
                {diffDays < 0 ? (
                    <p className="text-4xl font-bold text-muted-foreground">{t('countdown.card.expired')}</p>
                ) : (
                    <>
                        <p className="text-6xl font-bold text-primary">{diffDays}</p>
                        <p className="text-muted-foreground">{diffDays === 1 ? t('countdown.card.dayRemaining') : t('countdown.card.daysRemaining')}</p>
                    </>
                )}
            </div>
             <button onClick={handleDelete} className="absolute top-2 right-2 p-1.5 rounded-full bg-secondary text-muted-foreground hover:bg-destructive/10 hover:text-destructive opacity-0 group-hover:opacity-100 transition-opacity">
                <TrashIcon className="h-4 w-4"/>
            </button>
        </div>
    );
};

const CountdownView: React.FC = () => {
    const { state } = useTaskManager();
    const { t } = useTranslation();
    const [isModalOpen, setIsModalOpen] = useState(false);

    return (
        <div className="flex-1 flex flex-col overflow-hidden">
            <header className="p-6 border-b border-border flex-shrink-0 flex flex-wrap items-center justify-between gap-4">
                <div>
                    <h1 className="text-2xl font-bold">{t('countdownView.title')}</h1>
                    <p className="text-muted-foreground">{t('countdownView.subtitle')}</p>
                </div>
                <button
                    onClick={() => setIsModalOpen(true)}
                    className="flex items-center gap-2 px-4 py-2 bg-primary text-primary-foreground rounded-md text-sm font-semibold hover:bg-primary/90"
                >
                    <PlusIcon className="h-5 w-5" />
                    {t('countdownView.add')}
                </button>
            </header>
            <main className="flex-1 p-4 md:p-6 overflow-y-auto pb-20 md:pb-6">
                {state.countdownEvents.length > 0 ? (
                    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
                        {state.countdownEvents.map(event => (
                            <CountdownCard key={event.id} event={event} />
                        ))}
                    </div>
                ) : (
                    <div className="text-center py-20 text-muted-foreground">
                        <h2 className="text-xl font-semibold">{t('countdownView.emptyState.title')}</h2>
                        <p>{t('countdownView.emptyState.subtitle')}</p>
                    </div>
                )}
            </main>
            {isModalOpen && <AddCountdownModal onClose={() => setIsModalOpen(false)} />}
        </div>
    );
};

export default CountdownView;

================================================================================

--- FILE: components/dashboard/DashboardView.tsx ---

import React, { useMemo, useState, useEffect } from 'react';
import { useTaskManager } from '../../hooks/useTaskManager';
import { useTranslation } from '../../hooks/useI18n';
import { SparklesIcon, CalendarDayIcon, CalendarIcon, RepeatIcon } from '../../constants';
import ProductivityHeatmap from './ProductivityHeatmap';

interface DashboardViewProps {
    onBriefingToggle: () => void;
}

const useCountUp = (end: number, duration = 1200) => {
    const [count, setCount] = useState(0);

    useEffect(() => {
        let startTimestamp: number | null = null;
        const step = (timestamp: number) => {
            if (!startTimestamp) startTimestamp = timestamp;
            const progress = Math.min((timestamp - startTimestamp) / duration, 1);
            const current = Math.floor(progress * end);
            setCount(current);
            if (progress < 1) {
                requestAnimationFrame(step);
            }
        };
        requestAnimationFrame(step);
    }, [end, duration]);

    return count;
};

const isToday = (date: Date): boolean => {
    const today = new Date();
    return date.getDate() === today.getDate() &&
           date.getMonth() === today.getMonth() &&
           date.getFullYear() === today.getFullYear();
};

const isFuture = (date: Date): boolean => {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const otherDate = new Date(date);
    otherDate.setHours(0, 0, 0, 0);
    return otherDate.getTime() > today.getTime();
}

const isOverdue = (date: Date): boolean => {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const checkDate = new Date(date);
    checkDate.setHours(0, 0, 0, 0);
    return checkDate.getTime() < today.getTime();
}

const toYYYYMMDD = (date: Date) => date.toISOString().split('T')[0];

const DashboardView: React.FC<DashboardViewProps> = ({ onBriefingToggle }) => {
    const { state, dispatch } = useTaskManager();
    const { t } = useTranslation();

    const stats = useMemo(() => {
        const uncompletedTasks = state.tasks.filter(t => !t.completed);
        const todayTasks = uncompletedTasks.filter(t => {
            if (!t.dueDate) return false;
            const taskDate = new Date(t.dueDate);
            return isToday(taskDate) || isOverdue(taskDate);
        }).length;

        const upcomingTasks = uncompletedTasks.filter(t => t.dueDate && isFuture(new Date(t.dueDate))).length;
        
        const todayStr = toYYYYMMDD(new Date());
        const habitsToday = state.habits.filter(h => h.completions.includes(todayStr)).length;

        return {
            today: todayTasks,
            upcoming: upcomingTasks,
            habitsCompleted: habitsToday,
            habitsTotal: state.habits.length
        };
    }, [state.tasks, state.habits]);
    
    const animatedToday = useCountUp(stats.today);
    const animatedUpcoming = useCountUp(stats.upcoming);
    const animatedHabits = useCountUp(stats.habitsCompleted);

    const getGreeting = () => {
        const hour = new Date().getHours();
        if (hour < 12) return t('dashboard.greeting.morning');
        if (hour < 18) return t('dashboard.greeting.afternoon');
        return t('dashboard.greeting.evening');
    }

    return (
        <div className="flex-1 flex flex-col overflow-y-auto">
            <header className="p-6 border-b border-border">
                <h1 className="text-3xl font-bold">{getGreeting()}</h1>
                <p className="text-muted-foreground">{t('dashboard.subtitle')}</p>
            </header>
            <main className="flex-1 p-4 md:p-6 space-y-8">
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
                    <button 
                        onClick={() => dispatch({ type: 'SET_ACTIVE_LIST', payload: 'today' })}
                        className="bg-card border border-border rounded-lg p-6 flex items-start gap-4 text-left hover:shadow-md hover:border-primary/50 transition-all"
                    >
                        <div className="bg-blue-500/10 text-blue-500 p-3 rounded-lg">
                            <CalendarDayIcon className="h-6 w-6" />
                        </div>
                        <div>
                            <p className="text-sm text-muted-foreground">{t('dashboard.stat.today')}</p>
                            <p className="text-3xl font-bold">{animatedToday}</p>
                        </div>
                    </button>
                     <button 
                        onClick={() => dispatch({ type: 'SET_ACTIVE_LIST', payload: 'upcoming' })}
                        className="bg-card border border-border rounded-lg p-6 flex items-start gap-4 text-left hover:shadow-md hover:border-primary/50 transition-all"
                    >
                        <div className="bg-purple-500/10 text-purple-500 p-3 rounded-lg">
                            <CalendarIcon className="h-6 w-6" />
                        </div>
                        <div>
                            <p className="text-sm text-muted-foreground">{t('dashboard.stat.upcoming')}</p>
                            <p className="text-3xl font-bold">{animatedUpcoming}</p>
                        </div>
                    </button>
                     <button 
                        onClick={() => dispatch({ type: 'SET_VIEW', payload: 'habit' })}
                        className="bg-card border border-border rounded-lg p-6 flex items-start gap-4 text-left hover:shadow-md hover:border-primary/50 transition-all"
                     >
                        <div className="bg-green-500/10 text-green-500 p-3 rounded-lg">
                            <RepeatIcon className="h-6 w-6" />
                        </div>
                        <div>
                            <p className="text-sm text-muted-foreground">{t('dashboard.stat.habits')}</p>
                            <p className="text-3xl font-bold">{animatedHabits}/{stats.habitsTotal}</p>
                        </div>
                    </button>
                </div>

                <div>
                    <h2 className="text-xl font-bold mb-4">{t('dashboard.heatmapTitle')}</h2>
                    <ProductivityHeatmap />
                </div>


                <div className="bg-card border border-border rounded-lg p-8 text-center flex flex-col items-center">
                    <div className="bg-primary/10 text-primary p-4 rounded-full mb-4">
                         <SparklesIcon className="h-8 w-8" />
                    </div>
                    <h2 className="text-xl font-bold mb-2">{t('dashboard.cta.title')}</h2>
                    <p className="text-muted-foreground max-w-md mx-auto mb-6">
                        {t('dashboard.cta.subtitle')}
                    </p>
                     <button
                        onClick={onBriefingToggle}
                        className="flex items-center gap-2 px-6 py-3 bg-primary text-primary-foreground rounded-full text-md font-semibold hover:bg-primary/90 transition-transform hover:scale-105"
                    >
                        <SparklesIcon className="h-5 w-5" />
                        {t('dashboard.cta.button')}
                    </button>
                </div>
            </main>
        </div>
    );
};

export default DashboardView;

================================================================================

--- FILE: components/dashboard/ProductivityHeatmap.tsx ---

import React, { useMemo, useRef, useState, useEffect } from 'react';
import { useTaskManager } from '../../hooks/useTaskManager';
import { useTranslation } from '../../hooks/useI18n';
import { useSettings } from '../../hooks/useSettings';

const CELL_SIZE = 12; // Corresponds to w-3
const CELL_GAP = 4;   // Corresponds to gap-1
const WEEK_WIDTH = CELL_SIZE + CELL_GAP;
const DAY_LABELS_WIDTH = 30; // Approx width for 'Mon', 'Wed', 'Fri' labels and margin

const ProductivityHeatmap: React.FC = () => {
    const { state } = useTaskManager();
    const { t } = useTranslation();
    const { language } = useSettings();
    const containerRef = useRef<HTMLDivElement>(null);
    const [containerWidth, setContainerWidth] = useState(0);

    // Get container width on resize
    useEffect(() => {
        const observer = new ResizeObserver(entries => {
            if (entries[0]) {
                setContainerWidth(entries[0].contentRect.width);
            }
        });
        const currentRef = containerRef.current;
        if (currentRef) {
            observer.observe(currentRef);
        }
        return () => {
            if (currentRef) {
                observer.unobserve(currentRef);
            }
        };
    }, []);

    const { contributions, maxContribution } = useMemo(() => {
        const contribs: { [date: string]: { tasks: number, pomos: number, total: number } } = {};
        let max = 1;

        state.tasks.forEach(task => {
            if (task.completed && task.completedAt) {
                const dateStr = new Date(task.completedAt).toISOString().split('T')[0];
                if (!contribs[dateStr]) contribs[dateStr] = { tasks: 0, pomos: 0, total: 0 };
                contribs[dateStr].tasks += 1;
                contribs[dateStr].total += 2;
                if (contribs[dateStr].total > max) max = contribs[dateStr].total;
            }
        });

        state.pomodoro.focusHistory.forEach(session => {
            const dateStr = new Date(session.startTime).toISOString().split('T')[0];
            if (!contribs[dateStr]) contribs[dateStr] = { tasks: 0, pomos: 0, total: 0 };
            contribs[dateStr].pomos += 1;
            contribs[dateStr].total += 1;
            if (contribs[dateStr].total > max) max = contribs[dateStr].total;
        });

        return { contributions: contribs, maxContribution: max };
    }, [state.tasks, state.pomodoro.focusHistory]);

    // Calculate which days and month labels to show based on width
    const { weeks, monthLabels, dayLabels } = useMemo(() => {
        const localDayLabels = Array.from({ length: 7 }, (_, i) => {
             // A known Sunday is Jan 7, 2024
            const day = new Date(2024, 0, 7 + i); 
            return day.toLocaleDateString(language, { weekday: 'short' });
        });

        if (containerWidth === 0) {
            return { weeks: [], monthLabels: [], dayLabels: localDayLabels };
        }

        const availableWidth = containerWidth > DAY_LABELS_WIDTH ? containerWidth - DAY_LABELS_WIDTH : 0;
        const numWeeks = Math.max(1, Math.min(52, Math.floor(availableWidth / WEEK_WIDTH)));
        
        const today = new Date();
        const endDate = new Date(today);
        // Align to the end of the week (Saturday) to ensure full columns
        endDate.setDate(endDate.getDate() + (6 - endDate.getDay()));

        const days = [];
        for (let i = 0; i < numWeeks * 7; i++) {
            const date = new Date(endDate);
            date.setDate(endDate.getDate() - i);
            days.push(date);
        }
        days.reverse();
        
        const weeksData = [];
        const labels: { label: string, index: number }[] = [];
        let lastMonth = -1;

        for (let i = 0; i < numWeeks; i++) {
            const week = days.slice(i * 7, (i + 1) * 7);
            weeksData.push(week);

            // Find month label
            const firstDayOfWeek = week[0];
            if (firstDayOfWeek) {
                const month = firstDayOfWeek.getMonth();
                if (month !== lastMonth) {
                    const lastLabelIndex = labels.length > 0 ? labels[labels.length - 1].index : -5;
                    // Heuristic to prevent label overlap on smaller screens
                    if (i > lastLabelIndex + 3) { 
                        labels.push({ label: firstDayOfWeek.toLocaleDateString(language, { month: 'short' }), index: i });
                        lastMonth = month;
                    }
                }
            }
        }
        
        return { weeks: weeksData, monthLabels: labels, dayLabels: localDayLabels };

    }, [containerWidth, language]);
    
    const getColorClass = (count: number) => {
        if (count === 0) return 'bg-secondary';
        const ratio = count / maxContribution;
        if (ratio < 0.25) return 'bg-primary/20';
        if (ratio < 0.5) return 'bg-primary/40';
        if (ratio < 0.75) return 'bg-primary/70';
        return 'bg-primary';
    };
    
    const getTooltipText = (date: Date) => {
        const dateStr = date.toISOString().split('T')[0];
        const data = contributions[dateStr];
        const formattedDate = date.toLocaleDateString(language, { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
        
        if (!data || data.total === 0) {
            return t('heatmap.tooltip.noActivity', { date: formattedDate });
        }
        
        return t('heatmap.tooltip.activity', {
            date: formattedDate,
            tasksCount: data.tasks,
            pomosCount: data.pomos
        });
    };

    return (
        <div ref={containerRef} className="bg-card border border-border p-4 rounded-lg overflow-hidden">
            <div className="flex flex-col">
                 {/* Month Labels */}
                <div className="h-5 mb-1 relative" style={{ marginLeft: `${DAY_LABELS_WIDTH}px` }}>
                    {monthLabels.map(({ label, index }) => (
                        <div
                            key={label + index}
                            className="absolute top-0 text-xs text-muted-foreground"
                            style={{ left: `${index * WEEK_WIDTH}px` }}
                        >
                            {label}
                        </div>
                    ))}
                </div>

                <div className="flex gap-3">
                    {/* Day Labels */}
                    <div className="flex flex-col gap-1 text-xs text-muted-foreground pt-0.5" style={{ minWidth: `${DAY_LABELS_WIDTH - 3}px`, width: `${DAY_LABELS_WIDTH - 3}px` }}>
                        <div className="h-3"></div> {/* Sun */}
                        <div className="h-3">{dayLabels[1]}</div>
                        <div className="h-3"></div> {/* Tue */}
                        <div className="h-3">{dayLabels[3]}</div>
                        <div className="h-3"></div> {/* Thu */}
                        <div className="h-3">{dayLabels[5]}</div>
                        <div className="h-3"></div> {/* Sat */}
                    </div>

                    {/* Heatmap Grid */}
                    <div className="flex gap-1">
                        {weeks.map((week, weekIndex) => (
                            <div key={weekIndex} className="flex flex-col gap-1">
                                {week.map((day, dayIndex) => {
                                    if (!day) {
                                        return <div key={`empty-${weekIndex}-${dayIndex}`} className="w-3 h-3" />;
                                    }
                                    const date = day as Date;
                                    const count = contributions[date.toISOString().split('T')[0]]?.total || 0;
                                    const isFuture = date > new Date();

                                    return (
                                        <div
                                            key={date.toISOString()}
                                            className={`w-3 h-3 rounded-sm ${isFuture ? 'bg-muted/20' : getColorClass(count)}`}
                                            title={isFuture ? t('heatmap.tooltip.future') : getTooltipText(date)}
                                        />
                                    );
                                })}
                            </div>
                        ))}
                    </div>
                </div>
            </div>
        </div>
    );
};

export default ProductivityHeatmap;

================================================================================

--- FILE: components/habit/HabitView.tsx ---


import React, { useState } from 'react';
import { useTaskManager } from '../../hooks/useTaskManager';
import { Habit } from '../../types';
import { PlusIcon, TrashIcon, ArrowDownIcon } from '../../constants';
import { useConfirmation } from '../../hooks/useConfirmation';
import { useToast } from '../../hooks/useToast';
import { useTranslation } from '../../hooks/useI18n';
import { useSettings } from '../../hooks/useSettings';

const toYYYYMMDD = (date: Date) => date.toISOString().split('T')[0];

const calculateStreak = (completions: string[]): number => {
    if (completions.length === 0) return 0;

    const sortedDates = completions.map(d => new Date(d)).sort((a, b) => b.getTime() - a.getTime());
    let streak = 0;
    let today = new Date();
    
    // Check if latest completion is today or yesterday
    const latestCompletion = sortedDates[0];
    const todayStr = toYYYYMMDD(today);
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    const yesterdayStr = toYYYYMMDD(yesterday);
    const latestCompletionStr = toYYYYMMDD(latestCompletion);

    if (latestCompletionStr === todayStr || latestCompletionStr === yesterdayStr) {
        streak = 1;
        let currentStreakDate = latestCompletion;
        for (let i = 1; i < sortedDates.length; i++) {
            const nextExpectedDate = new Date(currentStreakDate);
            nextExpectedDate.setDate(nextExpectedDate.getDate() - 1);
            if (toYYYYMMDD(sortedDates[i]) === toYYYYMMDD(nextExpectedDate)) {
                streak++;
                currentStreakDate = sortedDates[i];
            } else if (toYYYYMMDD(sortedDates[i]) !== toYYYYMMDD(currentStreakDate)) {
                // a gap in dates
                break;
            }
        }
    }

    return streak;
};

const HabitHeatmap: React.FC<{ completions: string[] }> = ({ completions }) => {
    const { t } = useTranslation();
    const { language } = useSettings();
    const today = new Date();
    const startDate = new Date();
    startDate.setMonth(today.getMonth() - 5);
    startDate.setDate(1);

    const completionsSet = new Set(completions);
    const days = [];
    let currentDate = new Date(startDate);
    
    // Pad start date to be a Monday
    const dayOfWeek = (startDate.getDay() + 6) % 7; // Monday is 0
    for (let i = 0; i < dayOfWeek; i++) {
        days.push({ date: null, completed: false });
    }

    while (currentDate <= today) {
        const dateStr = toYYYYMMDD(currentDate);
        days.push({ date: new Date(currentDate), completed: completionsSet.has(dateStr) });
        currentDate.setDate(currentDate.getDate() + 1);
    }

    const monthLabels = Array.from({ length: 6 }).map((_, i) => {
        const date = new Date(today);
        date.setMonth(today.getMonth() - i);
        return date.toLocaleDateString(language, { month: 'short' });
    }).reverse();

    return (
        <div className="mt-4 p-4 bg-secondary/50 rounded-lg">
            <div className="grid grid-cols-[repeat(auto-fit,minmax(1rem,1fr))] grid-rows-7 grid-flow-col gap-1">
                {days.map((day, index) => (
                    <div
                        key={index}
                        className={`w-4 h-4 rounded-sm ${day.date ? (day.completed ? 'bg-primary' : 'bg-muted') : 'bg-transparent'}`}
                        title={day.date ? t(day.completed ? 'habit.heatmap.tooltip.completed' : 'habit.heatmap.tooltip.notCompleted', { date: day.date.toLocaleDateString() }) : ''}
                    />
                ))}
            </div>
             <div className="flex justify-between text-xs text-muted-foreground mt-2 px-1">
                {monthLabels.map(label => <span key={label}>{label}</span>)}
            </div>
        </div>
    );
};


const HabitItem: React.FC<{ habit: Habit }> = ({ habit }) => {
    const { dispatch } = useTaskManager();
    const { confirm } = useConfirmation();
    const { t } = useTranslation();
    const { language } = useSettings();
    const addToast = useToast();
    const [isExpanded, setIsExpanded] = useState(false);

    const today = new Date();
    const weekDays = Array.from({ length: 7 }).map((_, i) => {
        const date = new Date();
        date.setDate(today.getDate() - (6 - i));
        return date;
    });

    const completionsSet = new Set(habit.completions);
    const streak = calculateStreak(habit.completions);

    const handleToggle = (date: Date) => {
        dispatch({
            type: 'TOGGLE_HABIT_COMPLETION',
            payload: { habitId: habit.id, date: toYYYYMMDD(date) }
        });
    };
    
    const handleDelete = async () => {
        const isConfirmed = await confirm({
            title: t('habit.deleteConfirm.title', { habitName: habit.name }),
            message: t('habit.deleteConfirm.message'),
            confirmText: t('habit.deleteConfirm.confirmText'),
        });
        if (isConfirmed) {
            dispatch({ type: 'DELETE_HABIT', payload: habit.id });
            addToast(t('habit.deleteSuccess', { habitName: habit.name }), 'success');
        }
    }

    return (
         <div className="bg-card p-4 rounded-lg border border-border">
            <div className="flex flex-col md:flex-row items-start md:items-center justify-between gap-4">
                <div className="flex-grow">
                    <h3 className="font-semibold">{habit.name}</h3>
                    <p className="text-sm text-muted-foreground">{streak > 0 ? t('habit.streak', { count: streak }) : t('habit.noStreak')}</p>
                </div>
                <div className="flex items-center gap-2">
                    <div className="flex flex-wrap items-center gap-1.5">
                        {weekDays.map(date => {
                            const dateString = toYYYYMMDD(date);
                            const isCompleted = completionsSet.has(dateString);
                            const isFuture = date > new Date();
                            return (
                                <button
                                    key={dateString}
                                    disabled={isFuture}
                                    onClick={() => handleToggle(date)}
                                    className={`w-8 h-8 rounded-full flex flex-col items-center justify-center transition-colors text-xs ${
                                        isCompleted ? 'bg-primary text-primary-foreground' : 'bg-secondary hover:bg-muted'
                                    } ${isFuture ? 'opacity-50 cursor-not-allowed' : ''}`}
                                >
                                    <span>{date.toLocaleDateString(language, { weekday: 'short' })[0]}</span>
                                    <span className="font-bold">{date.getDate()}</span>
                                </button>
                            );
                        })}
                    </div>
                    <button onClick={() => setIsExpanded(!isExpanded)} className="p-2 rounded-md text-muted-foreground hover:bg-secondary">
                        <ArrowDownIcon className={`h-5 w-5 transition-transform ${isExpanded ? 'rotate-180' : ''}`} />
                    </button>
                    <button onClick={handleDelete} className="p-2 rounded-md text-muted-foreground hover:bg-destructive/10 hover:text-destructive">
                        <TrashIcon className="h-5 w-5" />
                    </button>
                </div>
            </div>
            {isExpanded && <HabitHeatmap completions={habit.completions} />}
        </div>
    );
};

const HabitView: React.FC = () => {
    const { state, dispatch } = useTaskManager();
    const { t } = useTranslation();
    const [newHabitName, setNewHabitName] = useState('');

    const handleAddHabit = (e: React.FormEvent) => {
        e.preventDefault();
        if (newHabitName.trim()) {
            dispatch({ type: 'ADD_HABIT', payload: { name: newHabitName.trim() } });
            setNewHabitName('');
        }
    };

    return (
        <div className="flex-1 flex flex-col h-full">
            <header className="p-6 border-b border-border flex-shrink-0">
                <h1 className="text-2xl font-bold">{t('habitView.title')}</h1>
                <p className="text-muted-foreground">{t('habitView.subtitle')}</p>
            </header>
            <main className="flex-1 p-4 md:p-6 overflow-y-auto">
                <div className="space-y-4">
                    {state.habits.length > 0 ? (
                        state.habits.map(habit => (
                            <HabitItem key={habit.id} habit={habit} />
                        ))
                    ) : (
                         <div className="text-center py-20 text-muted-foreground">
                            <h2 className="text-xl font-semibold">{t('habitView.emptyState.title')}</h2>
                            <p>{t('habitView.emptyState.subtitle')}</p>
                        </div>
                    )}
                </div>
            </main>
            <footer className="p-4 border-t border-border bg-background flex-shrink-0 md:pb-4 pb-20">
                 <form onSubmit={handleAddHabit} className="flex items-center gap-4">
                    <input
                        type="text"
                        value={newHabitName}
                        onChange={(e) => setNewHabitName(e.target.value)}
                        placeholder={t('habitView.addPlaceholder')}
                        className="w-full p-3 bg-secondary rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50"
                    />
                    <button type="submit" className="p-3 bg-primary text-primary-foreground rounded-md hover:bg-primary/90">
                        <PlusIcon className="h-6 w-6" />
                    </button>
                </form>
            </footer>
        </div>
    );
};

export default HabitView;

================================================================================

--- FILE: components/landing/LandingPage.tsx ---

import React from 'react';
import { SparklesIcon, GridIcon, ArchiveBoxIcon, HeroIllustration } from '../../constants';
import Avatar from '../ui/Avatar';
import { useTranslation } from '../../hooks/useI18n';
import LanguageSwitcher from '../ui/LanguageSwitcher';

interface LandingPageProps {
    onLaunch: () => void;
}

const LandingPage: React.FC<LandingPageProps> = ({ onLaunch }) => {
    const { t } = useTranslation();

    return (
        <div className="bg-background text-foreground min-h-screen">
            <header className="sticky top-0 z-50 bg-background/80 backdrop-blur-lg border-b border-border">
                <div className="container mx-auto px-6 py-4 flex justify-between items-center">
                    <div className="flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256" className="h-8 w-8 text-primary">
                            <rect width="256" height="256" fill="none"></rect>
                            <path d="M128,24a104,104,0,1,0,104,104A104.11,104.11,0,0,0,128,24Zm45.15,122.34-8.6-14.9a4,4,0,0,0-6.92,0l-22.1,38.28a4,4,0,0,1-3.46,2H92a4,4,0,0,1-3.46-6l25.56-44.28a4,4,0,0,0-3.46-6H65.75a4,4,0,0,1,0-8h42.39a4,4,0,0,1,3.46,6l-25.56,44.28a4,4,0,0,0,3.46,6h22.54a4,4,0,0,1,3.46-2l22.1-38.28a4,4,0,0,0-3.46-6H134.25a4,4,0,0,1,0-8h42.39a4,4,0,0,1,3.46,2l8.6,14.9a4,4,0,0,1-3.46,6H173.15a4,4,0,0,1,0,8h-3.46a4,4,0,0,1-3.46-2Z"></path>
                        </svg>
                        <h1 className="text-xl font-bold">TaskFlow</h1>
                    </div>
                    <div className="flex items-center gap-4">
                        <LanguageSwitcher />
                        <button 
                            onClick={onLaunch}
                            className="px-4 py-2 text-sm font-semibold bg-primary text-primary-foreground rounded-md hover:bg-primary/90"
                        >
                            {t('landing.nav.launch')}
                        </button>
                    </div>
                </div>
            </header>

            <main className="container mx-auto px-6">
                {/* Hero Section */}
                <section className="text-center py-20">
                    <h2 className="text-4xl md:text-6xl font-extrabold mb-4 bg-gradient-to-r from-primary via-blue-500 to-purple-600 bg-clip-text text-transparent">
                        {t('landing.hero.title')}
                    </h2>
                    <p className="text-lg md:text-xl text-muted-foreground max-w-3xl mx-auto mb-8">
                        {t('landing.hero.subtitle')}
                    </p>
                    <button 
                        onClick={onLaunch}
                        className="px-8 py-4 bg-primary text-primary-foreground rounded-full text-lg font-bold hover:bg-primary/90 transition-transform hover:scale-105"
                    >
                        {t('landing.hero.cta')}
                    </button>
                    <div className="relative">
                        <div className="absolute inset-0 bg-primary/5 blur-3xl rounded-full -z-10"></div>
                        <HeroIllustration className="w-full max-w-3xl mx-auto mt-16" />
                    </div>
                </section>

                {/* Features Section */}
                <section className="py-20">
                    <div className="text-center mb-12">
                         <h3 className="text-3xl md:text-4xl font-bold">{t('landing.features.title')}</h3>
                         <p className="text-muted-foreground mt-2">{t('landing.features.subtitle')}</p>
                    </div>
                    <div className="grid md:grid-cols-3 gap-8">
                        <div className="bg-card p-8 rounded-xl border border-border hover:border-primary/50 hover:shadow-lg transition-all">
                            <div className="p-3 inline-block bg-primary/10 rounded-lg mb-4">
                                <SparklesIcon className="h-8 w-8 text-primary" />
                            </div>
                            <h3 className="text-xl font-bold mb-2">{t('landing.feature1.title')}</h3>
                            <p className="text-muted-foreground">
                                {t('landing.feature1.description')}
                            </p>
                        </div>
                        <div className="bg-card p-8 rounded-xl border border-border hover:border-primary/50 hover:shadow-lg transition-all">
                            <div className="p-3 inline-block bg-primary/10 rounded-lg mb-4">
                                <GridIcon className="h-8 w-8 text-primary" />
                            </div>
                            <h3 className="text-xl font-bold mb-2">{t('landing.feature2.title')}</h3>
                            <p className="text-muted-foreground">
                                {t('landing.feature2.description')}
                            </p>
                        </div>
                        <div className="bg-card p-8 rounded-xl border border-border hover:border-primary/50 hover:shadow-lg transition-all">
                             <div className="p-3 inline-block bg-primary/10 rounded-lg mb-4">
                                <ArchiveBoxIcon className="h-8 w-8 text-primary" />
                            </div>
                            <h3 className="text-xl font-bold mb-2">{t('landing.feature3.title')}</h3>
                            <p className="text-muted-foreground">
                                {t('landing.feature3.description')}
                            </p>
                        </div>
                    </div>
                </section>

                {/* Testimonials Section */}
                <section className="py-20">
                     <div className="text-center mb-12">
                         <h3 className="text-3xl md:text-4xl font-bold">{t('landing.testimonials.title')}</h3>
                         <p className="text-muted-foreground mt-2">{t('landing.testimonials.subtitle')}</p>
                    </div>
                    <div className="grid md:grid-cols-2 gap-8 max-w-4xl mx-auto">
                        <div className="bg-card p-6 rounded-xl border border-border">
                            <p className="text-muted-foreground mb-4">{t('landing.testimonial1.quote')}</p>
                            <div className="flex items-center gap-3">
                                <Avatar user={{id: 't1', name: t('landing.testimonial1.author'), email: ''}} className="w-10 h-10"/>
                                <div>
                                    <p className="font-semibold">{t('landing.testimonial1.author')}</p>
                                    <p className="text-sm text-muted-foreground">{t('landing.testimonial1.role')}</p>
                                </div>
                            </div>
                        </div>
                        <div className="bg-card p-6 rounded-xl border border-border">
                            <p className="text-muted-foreground mb-4">{t('landing.testimonial2.quote')}</p>
                             <div className="flex items-center gap-3">
                                <Avatar user={{id: 't2', name: t('landing.testimonial2.author'), email: ''}} className="w-10 h-10"/>
                                <div>
                                    <p className="font-semibold">{t('landing.testimonial2.author')}</p>
                                    <p className="text-sm text-muted-foreground">{t('landing.testimonial2.role')}</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                 {/* CTA Section */}
                <section className="py-20 text-center bg-secondary rounded-2xl my-20">
                     <h3 className="text-3xl md:text-4xl font-bold mb-4">{t('landing.cta.title')}</h3>
                     <p className="text-muted-foreground max-w-xl mx-auto mb-8">
                        {t('landing.cta.subtitle')}
                    </p>
                    <button 
                        onClick={onLaunch}
                        className="px-8 py-4 bg-primary text-primary-foreground rounded-full text-lg font-bold hover:bg-primary/90 transition-transform hover:scale-105"
                    >
                        {t('landing.cta.button')}
                    </button>
                </section>

            </main>

            <footer className="text-center py-8 border-t border-border">
                <p className="text-sm text-muted-foreground">{t('landing.footer.copyright', { year: new Date().getFullYear() })}</p>
            </footer>
        </div>
    );
};

export default LandingPage;


================================================================================

--- FILE: components/layout/BottomNavBar.tsx ---

import React, { useState, useRef, useEffect } from 'react';
import { useTaskManager } from '../../hooks/useTaskManager';
import { useSettings } from '../../hooks/useSettings';
import { useTranslation } from '../../hooks/useI18n';
import { ViewType } from '../../types';
import { StopwatchIcon, ListBulletIcon, CalendarDaysIcon, GridIcon, RepeatIcon, HourglassIcon, HomeIcon, ViewColumnsIcon } from '../../constants';

const ALL_FEATURES: { view: ViewType, icon: React.FC<{className?: string}>, label: string }[] = [
    { view: 'dashboard', icon: HomeIcon, label: 'feature.dashboard' },
    { view: 'list', icon: ListBulletIcon, label: 'feature.listView' },
    { view: 'board', icon: ViewColumnsIcon, label: 'feature.boardView' },
    { view: 'calendar', icon: CalendarDaysIcon, label: 'feature.calendarView' },
    { view: 'matrix', icon: GridIcon, label: 'feature.matrixView' },
    { view: 'habit', icon: RepeatIcon, label: 'feature.habitTracker' },
    { view: 'pomodoro', icon: StopwatchIcon, label: 'feature.pomodoro' },
    { view: 'countdown', icon: HourglassIcon, label: 'feature.countdown' },
];

const MoreMenu: React.FC<{ hiddenViews: ViewType[], onClose: () => void }> = ({ hiddenViews, onClose }) => {
    const { dispatch } = useTaskManager();
    const { t } = useTranslation();
    const menuRef = useRef<HTMLDivElement>(null);

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
                onClose();
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, [onClose]);

    const handleSelect = (view: ViewType) => {
        dispatch({ type: 'SET_VIEW', payload: view });
        onClose();
    };

    return (
        <div ref={menuRef} className="absolute bottom-full right-0 mb-2 w-48 bg-popover rounded-lg shadow-2xl border border-border animate-fade-in p-2">
            <div className="space-y-1">
                {hiddenViews.map(view => {
                    const feature = ALL_FEATURES.find(f => f.view === view);
                    if (!feature) return null;
                    const Icon = feature.icon;
                    return (
                        <button 
                            key={view} 
                            onClick={() => handleSelect(view)}
                            className="w-full flex items-center gap-3 px-3 py-2 text-sm rounded-md hover:bg-secondary"
                        >
                            <Icon className="h-5 w-5 text-muted-foreground" />
                            <span>{t(feature.label)}</span>
                        </button>
                    )
                })}
            </div>
        </div>
    );
};

const BottomNavBar: React.FC = () => {
    const { state, dispatch } = useTaskManager();
    const { bottomNavActions } = useSettings();
    const { t } = useTranslation();
    const [isMoreMenuOpen, setIsMoreMenuOpen] = useState(false);

    const visibleFeatures = ALL_FEATURES.filter(f => bottomNavActions.includes(f.view));
    const hiddenFeatures = ALL_FEATURES.filter(f => !bottomNavActions.includes(f.view)).map(f => f.view);
    
    const NavButton: React.FC<{
        feature: typeof ALL_FEATURES[0];
        isActive: boolean;
    }> = ({ feature, isActive }) => {
        const Icon = feature.icon;
        return (
            <button
                onClick={() => dispatch({ type: 'SET_VIEW', payload: feature.view })}
                className={`flex flex-col items-center justify-center gap-1 flex-1 transition-colors p-1 ${
                    isActive ? 'text-primary' : 'text-muted-foreground hover:text-foreground'
                }`}
            >
                <Icon className="h-6 w-6" />
                <span className="text-[10px] font-medium">{t(feature.label)}</span>
            </button>
        );
    };

    return (
        <nav className="md:hidden fixed bottom-0 left-0 right-0 h-16 bg-card/80 backdrop-blur-lg border-t border-border flex items-stretch justify-around z-30">
            {visibleFeatures.map(feature => (
                <NavButton key={feature.view} feature={feature} isActive={state.view === feature.view} />
            ))}
            {hiddenFeatures.length > 0 && (
                <div className="relative">
                    <button
                        onClick={() => setIsMoreMenuOpen(p => !p)}
                        className={`flex flex-col items-center justify-center gap-1 flex-1 transition-colors p-1 h-full w-16 ${
                            isMoreMenuOpen ? 'text-primary' : 'text-muted-foreground hover:text-foreground'
                        }`}
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                            <path strokeLinecap="round" strokeLinejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z" />
                        </svg>
                        <span className="text-[10px] font-medium">{t('feature.more')}</span>
                    </button>
                    {isMoreMenuOpen && <MoreMenu hiddenViews={hiddenFeatures} onClose={() => setIsMoreMenuOpen(false)} />}
                </div>
            )}
        </nav>
    );
};

export default BottomNavBar;

================================================================================

--- FILE: components/layout/FeatureBar.tsx ---

import React, { useState, useRef, useEffect } from 'react';
import { MenuIcon, StopwatchIcon, ListBulletIcon, CalendarDaysIcon, GridIcon, RepeatIcon, HourglassIcon, HomeIcon, ViewColumnsIcon, UserCircleIcon, SettingsIcon, TrophyIcon } from '../../constants';
import { useTaskManager } from '../../hooks/useTaskManager';
import { useUser } from '../../hooks/useUser';
import Avatar from '../ui/Avatar';
import ProfileDropdown from '../auth/ProfileDropdown';
import { useTranslation } from '../../hooks/useI18n';

interface FeatureBarProps {
    onSidebarToggle: () => void;
}

const FeatureBar: React.FC<FeatureBarProps> = ({ onSidebarToggle }) => {
    const { state, dispatch } = useTaskManager();
    const { user } = useUser();
    const { t } = useTranslation();
    const [isDropdownOpen, setDropdownOpen] = useState(false);
    const dropdownRef = useRef<HTMLDivElement>(null);

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
                setDropdownOpen(false);
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => {
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, []);
    
    const NavButton: React.FC<{
        label: string;
        onClick: () => void;
        isActive?: boolean;
        children: React.ReactNode;
        className?: string;
    }> = ({ label, onClick, isActive, children, className }) => (
        <button
            onClick={onClick}
            title={label}
            aria-label={label}
            className={`w-12 h-12 flex items-center justify-center rounded-lg transition-colors flex-shrink-0 ${
                isActive ? 'bg-primary/10 text-primary' : 'text-muted-foreground hover:bg-muted hover:text-foreground'
            } ${className}`}
        >
            {children}
        </button>
    );

    return (
        <nav className="hidden md:flex flex-col flex-shrink-0 w-16 h-full border-r border-border items-center py-4 justify-between">
            <div className="flex flex-col items-center gap-2">
                <NavButton label={t('feature.toggleSidebar')} onClick={onSidebarToggle}>
                    <MenuIcon className="h-6 w-6" />
                </NavButton>

                <div className="border-b w-8 my-2 border-border"></div>

                <NavButton label={t('feature.dashboard')} onClick={() => dispatch({ type: 'SET_VIEW', payload: 'dashboard' })} isActive={state.view === 'dashboard'}>
                    <HomeIcon className="h-6 w-6" />
                </NavButton>
                <NavButton label={t('feature.listView')} onClick={() => dispatch({ type: 'SET_VIEW', payload: 'list' })} isActive={state.view === 'list'}>
                    <ListBulletIcon className="h-6 w-6" />
                </NavButton>
                <NavButton label={t('feature.boardView')} onClick={() => dispatch({ type: 'SET_VIEW', payload: 'board' })} isActive={state.view === 'board'}>
                    <ViewColumnsIcon className="h-6 w-6" />
                </NavButton>
                <NavButton label={t('feature.calendarView')} onClick={() => dispatch({ type: 'SET_VIEW', payload: 'calendar' })} isActive={state.view === 'calendar'}>
                    <CalendarDaysIcon className="h-6 w-6" />
                </NavButton>
                <NavButton label={t('feature.matrixView')} onClick={() => dispatch({ type: 'SET_VIEW', payload: 'matrix' })} isActive={state.view === 'matrix'}>
                    <GridIcon className="h-6 w-6" />
                </NavButton>
                 <NavButton label={t('feature.habitTracker')} onClick={() => dispatch({ type: 'SET_VIEW', payload: 'habit' })} isActive={state.view === 'habit'}>
                    <RepeatIcon className="h-6 w-6" />
                </NavButton>
                <NavButton label={t('feature.pomodoro')} onClick={() => dispatch({ type: 'SET_VIEW', payload: 'pomodoro' })} isActive={state.view === 'pomodoro'}>
                    <StopwatchIcon className="h-6 w-6" />
                </NavButton>
                <NavButton label={t('feature.countdown')} onClick={() => dispatch({ type: 'SET_VIEW', payload: 'countdown' })} isActive={state.view === 'countdown'}>
                    <HourglassIcon className="h-6 w-6" />
                </NavButton>

            </div>
            
            <div ref={dropdownRef} className="relative flex flex-col items-center">
                <div className="border-b w-8 my-2 border-border"></div>
                 <button onClick={() => setDropdownOpen(prev => !prev)} className="p-1 rounded-full focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 focus:ring-offset-background">
                    <Avatar user={user} className="w-10 h-10" />
                 </button>
                 {isDropdownOpen && <ProfileDropdown user={user} onClose={() => setDropdownOpen(false)} />}
            </div>
        </nav>
    );
};

export default FeatureBar;

================================================================================

--- FILE: components/layout/MainContent.tsx ---

import React, { useState, useMemo } from 'react';
import TaskList from '../task/TaskList';
import { useTaskManager } from '../../hooks/useTaskManager';
import { SPECIAL_LISTS_CONFIG, PlusIcon, UndoIcon, RedoIcon, TrashIcon, ArrowsUpDownIcon, ArrowUpIcon, ArrowDownIcon, SearchIcon, SparklesIcon } from '../../constants';
import { SortOrder } from '../../types';
import { useTranslation } from '../../hooks/useI18n';
import { useUser } from '../../hooks/useUser';
import Avatar from '../ui/Avatar';


interface MainContentProps {
    onSearchToggle: () => void;
    onBriefingToggle: () => void;
    onOpenTaskForm: () => void;
}

const MainContent: React.FC<MainContentProps> = ({ onSearchToggle, onBriefingToggle, onOpenTaskForm }) => {
    const { state, dispatch, canUndo, canRedo } = useTaskManager();
    const { allUsers } = useUser();
    const { t } = useTranslation();

    const activeList = useMemo(() => {
        if (state.activeListId in SPECIAL_LISTS_CONFIG || state.activeTag) {
            return null;
        }
        return state.lists.find(l => l.id === state.activeListId);
    }, [state.activeListId, state.lists, state.activeTag]);

    const listMembers = useMemo(() => {
        if (!activeList || !activeList.members) return [];
        return activeList.members.map(memberId => allUsers.find(u => u.id === memberId)).filter(Boolean);
    }, [activeList, allUsers]);

    const getActiveListName = () => {
        if (state.activeTag) {
            return `#${state.activeTag}`;
        }
        if (state.activeListId in SPECIAL_LISTS_CONFIG) {
            const configKey = state.activeListId as keyof typeof SPECIAL_LISTS_CONFIG;
            return t(SPECIAL_LISTS_CONFIG[configKey].name);
        }
        return activeList ? activeList.name : t('mainContent.tasksDefault');
    };

    const handleUndo = () => {
        if (canUndo) {
            dispatch({ type: 'UNDO' });
        }
    };

    const handleRedo = () => {
        if (canRedo) {
            dispatch({ type: 'REDO' });
        }
    };

    const handleClearHistory = () => {
        if (canUndo || canRedo) {
            dispatch({ type: 'CLEAR_HISTORY' });
        }
    };
    
    const handleSortToggle = () => {
        let nextSortOrder: SortOrder;
        if (state.sortOrder === 'default') {
            nextSortOrder = 'dueDateAsc';
        } else if (state.sortOrder === 'dueDateAsc') {
            nextSortOrder = 'dueDateDesc';
        } else {
            nextSortOrder = 'default';
        }
        dispatch({ type: 'SET_SORT_ORDER', payload: nextSortOrder });
    };

    const SortIcon = () => {
        if (state.sortOrder === 'dueDateAsc') return <ArrowUpIcon className="h-5 w-5 text-muted-foreground" />;
        if (state.sortOrder === 'dueDateDesc') return <ArrowDownIcon className="h-5 w-5 text-muted-foreground" />;
        return <ArrowsUpDownIcon className="h-5 w-5 text-muted-foreground" />;
    };

    return (
        <main className="flex-1 flex flex-col">
            <header className="flex-shrink-0 grid grid-cols-2 md:grid-cols-3 items-center p-4 md:p-6 border-b border-border gap-4">
                <div className="flex items-center gap-4">
                    <h1 className="text-xl md:text-2xl font-bold truncate">{getActiveListName()}</h1>
                    {listMembers.length > 0 && (
                        <div className="flex items-center -space-x-2">
                            {listMembers.slice(0, 3).map(member => (
                                member && <Avatar key={member.id} user={member} className="w-7 h-7 border-2 border-background" />
                            ))}
                            {listMembers.length > 3 && (
                                <div className="w-7 h-7 rounded-full bg-secondary flex items-center justify-center text-xs font-semibold border-2 border-background">
                                    +{listMembers.length - 3}
                                </div>
                            )}
                        </div>
                    )}
                </div>

                <div className="flex items-center justify-center md:col-start-2">
                     <button
                        onClick={onBriefingToggle}
                        className="flex items-center gap-2 px-3 py-2 bg-secondary rounded-md cursor-pointer hover:bg-muted"
                        role="button"
                        tabIndex={0}
                        aria-label="Get AI Daily Briefing"
                    >
                        <SparklesIcon className="h-5 w-5 text-primary" />
                        <span className="text-sm text-muted-foreground hidden sm:inline">{t('mainContent.dailyBriefing')}</span>
                    </button>
                </div>

                <div className="flex items-center gap-2 justify-end col-start-2 md:col-start-3">
                    <button
                        onClick={onSearchToggle}
                        className="p-2 rounded-md hover:bg-secondary"
                        aria-label={t('mainContent.searchTasks')}
                    >
                         <SearchIcon className="h-5 w-5 text-muted-foreground" />
                    </button>
                    <button
                        onClick={handleSortToggle}
                        className="p-2 rounded-md hover:bg-secondary"
                        aria-label={t('mainContent.sortTasks')}
                    >
                        <SortIcon />
                    </button>
                    <div className="hidden md:flex items-center gap-2">
                        <button 
                            onClick={handleUndo} 
                            disabled={!canUndo} 
                            className="p-2 rounded-md hover:bg-secondary disabled:opacity-50 disabled:cursor-not-allowed transition-opacity"
                            aria-label={t('mainContent.undo')}
                        >
                            <UndoIcon className="h-5 w-5 text-muted-foreground" />
                        </button>
                        <button 
                            onClick={handleRedo} 
                            disabled={!canRedo} 
                            className="p-2 rounded-md hover:bg-secondary disabled:opacity-50 disabled:cursor-not-allowed transition-opacity"
                            aria-label={t('mainContent.redo')}
                        >
                            <RedoIcon className="h-5 w-5 text-muted-foreground" />
                        </button>
                        <button
                            onClick={handleClearHistory}
                            disabled={!canUndo && !canRedo}
                            className="p-2 rounded-md hover:bg-secondary disabled:opacity-50 disabled:cursor-not-allowed transition-opacity"
                            aria-label={t('mainContent.clearHistory')}
                        >
                            <TrashIcon className="h-5 w-5 text-muted-foreground" />
                        </button>
                    </div>
                </div>
            </header>
            <div className="flex-1 overflow-y-auto p-4 md:p-6 pb-20 md:pb-6">
                <TaskList onAddTask={onOpenTaskForm} />
            </div>

            <button
                onClick={() => onOpenTaskForm()}
                className="absolute bottom-20 md:bottom-8 right-4 md:right-8 bg-primary text-primary-foreground rounded-full p-4 shadow-lg hover:bg-primary/90 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 transition-transform hover:scale-105"
                aria-label={t('taskList.addTask')}
            >
                <PlusIcon className="h-6 w-6" />
            </button>
        </main>
    );
};

export default MainContent;

================================================================================

--- FILE: components/layout/Sidebar.tsx ---


import React, { useState, useMemo, useRef, useEffect } from 'react';
import { useTaskManager } from '../../hooks/useTaskManager';
import { ListBulletIcon, PlusIcon, ChatBubbleLeftRightIcon, TagIcon, TrashIcon, ArrowDownIcon, UserPlusIcon } from '../../constants';
import { SPECIAL_LISTS_CONFIG, TAG_COLORS } from '../../constants';
import { useTranslation } from '../../hooks/useI18n';
import { useConfirmation } from '../../hooks/useConfirmation';
import { useToast } from '../../hooks/useToast';
import { useGemini } from '../../hooks/useGemini';
import { useUser } from '../../hooks/useUser';
import Avatar from '../ui/Avatar';
import ProfileDropdown from '../auth/ProfileDropdown';


interface SidebarProps {
    isOpen: boolean;
    onClose: () => void;
    onChatbotToggle: () => void;
    onShareList: (listId: string) => void;
}

const Sidebar: React.FC<SidebarProps> = ({ isOpen, onClose, onChatbotToggle, onShareList }) => {
    const { state, dispatch } = useTaskManager();
    const { t } = useTranslation();
    const { isAvailable: isGeminiAvailable } = useGemini();
    const { user } = useUser();
    const [newList, setNewList] = useState('');
    const [newTag, setNewTag] = useState('');
    const [isListsExpanded, setIsListsExpanded] = useState(true);
    const [isTagsExpanded, setIsTagsExpanded] = useState(true);
    const [isProfileDropdownOpen, setProfileDropdownOpen] = useState(false);
    const profileDropdownRef = useRef<HTMLDivElement>(null);
    const addToast = useToast();
    const { confirm } = useConfirmation();

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (profileDropdownRef.current && !profileDropdownRef.current.contains(event.target as Node)) {
                setProfileDropdownOpen(false);
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => {
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, []);

    const handleAddList = (e: React.FormEvent) => {
        e.preventDefault();
        if (newList.trim()) {
            dispatch({ type: 'ADD_LIST', payload: { name: newList.trim() } });
            setNewList('');
        }
    };

    const handleAddTag = (e: React.FormEvent) => {
        e.preventDefault();
        if (newTag.trim()) {
            dispatch({ type: 'ADD_TAG', payload: { name: newTag.trim() } });
            setNewTag('');
        }
    };

    const handleDeleteList = async (listId: string, listName: string) => {
        const isConfirmed = await confirm({
            title: t('sidebar.deleteList.confirm.title', { listName }),
            message: t('sidebar.deleteList.confirm.message'),
            confirmText: t('sidebar.deleteList.confirm.button'),
        });

        if (isConfirmed) {
            dispatch({ type: 'DELETE_LIST', payload: listId });
            addToast(t('sidebar.deleteList.success', { listName }), 'success');
        }
    }
    
    const handleDeleteTag = async (tagName: string) => {
        const isConfirmed = await confirm({
            title: t('sidebar.deleteTag.confirm.title', { tagName }),
            message: t('sidebar.deleteTag.confirm.message'),
            confirmText: t('sidebar.deleteTag.confirm.button'),
        });

        if (isConfirmed) {
            dispatch({ type: 'DELETE_TAG', payload: tagName });
            addToast(t('sidebar.deleteTag.success', { tagName }), 'success');
        }
    }

    const allTags = useMemo(() => {
        return [...state.tags].sort();
    }, [state.tags]);

    const getTagColor = (tag: string) => {
        let hash = 0;
        for (let i = 0; i < tag.length; i++) {
            hash = tag.charCodeAt(i) + ((hash << 5) - hash);
        }
        const index = Math.abs(hash % TAG_COLORS.length);
        return TAG_COLORS[index];
    };

    const NavItem: React.FC<{
        children: React.ReactNode;
        isActive: boolean;
        onClick: () => void;
    }> = ({ children, isActive, onClick }) => (
        <button
            onClick={() => {
                onClick();
                if (window.innerWidth < 768) { // md breakpoint
                    onClose();
                }
            }}
            className={`w-full flex items-center justify-between text-sm px-3 py-2 rounded-md transition-colors group ${
                isActive ? 'bg-primary/10 text-primary font-semibold' : 'hover:bg-muted/50'
            }`}
        >
            {children}
        </button>
    );

    return (
        <>
            {/* Overlay for mobile */}
            <div 
                className={`fixed inset-0 bg-black/50 z-20 md:hidden transition-opacity ${isOpen ? 'opacity-100' : 'opacity-0 pointer-events-none'}`}
                onClick={onClose}
            ></div>
            <aside className={`
                fixed md:relative inset-y-0 left-0 bg-card flex flex-col shrink-0 z-30 
                w-64 transition-transform md:transition-all duration-300 ease-in-out overflow-hidden border-border
                ${isOpen 
                    ? 'p-4 border-r translate-x-0 md:w-64'
                    : 'p-4 -translate-x-full md:w-0 md:p-0 md:border-r-0 md:translate-x-0'
                }
            `}>
                <div className="flex items-center gap-2 mb-6 px-2">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256" className="h-8 w-8 text-primary">
                        <rect width="256" height="256" fill="none"></rect>
                        <path d="M128,24a104,104,0,1,0,104,104A104.11,104.11,0,0,0,128,24Zm45.15,122.34-8.6-14.9a4,4,0,0,0-6.92,0l-22.1,38.28a4,4,0,0,1-3.46,2H92a4,4,0,0,1-3.46-6l25.56-44.28a4,4,0,0,0-3.46-6H65.75a4,4,0,0,1,0-8h42.39a4,4,0,0,1,3.46,6l-25.56,44.28a4,4,0,0,0,3.46,6h22.54a4,4,0,0,1,3.46-2l22.1-38.28a4,4,0,0,0-3.46-6H134.25a4,4,0,0,1,0-8h42.39a4,4,0,0,1,3.46,2l8.6,14.9a4,4,0,0,1-3.46,6H173.15a4,4,0,0,1,0,8h-3.46a4,4,0,0,1-3.46-2Z"></path>
                    </svg>
                    <h1 className="text-xl font-bold whitespace-nowrap">TaskFlow</h1>
                </div>

                <div className="flex-grow overflow-y-auto pr-1 min-w-[15rem]">
                    <nav className="space-y-1">
                        {Object.values(SPECIAL_LISTS_CONFIG).map(({ id, name, icon }) => (
                            <NavItem
                                key={id}
                                isActive={state.activeListId === id && !state.activeTag}
                                onClick={() => dispatch({ type: 'SET_ACTIVE_LIST', payload: id as any })}
                            >
                                <div className="flex items-center gap-3">
                                    {icon}
                                    <span>{t(name)}</span>
                                </div>
                            </NavItem>
                        ))}
                    </nav>

                    <div className="pt-4">
                        <div className="flex items-center justify-between px-3 mb-2">
                            <h2 className="text-xs font-semibold text-muted-foreground">{t('sidebar.myLists')}</h2>
                            <button onClick={() => setIsListsExpanded(!isListsExpanded)} className="p-1 rounded-md hover:bg-muted/50">
                                <ArrowDownIcon className={`h-4 w-4 text-muted-foreground transition-transform ${!isListsExpanded && '-rotate-90'}`} />
                            </button>
                        </div>
                        {isListsExpanded && (
                            <div className="animate-accordion-down overflow-hidden">
                                <div className="space-y-1">
                                    {state.lists.map(list => {
                                        const taskCount = state.tasks.filter(t => t.listId === list.id && !t.completed).length;
                                        return (
                                            <NavItem
                                                key={list.id}
                                                isActive={state.activeListId === list.id && !state.activeTag}
                                                onClick={() => dispatch({ type: 'SET_ACTIVE_LIST', payload: list.id })}
                                            >
                                                <div className="flex items-center gap-3">
                                                    <ListBulletIcon className="h-5 w-5" />
                                                    <span className="truncate flex-1 text-left">{list.name}</span>
                                                </div>
                                                <div className="flex items-center gap-2">
                                                    <span className="text-xs font-medium text-muted-foreground">{taskCount}</span>
                                                     <button 
                                                        onClick={(e) => { e.stopPropagation(); onShareList(list.id); }} 
                                                        className="opacity-0 group-hover:opacity-100 text-muted-foreground hover:text-primary p-0.5 rounded"
                                                        aria-label={t('sidebar.aria.shareList', { listName: list.name })}
                                                    >
                                                        <UserPlusIcon className="h-4 w-4" />
                                                    </button>
                                                    <button 
                                                        onClick={(e) => { e.stopPropagation(); handleDeleteList(list.id, list.name); }} 
                                                        className="opacity-0 group-hover:opacity-100 text-muted-foreground hover:text-destructive p-0.5 rounded"
                                                        aria-label={t('sidebar.aria.deleteList', { listName: list.name })}
                                                    >
                                                        <TrashIcon className="h-4 w-4" />
                                                    </button>
                                                </div>
                                            </NavItem>
                                        )
                                    })}
                                </div>
                                <form onSubmit={handleAddList} className="flex items-center gap-2 mt-2 px-3">
                                    <PlusIcon className="h-4 w-4 text-muted-foreground" />
                                    <input
                                        type="text"
                                        value={newList}
                                        onChange={e => setNewList(e.target.value)}
                                        placeholder={t('sidebar.addNewList')}
                                        className="w-full bg-transparent text-sm placeholder-muted-foreground focus:outline-none"
                                    />
                                </form>
                            </div>
                        )}
                    </div>

                    <div className="pt-4">
                        <div className="flex items-center justify-between px-3 mb-2">
                            <h2 className="text-xs font-semibold text-muted-foreground">{t('sidebar.tags')}</h2>
                            <button onClick={() => setIsTagsExpanded(!isTagsExpanded)} className="p-1 rounded-md hover:bg-muted/50">
                                <ArrowDownIcon className={`h-4 w-4 text-muted-foreground transition-transform ${!isTagsExpanded && '-rotate-90'}`} />
                            </button>
                        </div>
                        {isTagsExpanded && (
                            <div className="animate-accordion-down overflow-hidden">
                                <div className="space-y-1">
                                    {allTags.map(tag => {
                                        const taskCount = state.tasks.filter(t => t.tags.includes(tag) && !t.completed).length;
                                        return (
                                            <div
                                                key={tag}
                                                className={`group w-full flex items-center justify-between text-sm px-3 py-2 rounded-md transition-colors ${
                                                    state.activeTag === tag ? 'bg-primary/10' : 'hover:bg-muted/50'
                                                }`}
                                            >
                                                <button
                                                    onClick={() => {
                                                        dispatch({ type: 'SET_ACTIVE_TAG', payload: tag });
                                                        if (window.innerWidth < 768) {
                                                            onClose();
                                                        }
                                                    }}
                                                    className={`flex-grow flex items-center gap-3 text-left ${state.activeTag === tag ? 'text-primary font-semibold' : ''}`}
                                                >
                                                    <TagIcon className="h-5 w-5" />
                                                    <span className="truncate flex-1">{tag}</span>
                                                </button>
                                                <div className="flex items-center gap-2 pl-2">
                                                    <span className="text-xs font-medium text-muted-foreground">{taskCount}</span>
                                                    <span className={`w-2 h-2 rounded-full ${getTagColor(tag)}`}></span>
                                                    <button 
                                                        onClick={() => handleDeleteTag(tag)} 
                                                        className="opacity-0 group-hover:opacity-100 text-muted-foreground hover:text-destructive p-0.5 rounded"
                                                        aria-label={t('sidebar.aria.deleteTag', { tagName: tag })}
                                                    >
                                                        <TrashIcon className="h-4 w-4" />
                                                    </button>
                                                </div>
                                            </div>
                                        )
                                    })}
                                </div>
                                <form onSubmit={handleAddTag} className="flex items-center gap-2 mt-2 px-3">
                                    <PlusIcon className="h-4 w-4 text-muted-foreground" />
                                    <input
                                        type="text"
                                        value={newTag}
                                        onChange={e => setNewTag(e.target.value)}
                                        placeholder={t('sidebar.addNewTag')}
                                        className="w-full bg-transparent text-sm placeholder-muted-foreground focus:outline-none"
                                    />
                                </form>
                            </div>
                        )}
                    </div>
                </div>

                {isGeminiAvailable && (
                    <div className="pt-4">
                        <button
                            onClick={onChatbotToggle}
                            className="w-full flex items-center justify-center gap-2 text-sm px-3 py-2 rounded-md bg-secondary hover:bg-muted transition-colors"
                        >
                            <ChatBubbleLeftRightIcon className="h-5 w-5" />
                            {t('sidebar.chatWithGemini')}
                        </button>
                    </div>
                )}
                 <div ref={profileDropdownRef} className="relative mt-auto pt-4 md:hidden">
                    <div className="border-t border-border mb-4 -mx-4"></div>
                    <button onClick={() => setProfileDropdownOpen(prev => !prev)} className="w-full flex items-center gap-3 p-2 rounded-md hover:bg-secondary">
                        <Avatar user={user} className="w-8 h-8" />
                        <span className="font-semibold text-sm truncate">{user?.name}</span>
                    </button>
                    {isProfileDropdownOpen && <ProfileDropdown user={user} onClose={() => setProfileDropdownOpen(false)} />}
                </div>
            </aside>
        </>
    );
};

export default Sidebar;


================================================================================

--- FILE: components/matrix/MatrixView.tsx ---

import React, { useMemo } from 'react';
import { useTaskManager } from '../../hooks/useTaskManager';
import { Task, Priority } from '../../types';
import TaskItem from '../task/TaskItem';
import { useTranslation } from '../../hooks/useI18n';

const Quadrant: React.FC<{ title: string; subtitle: string; tasks: Task[]; className?: string }> = ({ title, subtitle, tasks, className }) => {
    const { t } = useTranslation();
    
    return (
        <div className={`p-4 rounded-lg flex flex-col bg-card border border-border ${className}`}>
            <div className="mb-4">
                <h3 className="font-bold">{title}</h3>
                <p className="text-xs text-muted-foreground">{subtitle}</p>
            </div>
            <div className="flex-1 overflow-y-auto pr-2 space-y-2">
                {tasks.length > 0 ? (
                    tasks.map(task => <TaskItem key={task.id} task={task} isDraggable={false} />)
                ) : (
                    <div className="text-center text-sm text-muted-foreground pt-8">{t('matrix.empty')}</div>
                )}
            </div>
        </div>
    );
};

const MatrixView: React.FC = () => {
    const { state } = useTaskManager();
    const { t } = useTranslation();
    const tasks = state.tasks.filter(t => !t.completed);

    const categorizedTasks = useMemo(() => {
        const urgentImportant = tasks.filter(t => t.priority === Priority.High);
        const notUrgentImportant = tasks.filter(t => t.priority === Priority.Low);
        const urgentNotImportant = tasks.filter(t => t.priority === Priority.Medium);
        const notUrgentNotImportant = tasks.filter(t => t.priority === Priority.None);
        return { urgentImportant, notUrgentImportant, urgentNotImportant, notUrgentNotImportant };
    }, [tasks]);

    return (
        <div className="flex-1 flex flex-col">
            <header className="flex-shrink-0 p-6 border-b border-border">
                <h1 className="text-2xl font-bold">{t('matrix.title')}</h1>
                <p className="text-muted-foreground">{t('matrix.subtitle')}</p>
            </header>
            <main className="flex-1 grid grid-cols-1 md:grid-cols-2 md:grid-rows-2 gap-4 p-4 md:p-6 overflow-y-auto pb-20 md:pb-6">
                <Quadrant 
                    title={t('matrix.q1.title')}
                    subtitle={t('matrix.q1.subtitle')}
                    tasks={categorizedTasks.urgentImportant} 
                    className="border-red-500/50"
                />
                <Quadrant 
                    title={t('matrix.q2.title')}
                    subtitle={t('matrix.q2.subtitle')} 
                    tasks={categorizedTasks.notUrgentImportant} 
                    className="border-blue-500/50"
                />
                <Quadrant 
                    title={t('matrix.q3.title')}
                    subtitle={t('matrix.q3.subtitle')}
                    tasks={categorizedTasks.urgentNotImportant} 
                    className="border-yellow-500/50"
                />
                <Quadrant 
                    title={t('matrix.q4.title')} 
                    subtitle={t('matrix.q4.subtitle')}
                    tasks={categorizedTasks.notUrgentNotImportant} 
                    className="border-gray-500/50"
                />
            </main>
        </div>
    );
};

export default MatrixView;

================================================================================

--- FILE: components/pomodoro/FocusTaskPicker.tsx ---

import React, { useMemo } from 'react';
import { useTaskManager } from '../../hooks/useTaskManager';
import { CloseIcon, CheckCircleIcon } from '../../constants';
import { Task } from '../../types';
import { useTranslation } from '../../hooks/useI18n';

interface FocusTaskPickerProps {
    onClose: () => void;
}

const FocusTaskPicker: React.FC<FocusTaskPickerProps> = ({ onClose }) => {
    const { state, dispatch } = useTaskManager();
    const { t } = useTranslation();

    const uncompletedTasks = useMemo(() => {
        return state.tasks.filter(task => !task.completed);
    }, [state.tasks]);
    
    const handleSelectTask = (taskId: string | null) => {
        dispatch({ type: 'SET_FOCUSED_TASK', payload: taskId });
        onClose();
    };

    return (
         <div className="fixed inset-0 bg-black/50 z-30 flex items-center justify-center p-4">
            <div className="bg-card rounded-lg shadow-xl w-full max-w-lg flex flex-col max-h-[70vh]">
                <header className="p-4 border-b border-border flex items-center justify-between">
                    <h2 className="text-lg font-semibold">{t('focusPicker.title')}</h2>
                    <button onClick={onClose} className="p-1 rounded-full hover:bg-secondary">
                        <CloseIcon className="h-5 w-5 text-muted-foreground" />
                    </button>
                </header>
                <div className="flex-grow p-4 overflow-y-auto">
                    <ul className="space-y-2">
                        <li 
                            onClick={() => handleSelectTask(null)}
                            className="p-3 flex items-center justify-between rounded-md cursor-pointer hover:bg-secondary"
                        >
                            <span>{t('focusPicker.general')}</span>
                             {!state.pomodoro.focusedTaskId && <CheckCircleIcon className="h-5 w-5 text-primary" />}
                        </li>
                        {uncompletedTasks.map(task => (
                            <li 
                                key={task.id}
                                onClick={() => handleSelectTask(task.id)}
                                className="p-3 flex items-center justify-between rounded-md cursor-pointer hover:bg-secondary"
                            >
                                <span>{task.title}</span>
                                {state.pomodoro.focusedTaskId === task.id && <CheckCircleIcon className="h-5 w-5 text-primary" />}
                            </li>
                        ))}
                    </ul>
                </div>
            </div>
        </div>
    );
};

export default FocusTaskPicker;

================================================================================

--- FILE: components/pomodoro/PomodoroTimer.tsx ---

import React from 'react';

const PomodoroTimer: React.FC = () => {
    // This component is not currently used, but is kept as a placeholder.
    return null;
};

export default PomodoroTimer;


================================================================================

--- FILE: components/pomodoro/PomodoroView.tsx ---

import React, { useState, useMemo } from 'react';
import { useTaskManager } from '../../hooks/useTaskManager';
import { Task } from '../../types';
import { PlusIcon } from '../../constants';
import FocusTaskPicker from './FocusTaskPicker';
import { useTranslation } from '../../hooks/useI18n';


const PomodoroView: React.FC = () => {
    const { state, dispatch } = useTaskManager();
    const { t } = useTranslation();
    const { pomodoro } = state;
    const [isTaskPickerOpen, setTaskPickerOpen] = useState(false);
    
    const focusedTask = useMemo(() => 
        state.tasks.find(t => t.id === pomodoro.focusedTaskId),
        [state.tasks, pomodoro.focusedTaskId]
    );
    
    const today = new Date().toISOString().split('T')[0];
    const todaysFocusRecords = pomodoro.focusHistory.filter(r => r.startTime.startsWith(today));
    const totalPomosToday = todaysFocusRecords.length;
    const totalFocusDurationToday = todaysFocusRecords.reduce((acc, curr) => acc + curr.duration, 0);


    const formatTime = (seconds: number) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    };
    
    const formatDuration = (seconds: number) => {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        if (hours > 0) return `${hours}h ${minutes}m`;
        return `${minutes}m`;
    };

    const handlePauseResume = () => {
        if (pomodoro.isPaused || !pomodoro.isActive) {
            dispatch({ type: 'START_TIMER' });
        } else {
            dispatch({ type: 'PAUSE_TIMER' });
        }
    };

    const handleStop = () => {
        dispatch({ type: 'STOP_TIMER' });
    };

    const getSessionName = () => {
        switch (pomodoro.currentSession) {
            case 'pomo': return t('pomodoro.focus');
            case 'shortBreak': return t('pomodoro.shortBreak');
            case 'longBreak': return t('pomodoro.longBreak');
        }
    };
    
    const totalDuration = pomodoro.settings[`${pomodoro.currentSession}Duration`];
    const progress = totalDuration > 0 ? (totalDuration - pomodoro.remainingTime) / totalDuration : 0;

    return (
        <>
            <div className="flex flex-col md:flex-row h-full w-full pb-16 md:pb-0">
                <div className="flex-1 flex flex-col items-center justify-center p-4 md:p-8">
                    <div className="text-center mb-6">
                        <p className="text-lg text-muted-foreground mb-2">
                            {getSessionName()} {pomodoro.currentSession === 'pomo' && `(#${pomodoro.currentCycle + 1})`}
                        </p>
                        <div 
                            className="text-xl md:text-2xl font-semibold min-h-[32px] cursor-pointer hover:bg-secondary p-2 rounded-md"
                            onClick={() => setTaskPickerOpen(true)}
                        >
                            {focusedTask ? t('pomodoro.focusingOn', { taskTitle: focusedTask.title }) : t('pomodoro.selectTask')}
                        </div>
                    </div>

                    <div className="relative w-60 h-60 md:w-72 md:h-72 flex items-center justify-center mb-8">
                        <svg className="absolute w-full h-full" viewBox="0 0 100 100">
                            <circle className="text-secondary" strokeWidth="5" stroke="currentColor" fill="transparent" r="45" cx="50" cy="50" />
                            <circle
                                className="text-primary transition-all duration-1000 ease-linear"
                                strokeWidth="5"
                                strokeDasharray={2 * Math.PI * 45}
                                strokeDashoffset={2 * Math.PI * 45 * (1 - progress)}
                                strokeLinecap="round"
                                stroke="currentColor"
                                fill="transparent"
                                r="45"
                                cx="50"
                                cy="50"
                                style={{ transform: 'rotate(-90deg)', transformOrigin: 'center' }}
                            />
                        </svg>
                        <span className="text-5xl md:text-6xl font-bold font-mono tracking-tighter">
                            {formatTime(pomodoro.remainingTime)}
                        </span>
                    </div>
                    <div className="flex items-center gap-6">
                        <button 
                            onClick={handleStop}
                            className="px-6 py-3 bg-secondary text-secondary-foreground rounded-full text-md md:text-lg font-semibold hover:bg-muted"
                        >
                            {t('pomodoro.stop')}
                        </button>
                        <button 
                            onClick={handlePauseResume}
                            className="px-6 py-3 bg-primary text-primary-foreground rounded-full text-md md:text-lg font-semibold hover:bg-primary/90 w-32"
                        >
                            {pomodoro.isPaused || !pomodoro.isActive ? t('pomodoro.start') : t('pomodoro.pause')}
                        </button>
                    </div>
                </div>
                <aside className="w-full md:w-80 bg-card border-t md:border-l md:border-t-0 border-border p-6 flex-shrink-0 flex flex-col h-1/3 md:h-full">
                    <h2 className="text-xl font-bold mb-4">{t('pomodoro.overview')}</h2>
                    <div className="grid grid-cols-2 gap-4 mb-8">
                        <div className="bg-secondary p-4 rounded-lg">
                            <p className="text-sm text-muted-foreground">{t('pomodoro.todayPomos')}</p>
                            <p className="text-2xl font-bold">{totalPomosToday}</p>
                        </div>
                        <div className="bg-secondary p-4 rounded-lg">
                            <p className="text-sm text-muted-foreground">{t('pomodoro.totalFocus')}</p>
                            <p className="text-2xl font-bold">{formatDuration(totalFocusDurationToday)}</p>
                        </div>
                    </div>

                    <h2 className="text-xl font-bold mb-4">{t('pomodoro.focusRecord')}</h2>
                    <div className="flex-1 overflow-y-auto pr-2">
                        {todaysFocusRecords.length > 0 ? (
                            <ul className="space-y-3">
                                {todaysFocusRecords.slice().reverse().map((record) => {
                                    const task = state.tasks.find(t => t.id === record.taskId);
                                    return (
                                    <li key={record.startTime} className="flex items-center justify-between text-sm">
                                        <div>
                                            <p className="font-semibold truncate max-w-[150px]">{task ? task.title : t('pomodoro.generalFocus')}</p>
                                            <p className="text-xs text-muted-foreground">
                                                {new Date(record.startTime).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })} - {new Date(record.endTime).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                                            </p>
                                        </div>
                                        <span className="font-mono text-muted-foreground">{formatDuration(record.duration)}</span>
                                    </li>
                                )})}
                            </ul>
                        ) : (
                            <p className="text-sm text-muted-foreground text-center mt-8">{t('pomodoro.noRecords')}</p>
                        )}
                    </div>
                </aside>
            </div>
            {isTaskPickerOpen && <FocusTaskPicker onClose={() => setTaskPickerOpen(false)} />}
        </>
    );
};

export default PomodoroView;

================================================================================

--- FILE: components/profile/EditProfileModal.tsx ---

import React, { useState } from 'react';
import { User } from '../../types';
import { useTranslation } from '../../hooks/useI18n';
import { CloseIcon } from '../../constants';

interface EditProfileModalProps {
    user: User;
    onClose: () => void;
    onSave: (updatedData: Partial<User>) => void;
}

const EditProfileModal: React.FC<EditProfileModalProps> = ({ user, onClose, onSave }) => {
    const { t } = useTranslation();
    const [name, setName] = useState(user.name);
    const [email, setEmail] = useState(user.email);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        onSave({ name, email });
    };

    return (
        <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4">
            <div className="bg-card rounded-lg shadow-xl w-full max-w-md">
                <header className="p-4 border-b border-border flex items-center justify-between">
                    <h2 className="text-lg font-semibold">{t('profile.editModal.title')}</h2>
                    <button onClick={onClose} className="p-1 rounded-full hover:bg-secondary">
                        <CloseIcon className="h-5 w-5 text-muted-foreground" />
                    </button>
                </header>
                <form onSubmit={handleSubmit}>
                    <div className="p-6 space-y-4">
                        <div>
                            <label htmlFor="name" className="text-sm font-medium text-muted-foreground">
                                {t('profile.editModal.nameLabel')}
                            </label>
                            <input
                                id="name"
                                type="text"
                                value={name}
                                onChange={(e) => setName(e.target.value)}
                                className="mt-1 w-full p-2 bg-secondary/80 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50"
                                required
                            />
                        </div>
                        <div>
                            <label htmlFor="email" className="text-sm font-medium text-muted-foreground">
                                {t('profile.editModal.emailLabel')}
                            </label>
                            <input
                                id="email"
                                type="email"
                                value={email}
                                onChange={(e) => setEmail(e.target.value)}
                                className="mt-1 w-full p-2 bg-secondary/80 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50"
                                required
                            />
                        </div>
                    </div>
                    <footer className="p-4 bg-secondary/50 rounded-b-lg flex justify-end gap-4">
                        <button
                            type="button"
                            onClick={onClose}
                            className="px-4 py-2 bg-background border border-border rounded-md text-sm font-semibold hover:bg-muted"
                        >
                            {t('board.column.cancel')}
                        </button>
                        <button
                            type="submit"
                            className="px-4 py-2 bg-primary text-primary-foreground rounded-md text-sm font-semibold hover:bg-primary/90"
                        >
                            {t('profile.editModal.saveButton')}
                        </button>
                    </footer>
                </form>
            </div>
        </div>
    );
};

export default EditProfileModal;

================================================================================

--- FILE: components/profile/ProfileView.tsx ---

import React, { useMemo, useState } from 'react';
import { useUser } from '../../hooks/useUser';
import { useTaskManager } from '../../hooks/useTaskManager';
import { useTranslation } from '../../hooks/useI18n';
import Avatar from '../ui/Avatar';
import { CheckCircleIcon, StopwatchIcon, TrophyIcon } from '../../constants';
import { ALL_ACHIEVEMENTS } from '../../constants';
import AchievementBadge from '../achievements/AchievementBadge';
import EditProfileModal from './EditProfileModal';
import { useToast } from '../../hooks/useToast';
import { User } from '../../types';

const toYYYYMMDD = (date: Date) => date.toISOString().split('T')[0];

const StatCard: React.FC<{ icon: React.ReactNode; label: string; value: string | number }> = ({ icon, label, value }) => (
    <div className="bg-card border border-border rounded-lg p-6 flex items-start gap-4">
        <div className="bg-primary/10 text-primary p-3 rounded-lg">
            {icon}
        </div>
        <div>
            <p className="text-sm text-muted-foreground">{label}</p>
            <p className="text-3xl font-bold">{value}</p>
        </div>
    </div>
);

const WeeklyActivityChart: React.FC = () => {
    const { state } = useTaskManager();
    const { t } = useTranslation();

    const weeklyData = useMemo(() => {
        const today = new Date();
        const days = Array.from({ length: 7 }).map((_, i) => {
            const d = new Date();
            d.setDate(today.getDate() - i);
            return d;
        }).reverse();

        const taskCounts = days.map(day => {
            const dayStr = toYYYYMMDD(day);
            const count = state.tasks.filter(t => t.completed && t.completedAt?.startsWith(dayStr)).length;
            return {
                day: day.toLocaleDateString(undefined, { weekday: 'short' }),
                count,
            };
        });
        
        const maxCount = Math.max(1, ...taskCounts.map(d => d.count));

        return taskCounts.map(d => ({ ...d, height: (d.count / maxCount) * 100 }));
    }, [state.tasks]);

    return (
        <div className="bg-card border border-border rounded-lg p-6">
            <h3 className="font-bold mb-4">{t('profile.weeklyActivity')}</h3>
            <div className="flex justify-between items-end h-32 gap-2">
                {weeklyData.map(({ day, height, count }) => (
                    <div key={day} className="flex-1 flex flex-col items-center gap-2 group">
                        <div className="relative w-full h-full flex items-end">
                            <div
                                className="w-full bg-primary/20 rounded-t-md group-hover:bg-primary/40 transition-all"
                                style={{ height: `${height}%` }}
                                title={`${count} ${t('profile.tasksCompleted')}`}
                            ></div>
                        </div>
                        <span className="text-xs text-muted-foreground">{day}</span>
                    </div>
                ))}
            </div>
        </div>
    );
};


const ProfileView: React.FC = () => {
    const { user, updateUser } = useUser();
    const { state, dispatch } = useTaskManager();
    const { t } = useTranslation();
    const addToast = useToast();
    const [isEditModalOpen, setIsEditModalOpen] = useState(false);

    if (!user) return null;

    const handleSaveProfile = (updatedData: Partial<User>) => {
        updateUser(updatedData);
        addToast(t('profile.updateSuccess'), 'success');
        setIsEditModalOpen(false);
    };

    const tasksCompleted = state.tasks.filter(t => t.completed).length;
    const totalFocusSeconds = state.pomodoro.focusHistory.reduce((acc, session) => acc + session.duration, 0);
    const totalFocusHours = (totalFocusSeconds / 3600).toFixed(1);
    const achievementsUnlocked = state.unlockedAchievements.length;
    
    const recentActivities = useMemo(() => {
        return state.tasks
            .filter(t => t.completed && t.completedAt)
            .sort((a, b) => new Date(b.completedAt!).getTime() - new Date(a.completedAt!).getTime())
            .slice(0, 5);
    }, [state.tasks]);
    
    const recentAchievements = useMemo(() => {
        return state.unlockedAchievements
            .slice(-3)
            .reverse()
            .map(id => ALL_ACHIEVEMENTS.find(ach => ach.id === id))
            .filter((a): a is NonNullable<typeof a> => a !== undefined);
    }, [state.unlockedAchievements]);


    return (
        <>
            <div className="flex-1 flex flex-col overflow-y-auto pb-16 md:pb-0">
                <header className="p-6 border-b border-border bg-card">
                    <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
                        <div className="flex items-center gap-6">
                            <Avatar user={user} className="w-24 h-24 text-4xl" />
                            <div>
                                <h1 className="text-3xl font-bold">{user.name}</h1>
                                <p className="text-muted-foreground">{user.email}</p>
                            </div>
                        </div>
                        <button 
                            onClick={() => setIsEditModalOpen(true)}
                            className="px-4 py-2 bg-secondary text-secondary-foreground rounded-md text-sm font-semibold hover:bg-muted"
                        >
                            {t('profile.editProfile')}
                        </button>
                    </div>
                </header>
                <main className="flex-1 p-4 md:p-6 grid grid-cols-1 lg:grid-cols-3 gap-6">
                    <div className="lg:col-span-2 space-y-6">
                        <section>
                            <h2 className="text-xl font-bold mb-4">{t('profile.stats.title')}</h2>
                            <div className="grid grid-cols-1 sm:grid-cols-3 gap-6">
                                <StatCard 
                                    icon={<CheckCircleIcon className="h-6 w-6" />}
                                    label={t('profile.stats.tasksCompleted')}
                                    value={tasksCompleted}
                                />
                                <StatCard 
                                    icon={<StopwatchIcon className="h-6 w-6" />}
                                    label={t('profile.stats.focusTime')}
                                    value={`${totalFocusHours}h`}
                                />
                                <StatCard 
                                    icon={<TrophyIcon className="h-6 w-6" />}
                                    label={t('profile.stats.achievementsUnlocked')}
                                    value={achievementsUnlocked}
                                />
                            </div>
                        </section>
                        <section>
                            <WeeklyActivityChart />
                        </section>
                    </div>

                    <div className="space-y-6">
                        <section className="bg-card border border-border rounded-lg p-6">
                            <h3 className="font-bold mb-4">{t('profile.recentActivity')}</h3>
                            <div className="space-y-4">
                                {recentActivities.length > 0 ? (
                                    recentActivities.map(task => (
                                        <div key={task.id} className="flex items-center gap-3">
                                            <div className="p-2 bg-green-500/10 rounded-full">
                                                <CheckCircleIcon className="h-4 w-4 text-green-500"/>
                                            </div>
                                            <div>
                                                <p className="text-sm font-medium line-through text-muted-foreground truncate">{task.title}</p>
                                                <p className="text-xs text-muted-foreground">{new Date(task.completedAt!).toLocaleDateString(undefined, {month: 'short', day: 'numeric'})}</p>
                                            </div>
                                        </div>
                                    ))
                                ) : (
                                    <p className="text-sm text-muted-foreground text-center py-4">{t('profile.noRecentActivity')}</p>
                                )}
                            </div>
                        </section>
                        <section className="bg-card border border-border rounded-lg p-6">
                            <h3 className="font-bold mb-4">{t('profile.recentAchievements')}</h3>
                            <div>
                                {recentAchievements.length > 0 ? (
                                    <div className="grid grid-cols-3 gap-4">
                                    {recentAchievements.map(ach => (
                                        <div key={ach.id} className="flex flex-col items-center text-center">
                                            <div className="p-2 rounded-full bg-primary/10 text-primary">
                                                <ach.icon className="h-6 w-6" />
                                            </div>
                                            <p className="text-xs mt-1 font-medium">{t(ach.title)}</p>
                                        </div>
                                    ))}
                                    </div>
                                ) : (
                                    <p className="text-sm text-muted-foreground text-center py-4">{t('profile.noAchievements')}</p>
                                )}
                                <button onClick={() => dispatch({type: 'SET_VIEW', payload: 'achievements'})} className="mt-4 w-full text-center text-sm font-semibold text-primary hover:underline">
                                    View all
                                </button>
                            </div>
                        </section>
                    </div>
                </main>
            </div>
            {isEditModalOpen && user && (
                <EditProfileModal
                    user={user}
                    onClose={() => setIsEditModalOpen(false)}
                    onSave={handleSaveProfile}
                />
            )}
        </>
    );
};

export default ProfileView;

================================================================================

--- FILE: components/search/SearchModal.tsx ---

import React, { useState, useMemo } from 'react';
import { useTaskManager } from '../../hooks/useTaskManager';
import { Task } from '../../types';
import { CloseIcon, SearchIcon } from '../../constants';
import TaskItem from '../task/TaskItem';
import { useTranslation } from '../../hooks/useI18n';

interface SearchModalProps {
    onClose: () => void;
}

const SearchModal: React.FC<SearchModalProps> = ({ onClose }) => {
    const { state, dispatch } = useTaskManager();
    const { t } = useTranslation();
    const [searchTerm, setSearchTerm] = useState('');

    const searchResults = useMemo(() => {
        if (!searchTerm.trim()) {
            return [];
        }
        const lowercasedTerm = searchTerm.toLowerCase();
        return state.tasks.filter(task => 
            task.title.toLowerCase().includes(lowercasedTerm) ||
            task.description?.toLowerCase().includes(lowercasedTerm) ||
            task.tags.some(tag => tag.toLowerCase().includes(lowercasedTerm))
        );
    }, [searchTerm, state.tasks]);

    // Override TaskItem click to close modal and select task
    const handleTaskSelect = (task: Task) => {
        dispatch({ type: 'SET_SELECTED_TASK', payload: task.id });
        if (task.listId) {
             dispatch({ type: 'SET_ACTIVE_LIST', payload: task.listId });
        }
        onClose();
    };

    const getListName = (listId: string): string => {
        if (listId === 'inbox') {
            return t('specialLists.inbox');
        }
        const list = state.lists.find(l => l.id === listId);
        return list ? list.name : '';
    };

    return (
        <div className="fixed inset-0 bg-background/90 z-40 flex justify-center p-4 sm:p-6 md:p-12 animate-fade-in" onClick={onClose}>
            <div className="bg-card rounded-lg shadow-xl w-full max-w-2xl flex flex-col h-full max-h-[80vh]" onClick={e => e.stopPropagation()}>
                <header className="p-4 flex items-center border-b border-border">
                    <SearchIcon className="h-5 w-5 text-muted-foreground mr-3" />
                    <input
                        type="text"
                        value={searchTerm}
                        onChange={e => setSearchTerm(e.target.value)}
                        placeholder={t('search.placeholder')}
                        className="w-full bg-transparent text-lg focus:outline-none"
                        autoFocus
                    />
                    <button onClick={onClose} className="p-1 rounded-full hover:bg-secondary ml-4">
                        <CloseIcon className="h-5 w-5 text-muted-foreground" />
                    </button>
                </header>
                
                <div className="flex-grow p-4 overflow-y-auto">
                    {searchTerm.trim() && searchResults.length === 0 && (
                         <div className="text-center py-12 text-muted-foreground">
                            <p>{t('search.noResults', { searchTerm })}</p>
                        </div>
                    )}
                    <div className="space-y-2">
                        {searchResults.map(task => (
                            <div key={task.id} onClick={() => handleTaskSelect(task)}>
                                <TaskItem 
                                    task={task} 
                                    isDraggable={false} 
                                    listName={getListName(task.listId)}
                                />
                            </div>
                        ))}
                    </div>
                </div>
            </div>
        </div>
    );
};

export default SearchModal;

================================================================================

--- FILE: components/settings/SettingsView.tsx ---

import React, { useState } from 'react';
import { useSettings } from '../../hooks/useSettings';
import { useTranslation } from '../../hooks/useI18n';
import { SunIcon, MoonIcon, StopwatchIcon, ListBulletIcon, CalendarDaysIcon, GridIcon, RepeatIcon, HourglassIcon, HomeIcon, ViewColumnsIcon, GripVerticalIcon } from '../../constants';
import { useTaskManager } from '../../hooks/useTaskManager';
import { ViewType } from '../../types';

const ALL_FEATURES: { view: ViewType, icon: React.FC<{className?: string}>, label: string }[] = [
    { view: 'dashboard', icon: HomeIcon, label: 'feature.dashboard' },
    { view: 'list', icon: ListBulletIcon, label: 'feature.listView' },
    { view: 'board', icon: ViewColumnsIcon, label: 'feature.boardView' },
    { view: 'calendar', icon: CalendarDaysIcon, label: 'feature.calendarView' },
    { view: 'matrix', icon: GridIcon, label: 'feature.matrixView' },
    { view: 'habit', icon: RepeatIcon, label: 'feature.habitTracker' },
    { view: 'pomodoro', icon: StopwatchIcon, label: 'feature.pomodoro' },
    { view: 'countdown', icon: HourglassIcon, label: 'feature.countdown' },
];


const SettingsView: React.FC = () => {
    const { theme, setTheme, language, setLanguage, bottomNavActions, setBottomNavActions } = useSettings();
    const { state: taskState, dispatch: taskDispatch } = useTaskManager();
    const { t } = useTranslation();
    const [draggedItem, setDraggedItem] = useState<ViewType | null>(null);

    const { settings: pomodoroSettings } = taskState.pomodoro;

    const handlePomodoroSettingChange = (setting: string, value: string) => {
        const numberValue = parseInt(value, 10);
        if (!isNaN(numberValue) && numberValue >= 1) {
             // UI shows minutes, state stores seconds
            const valueInSeconds = setting.includes('Interval') ? numberValue : numberValue * 60;
            taskDispatch({
                type: 'UPDATE_POMODORO_SETTINGS',
                payload: { [setting]: valueInSeconds }
            });
        }
    };
    
     const handleIntervalChange = (value: string) => {
        const numberValue = parseInt(value, 10);
        if (!isNaN(numberValue) && numberValue >= 1) {
            taskDispatch({
                type: 'UPDATE_POMODORO_SETTINGS',
                payload: { longBreakInterval: numberValue }
            });
        }
    };

    const handleDragStart = (view: ViewType) => {
        setDraggedItem(view);
    };

    const handleDrop = (targetList: 'visible' | 'hidden') => {
        if (!draggedItem) return;

        const isVisible = bottomNavActions.includes(draggedItem);

        if (targetList === 'visible' && !isVisible) {
            if (bottomNavActions.length < 4) {
                setBottomNavActions([...bottomNavActions, draggedItem]);
            }
        } else if (targetList === 'hidden' && isVisible) {
            setBottomNavActions(bottomNavActions.filter(v => v !== draggedItem));
        }
        setDraggedItem(null);
    };

    const hiddenNavActions = ALL_FEATURES.filter(f => !bottomNavActions.includes(f.view)).map(f => f.view);

    const DraggableItem: React.FC<{ view: ViewType }> = ({ view }) => {
        const feature = ALL_FEATURES.find(f => f.view === view);
        if (!feature) return null;
        const Icon = feature.icon;
        return (
            <div
                draggable
                onDragStart={() => handleDragStart(view)}
                className="flex items-center gap-3 p-2 bg-secondary rounded-md cursor-grab active:cursor-grabbing"
            >
                <GripVerticalIcon className="h-5 w-5 text-muted-foreground" />
                <Icon className="h-5 w-5" />
                <span className="text-sm font-medium">{t(feature.label)}</span>
            </div>
        );
    };


    return (
        <div className="flex-1 flex flex-col overflow-hidden">
            <header className="p-6 border-b border-border flex-shrink-0">
                <h1 className="text-2xl font-bold">{t('settings.title')}</h1>
                <p className="text-muted-foreground">{t('settings.subtitle')}</p>
            </header>
            <main className="flex-1 p-4 md:p-6 overflow-y-auto space-y-8 pb-20 md:pb-6">
                <section>
                    <h2 className="text-lg font-semibold mb-4">{t('settings.appearance')}</h2>
                    <div className="bg-card border border-border rounded-lg p-4 max-w-md">
                        <div className="flex items-center justify-between">
                            <label htmlFor="theme" className="font-medium">{t('settings.theme')}</label>
                            <div className="flex items-center gap-2 bg-secondary p-1 rounded-md">
                                <button
                                    onClick={() => setTheme('light')}
                                    className={`flex items-center gap-2 px-3 py-1 text-sm font-semibold rounded ${theme === 'light' ? 'bg-background shadow-sm' : 'hover:bg-background/50'}`}
                                >
                                    <SunIcon className="h-4 w-4" /> {t('settings.theme.light')}
                                </button>
                                <button
                                    onClick={() => setTheme('dark')}
                                    className={`flex items-center gap-2 px-3 py-1 text-sm font-semibold rounded ${theme === 'dark' ? 'bg-background shadow-sm' : 'hover:bg-background/50'}`}
                                >
                                    <MoonIcon className="h-4 w-4" /> {t('settings.theme.dark')}
                                </button>
                            </div>
                        </div>
                    </div>
                </section>

                <section>
                    <h2 className="text-lg font-semibold mb-2">{t('settings.bottomNav.title')}</h2>
                    <p className="text-sm text-muted-foreground mb-4 max-w-xl">{t('settings.bottomNav.subtitle')}</p>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6 max-w-xl">
                        <div 
                            onDragOver={(e) => e.preventDefault()}
                            onDrop={() => handleDrop('visible')}
                            className="bg-card border border-border rounded-lg p-4"
                        >
                            <h3 className="font-semibold mb-3">{t('settings.bottomNav.visible')}</h3>
                            <div className="space-y-2 min-h-[100px]">
                                {bottomNavActions.map(view => <DraggableItem key={view} view={view} />)}
                            </div>
                        </div>
                        <div
                             onDragOver={(e) => e.preventDefault()}
                             onDrop={() => handleDrop('hidden')}
                             className="bg-card border border-border rounded-lg p-4"
                        >
                             <h3 className="font-semibold mb-3">{t('settings.bottomNav.hidden')}</h3>
                            <div className="space-y-2 min-h-[100px]">
                                {hiddenNavActions.map(view => <DraggableItem key={view} view={view} />)}
                            </div>
                        </div>
                    </div>
                </section>
                
                 <section>
                    <h2 className="text-lg font-semibold mb-4">{t('settings.pomodoro.title')}</h2>
                    <div className="bg-card border border-border rounded-lg p-4 max-w-md space-y-4">
                        <div className="flex items-center justify-between">
                            <label htmlFor="focus-duration" className="font-medium text-sm">{t('settings.pomodoro.focusDuration')}</label>
                            <input
                                id="focus-duration"
                                type="number"
                                min="1"
                                value={pomodoroSettings.pomoDuration / 60}
                                onChange={(e) => handlePomodoroSettingChange('pomoDuration', e.target.value)}
                                className="w-20 p-1.5 bg-secondary/50 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50 text-center"
                            />
                        </div>
                         <div className="flex items-center justify-between">
                            <label htmlFor="short-break" className="font-medium text-sm">{t('settings.pomodoro.shortBreak')}</label>
                            <input
                                id="short-break"
                                type="number"
                                min="1"
                                value={pomodoroSettings.shortBreakDuration / 60}
                                onChange={(e) => handlePomodoroSettingChange('shortBreakDuration', e.target.value)}
                                className="w-20 p-1.5 bg-secondary/50 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50 text-center"
                            />
                        </div>
                         <div className="flex items-center justify-between">
                            <label htmlFor="long-break" className="font-medium text-sm">{t('settings.pomodoro.longBreak')}</label>
                            <input
                                id="long-break"
                                type="number"
                                min="1"
                                value={pomodoroSettings.longBreakDuration / 60}
                                onChange={(e) => handlePomodoroSettingChange('longBreakDuration', e.target.value)}
                                className="w-20 p-1.5 bg-secondary/50 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50 text-center"
                            />
                        </div>
                         <div className="flex items-center justify-between">
                            <label htmlFor="long-break-interval" className="font-medium text-sm">{t('settings.pomodoro.longBreakInterval')}</label>
                            <input
                                id="long-break-interval"
                                type="number"
                                min="1"
                                value={pomodoroSettings.longBreakInterval}
                                onChange={(e) => handleIntervalChange(e.target.value)}
                                className="w-20 p-1.5 bg-secondary/50 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50 text-center"
                            />
                        </div>
                    </div>
                </section>

                <section>
                    <h2 className="text-lg font-semibold mb-4">{t('settings.language')}</h2>
                    <div className="bg-card border border-border rounded-lg p-4 max-w-md">
                         <div className="flex items-center justify-between">
                            <label htmlFor="language-select" className="font-medium">{t('settings.language')}</label>
                            <select
                                id="language-select"
                                value={language}
                                onChange={(e) => setLanguage(e.target.value as 'en' | 'vi')}
                                className="p-2 bg-secondary/50 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50"
                            >
                                <option value="en">{t('settings.language.en')}</option>
                                <option value="vi">{t('settings.language.vi')}</option>
                            </select>
                        </div>
                    </div>
                </section>
            </main>
        </div>
    );
};

export default SettingsView;

================================================================================

--- FILE: components/task/TaskDetail.tsx ---

import React, { useState, useEffect } from 'react';
import { useTaskManager } from '../../hooks/useTaskManager';
import { Task, Subtask, Priority, Comment } from '../../types';
import { PRIORITY_MAP, CloseIcon, SparklesIcon, GlobeAltIcon, GripVerticalIcon, PlayCircleIcon, StopwatchIcon, RepeatIcon, CheckIcon, ChatBubbleOvalLeftEllipsisIcon } from '../../constants';
import { generateSubtasks, getGroundedInfo } from '../../services/geminiService';
import Spinner from '../ui/Spinner';
import DatePicker from '../ui/DatePicker';
import RecurrencePicker from '../ui/RecurrencePicker';
import ReminderSetter from '../ui/ReminderSetter';
import { useTranslation } from '../../hooks/useI18n';
import { useGemini } from '../../hooks/useGemini';
import { useToast } from '../../hooks/useToast';
import AssigneePicker from '../collaboration/AssigneePicker';
import CommentSection from '../collaboration/CommentSection';


interface TaskDetailProps {
    taskId: string;
}

const TaskDetail: React.FC<TaskDetailProps> = ({ taskId }) => {
    const { state, dispatch } = useTaskManager();
    const { t } = useTranslation();
    const { ai, isAvailable: isGeminiAvailable } = useGemini();
    const addToast = useToast();
    const [task, setTask] = useState<Task | null>(null);
    const [isGenerating, setIsGenerating] = useState(false);
    const [isSearching, setIsSearching] = useState(false);
    const [newSubtask, setNewSubtask] = useState('');
    const [newTag, setNewTag] = useState('');
    const [draggedIndex, setDraggedIndex] = useState<number | null>(null);
    const [draggedTagIndex, setDraggedTagIndex] = useState<number | null>(null);

    useEffect(() => {
        const foundTask = state.tasks.find(t => t.id === taskId);
        setTask(foundTask || null);
    }, [taskId, state.tasks]);

    if (!task) {
        return null;
    }
    
    const completedSubtasks = task.subtasks.filter(st => st.completed).length;

    const formatFocusTime = (seconds: number): string => {
        if (seconds < 60) return `${seconds}s`;
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        let result = '';
        if (hours > 0) result += `${hours}h `;
        if (minutes > 0) result += `${minutes}m`;
        return result.trim();
    };

    const handleClose = () => dispatch({ type: 'SET_SELECTED_TASK', payload: null });
    
    const updateTask = (updates: Partial<Task>) => {
        if (!task) return;
        const updatedTask = { ...task, ...updates };
        setTask(updatedTask); // Local update for responsiveness
        // Debounced update would be ideal here in a real app
        dispatch({ type: 'UPDATE_TASK', payload: updatedTask });
    };

    const handleStartFocus = () => {
        dispatch({ type: 'SET_FOCUSED_TASK', payload: task.id });
        dispatch({ type: 'START_TIMER' });
        dispatch({ type: 'SET_VIEW', payload: 'pomodoro' });
        handleClose();
    };
    
    const handleSubtaskChange = (subtaskId: string, completed: boolean) => {
        const newSubtasks = task.subtasks.map(st => st.id === subtaskId ? { ...st, completed } : st);
        updateTask({ subtasks: newSubtasks });
    };

    const handleAddSubtask = (e: React.FormEvent) => {
        e.preventDefault();
        if(newSubtask.trim()){
            const subtask: Subtask = { id: Date.now().toString(), title: newSubtask.trim(), completed: false };
            updateTask({ subtasks: [...task.subtasks, subtask] });
            setNewSubtask('');
        }
    };

    const handleGenerateSubtasks = async () => {
        if (!task || !ai) return;
        setIsGenerating(true);
        try {
            const generated = await generateSubtasks(ai, task.title);
            const newSubtasks = generated.map((title, i) => ({ id: `gen-${Date.now()}-${i}`, title, completed: false }));
            updateTask({ subtasks: [...task.subtasks, ...newSubtasks] });
        } catch (error: any) {
            addToast(error.message || 'Failed to generate subtasks', 'error');
        } finally {
            setIsGenerating(false);
        }
    };
    
    const handleGetGroundedInfo = async () => {
        if (!task || !ai) return;
        setIsSearching(true);
        try {
            const { summary, sources } = await getGroundedInfo(ai, task.title);
            const formattedSources = sources.map(s => `- [${s.title}](${s.uri})`).join('\n');
            const newDescription = `${task.description || ''}\n\n**Related Information (from Gemini):**\n${summary}\n\n**Sources:**\n${formattedSources}`;
            updateTask({ description: newDescription.trim(), groundingSources: sources });
        } catch (error: any) {
            addToast(error.message || 'Failed to get info', 'error');
        } finally {
            setIsSearching(false);
        }
    };

    const handleAddTag = (e: React.KeyboardEvent<HTMLInputElement>) => {
        if (e.key === 'Enter' && newTag.trim()) {
            e.preventDefault();
            const trimmedTag = newTag.trim().toLowerCase();
            if (trimmedTag && !task.tags.includes(trimmedTag)) {
                updateTask({ tags: [...task.tags, trimmedTag] });
            }
            setNewTag('');
        }
    };

    const handleRemoveTag = (tagToRemove: string) => {
        updateTask({ tags: task.tags.filter(tag => tag !== tagToRemove) });
    };

    const handleAssignTask = (userId: string | null) => {
        dispatch({ type: 'ASSIGN_TASK', payload: { taskId: task.id, userId } });
    };

    const handleAddComment = (content: string) => {
        const newComment: Comment = {
            id: Date.now().toString(),
            userId: 'user-001', // Should be the current user's ID
            content,
            createdAt: new Date().toISOString(),
        };
        dispatch({ type: 'ADD_COMMENT', payload: { taskId: task.id, comment: newComment } });
    };

    // Drag and Drop handlers for subtasks and tags
    const handleDragStart = (e: React.DragEvent<HTMLDivElement>, index: number) => { setDraggedIndex(index); e.dataTransfer.effectAllowed = 'move'; };
    const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => e.preventDefault();
    const handleDrop = (e: React.DragEvent<HTMLDivElement>, dropIndex: number) => {
        e.preventDefault();
        if (draggedIndex === null || draggedIndex === dropIndex) { setDraggedIndex(null); return; }
        const newSubtasks = [...task.subtasks];
        const [draggedItem] = newSubtasks.splice(draggedIndex, 1);
        newSubtasks.splice(dropIndex, 0, draggedItem);
        updateTask({ subtasks: newSubtasks });
        setDraggedIndex(null);
    };
    const handleDragEnd = () => setDraggedIndex(null);
    const handleTagDragStart = (e: React.DragEvent<HTMLSpanElement>, index: number) => { setDraggedTagIndex(index); e.dataTransfer.effectAllowed = 'move'; };
    const handleTagDragOver = (e: React.DragEvent<HTMLSpanElement>) => e.preventDefault();
    const handleTagDrop = (e: React.DragEvent<HTMLSpanElement>, dropIndex: number) => {
        e.preventDefault();
        if (draggedTagIndex === null || draggedTagIndex === dropIndex) { setDraggedTagIndex(null); return; }
        const newTags = [...task.tags];
        const [draggedItem] = newTags.splice(draggedTagIndex, 1);
        newTags.splice(dropIndex, 0, draggedItem);
        updateTask({ tags: newTags });
        setDraggedTagIndex(null);
    };
    const handleTagDragEnd = () => setDraggedTagIndex(null);
    
    const recurrenceText = task.recurrence ? t(`recurrence.${task.recurrence.rule}`) : '';

    return (
        <div className="h-full w-full md:w-96 bg-card border-l border-border shadow-2xl flex flex-col md:animate-slide-in">
            <header className="p-4 border-b border-border flex items-center justify-between flex-shrink-0">
                <div className="flex items-center gap-2">
                    <button
                        onClick={() => dispatch({ type: 'TOGGLE_TASK_COMPLETION', payload: { taskId: task.id } })}
                        aria-label={task.completed ? t('taskItem.aria.markIncomplete') : t('taskItem.aria.markComplete')}
                        className={`
                            h-5 w-5 rounded flex-shrink-0
                            flex items-center justify-center 
                            transition-all duration-150
                            focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2
                            ${task.completed 
                                ? 'bg-primary border-2 border-primary' 
                                : 'bg-transparent border-2 border-muted-foreground/50'
                            }
                        `}
                    >
                        {task.completed && <CheckIcon className="h-3.5 w-3.5 text-primary-foreground" />}
                    </button>
                    <label 
                        onClick={() => dispatch({ type: 'TOGGLE_TASK_COMPLETION', payload: { taskId: task.id } })}
                        className="text-sm text-muted-foreground cursor-pointer"
                    >
                        {task.completed ? t('taskDetail.completed') : t('taskDetail.markComplete')}
                    </label>
                </div>
                <div className="flex items-center gap-2">
                    <button onClick={handleClose} className="p-1 rounded-full hover:bg-secondary">
                        <CloseIcon className="h-5 w-5 text-muted-foreground" />
                    </button>
                </div>
            </header>

            <div className="flex-grow p-6 overflow-y-auto">
                <input
                    type="text"
                    value={task.title}
                    onChange={(e) => updateTask({ title: e.target.value })}
                    className="text-2xl font-bold bg-transparent w-full focus:outline-none focus:bg-secondary/50 rounded-md p-2"
                />
                
                 {task.recurrence && (
                    <div className="mt-2 flex items-center gap-2 text-sm text-muted-foreground p-2 bg-secondary/50 rounded-md">
                        <RepeatIcon className="h-4 w-4" />
                        <span>{t('taskDetail.recurringInfo', { rule: recurrenceText })}</span>
                    </div>
                )}
                
                {task.totalFocusTime > 0 && (
                     <div className="mt-4 flex items-center gap-2 text-sm text-muted-foreground p-2">
                        <StopwatchIcon className="h-5 w-5" />
                        <span dangerouslySetInnerHTML={{ __html: t('taskDetail.focusTime', { time: formatFocusTime(task.totalFocusTime) }) }} />
                    </div>
                )}

                <div className="mt-6 space-y-4">
                    <div>
                        <label htmlFor="task-description" className="text-sm font-medium text-muted-foreground">{t('taskDetail.descriptionLabel')}</label>
                        <textarea
                            id="task-description"
                            value={task.description || ''}
                            onChange={(e) => updateTask({ description: e.target.value })}
                            rows={4}
                            placeholder={t('taskDetail.descriptionPlaceholder')}
                            className="mt-1 w-full p-2 bg-secondary/50 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50"
                        />
                    </div>
                     {task.groundingSources && task.groundingSources.length > 0 && (
                        <div>
                            <h4 className="text-sm font-medium text-muted-foreground mb-2">{t('taskDetail.sourcesLabel')}</h4>
                            <ul className="space-y-1">
                                {task.groundingSources.map((source, index) => (
                                    <li key={index} className="text-sm">
                                        <a href={source.uri} target="_blank" rel="noopener noreferrer" className="text-blue-500 hover:underline break-all">
                                            {source.title || source.uri}
                                        </a>
                                    </li>
                                ))}
                            </ul>
                        </div>
                    )}


                    <div className="grid grid-cols-2 gap-4">
                         <AssigneePicker
                            currentAssigneeId={task.assigneeId}
                            onAssign={handleAssignTask}
                        />
                         <div>
                            <label htmlFor="task-priority" className="text-sm font-medium text-muted-foreground">{t('taskDetail.priorityLabel')}</label>
                            <select
                                id="task-priority"
                                value={task.priority}
                                onChange={(e) => updateTask({ priority: parseInt(e.target.value) as Priority })}
                                className="w-full mt-1 p-2 bg-secondary/50 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50 appearance-none"
                            >
                                {Object.entries(PRIORITY_MAP).map(([p, { label }]) => (
                                    <option key={p} value={p}>{t(label)}</option>
                                ))}
                            </select>
                        </div>
                    </div>

                    <div className="grid grid-cols-2 gap-4">
                        <DatePicker
                            value={task.dueDate}
                            onChange={(date) => updateTask({ dueDate: date ? date.toISOString() : undefined })}
                        />
                        <RecurrencePicker 
                            recurrence={task.recurrence} 
                            onChange={(r) => dispatch({ type: 'SET_TASK_RECURRENCE', payload: { taskId: task.id, recurrence: r } })}
                        />
                    </div>

                    <div className="grid grid-cols-1">
                         <ReminderSetter
                            reminder={task.reminderMinutes}
                            onChange={(m) => dispatch({ type: 'SET_TASK_REMINDER', payload: { taskId: task.id, reminderMinutes: m }})}
                        />
                    </div>
                    
                    <div>
                        <label htmlFor="tag-input" className="text-sm font-medium text-muted-foreground">{t('taskDetail.tagsLabel')}</label>
                        <div className="mt-2 flex flex-wrap gap-2 items-center p-2 bg-secondary/50 rounded-md">
                            {task.tags.map((tag, index) => (
                                <span 
                                    key={tag}
                                    draggable
                                    onDragStart={(e) => handleTagDragStart(e, index)}
                                    onDragOver={handleTagDragOver}
                                    onDrop={(e) => handleTagDrop(e, index)}
                                    onDragEnd={handleTagDragEnd}
                                    className={`flex items-center gap-1 bg-secondary px-2 py-1 rounded-full text-xs font-medium cursor-move transition-opacity ${draggedTagIndex === index ? 'opacity-50' : 'opacity-100'}`}>
                                    {tag}
                                    <button onClick={() => handleRemoveTag(tag)} className="rounded-full hover:bg-muted-foreground/20 z-10">
                                        <CloseIcon className="h-3 w-3" />
                                    </button>
                                </span>
                            ))}
                            <input
                                id="tag-input"
                                type="text"
                                value={newTag}
                                onChange={e => setNewTag(e.target.value)}
                                onKeyDown={handleAddTag}
                                placeholder={t('taskDetail.tagsPlaceholder')}
                                className="flex-grow bg-transparent text-sm focus:outline-none"
                            />
                        </div>
                        <p className="text-xs text-muted-foreground mt-1">{t('taskDetail.tagsHelper')}</p>
                    </div>

                    <div>
                        <div className="flex items-center justify-between mb-1">
                             <h3 className="text-sm font-medium text-muted-foreground">{t('taskDetail.subtasksLabel')}</h3>
                             {isGeminiAvailable && (
                                <button onClick={handleGenerateSubtasks} disabled={isGenerating} className="text-xs flex items-center gap-1 text-primary hover:text-primary/80 disabled:opacity-50">
                                    {isGenerating ? <Spinner className="h-4 w-4" /> : <SparklesIcon className="h-4 w-4" />}
                                    {t('taskDetail.generateButton')}
                                </button>
                             )}
                        </div>
                        {task.subtasks.length > 0 && (
                            <div className="my-2">
                                <div className="flex justify-between text-xs text-muted-foreground mb-1">
                                    <span>{t('taskDetail.progressLabel')}</span>
                                    <span>{completedSubtasks} / {task.subtasks.length}</span>
                                </div>
                                <div className="w-full bg-secondary rounded-full h-2">
                                    <div
                                        className="bg-primary h-2 rounded-full transition-all"
                                        style={{ width: `${(completedSubtasks / task.subtasks.length) * 100}%` }}
                                    ></div>
                                </div>
                            </div>
                        )}
                        <div className="mt-2 space-y-2">
                            {isGenerating && (
                                <div className="space-y-2">
                                    <div className="h-10 bg-secondary/50 rounded-md animate-pulse"></div>
                                    <div className="h-10 bg-secondary/50 rounded-md animate-pulse delay-75"></div>
                                </div>
                            )}
                            {task.subtasks.map((st, index) => (
                                <div 
                                    key={st.id}
                                    draggable
                                    onDragStart={(e) => handleDragStart(e, index)}
                                    onDragOver={handleDragOver}
                                    onDrop={(e) => handleDrop(e, index)}
                                    onDragEnd={handleDragEnd}
                                    className={`flex items-center gap-2 p-2 bg-secondary/50 rounded-md transition-opacity group ${draggedIndex === index ? 'opacity-50' : 'opacity-100'}`}
                                >
                                    <GripVerticalIcon className="h-5 w-5 text-muted-foreground/50 cursor-move group-hover:text-muted-foreground" />
                                    <button
                                        onClick={() => handleSubtaskChange(st.id, !st.completed)}
                                        aria-label={st.completed ? t('taskItem.aria.markIncomplete') : t('taskItem.aria.markComplete')}
                                        className={`
                                            h-4 w-4 rounded-sm flex-shrink-0
                                            flex items-center justify-center 
                                            transition-all duration-150
                                            focus:outline-none focus:ring-1 focus:ring-ring
                                            ${st.completed 
                                                ? 'bg-primary border border-primary' 
                                                : 'bg-transparent border border-muted-foreground/50'
                                            }
                                        `}
                                    >
                                        {st.completed && <CheckIcon className="h-2.5 w-2.5 text-primary-foreground" />}
                                    </button>
                                    <input type="text" value={st.title} 
                                        onChange={(e) => updateTask({ subtasks: task.subtasks.map(sub => sub.id === st.id ? {...sub, title: e.target.value} : sub)})}
                                        className={`flex-grow bg-transparent text-sm ${st.completed ? 'line-through text-muted-foreground' : ''} focus:outline-none`} 
                                    />
                                </div>
                            ))}
                            <form onSubmit={handleAddSubtask} className="flex items-center gap-2 p-2">
                                <input type="text" value={newSubtask} onChange={e => setNewSubtask(e.target.value)} placeholder={t('taskDetail.addSubtaskPlaceholder')} className="flex-grow bg-transparent text-sm focus:outline-none" />
                                <button type="submit" className="text-primary text-sm font-semibold">{t('taskDetail.addButton')}</button>
                            </form>
                        </div>
                    </div>
                </div>
                
                <div className="p-6 border-t border-border">
                    <CommentSection comments={task.comments || []} onAddComment={handleAddComment} />
                </div>
             </div>
             <div className="p-4 border-t border-border flex gap-2 flex-shrink-0">
                <button onClick={handleGetGroundedInfo} disabled={isSearching || !isGeminiAvailable} className="text-sm w-full flex items-center justify-center gap-2 px-4 py-2 rounded-md bg-secondary hover:bg-muted transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                    {isSearching ? <Spinner/> : <GlobeAltIcon className="h-5 w-5" />} {t('taskDetail.getInfoButton')}
                </button>
                 <button onClick={handleStartFocus} className="text-sm w-full flex items-center justify-center gap-2 px-4 py-2 rounded-md bg-primary text-primary-foreground hover:bg-primary/90 transition-colors">
                    <PlayCircleIcon className="h-5 w-5" /> {t('taskDetail.startFocusButton')}
                </button>
            </div>
        </div>
    );
};

export default TaskDetail;

================================================================================

--- FILE: components/task/TaskForm.tsx ---

import React, { useState, useEffect } from 'react';
import { useTaskManager } from '../../hooks/useTaskManager';
import { Task, Priority } from '../../types';
import { CloseIcon, SparklesIcon, PRIORITY_MAP } from '../../constants';
import { analyzeTextForTask } from '../../services/geminiService';
import Spinner from '../ui/Spinner';
import { useTranslation } from '../../hooks/useI18n';
import { useGemini } from '../../hooks/useGemini';
import { useToast } from '../../hooks/useToast';

interface TaskFormProps {
    onClose: () => void;
    defaultValues?: {
        listId?: string;
        columnId?: string;
    }
}

const TaskForm: React.FC<TaskFormProps> = ({ onClose, defaultValues }) => {
    const { state, dispatch } = useTaskManager();
    const { t } = useTranslation();
    const { ai, isAvailable: isGeminiAvailable } = useGemini();
    const addToast = useToast();

    const getInitialListId = () => {
        const initial = defaultValues?.listId || state.activeListId;
        // Special lists other than inbox are not selectable in the form. Default to inbox.
        if (initial === 'today' || initial === 'upcoming') {
            return 'inbox';
        }
        // Ensure the list exists, otherwise default to inbox
        const listExists = state.lists.some(l => l.id === initial);
        if (initial !== 'inbox' && !listExists) {
            return 'inbox';
        }
        return initial;
    };

    const [title, setTitle] = useState('');
    const [description, setDescription] = useState('');
    const [dueDate, setDueDate] = useState('');
    const [priority, setPriority] = useState<Priority>(Priority.None);
    const [listId, setListId] = useState(getInitialListId());
    const [columnId, setColumnId] = useState(defaultValues?.columnId);
    const [textToAnalyze, setTextToAnalyze] = useState('');
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    
    useEffect(() => {
        // Ensure columnId is valid for the selected listId, or clear it
        const columnsForList = state.columns.filter(c => c.listId === listId);
        if (columnId && !columnsForList.some(c => c.id === columnId)) {
            setColumnId(columnsForList[0]?.id);
        } else if (!columnId) {
             setColumnId(columnsForList[0]?.id);
        }
    }, [listId, columnId, state.columns]);


    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (title.trim()) {
            const newTask: Task = {
                id: Date.now().toString(),
                title: title.trim(),
                description: description.trim(),
                completed: false,
                dueDate: dueDate ? new Date(dueDate).toISOString() : undefined,
                priority,
                listId: listId || 'inbox',
                columnId: columnId,
                tags: [],
                subtasks: [],
                createdAt: new Date().toISOString(),
                totalFocusTime: 0,
            };
            dispatch({ type: 'ADD_TASK', payload: newTask });
            onClose();
        }
    };
    
    const handleAnalyzeText = async () => {
        if (!textToAnalyze.trim() || !ai) return;
        setIsAnalyzing(true);
        try {
            const result = await analyzeTextForTask(ai, textToAnalyze);
            if(result.title) setTitle(result.title);
            if(result.description) setDescription(result.description);
            if(result.dueDate) setDueDate(new Date(result.dueDate).toISOString().split('T')[0]);
            // Subtasks can be added in detail view
            setTextToAnalyze('');
        } catch (error: any) {
            addToast(error.message || 'Failed to analyze text', 'error');
        } finally {
            setIsAnalyzing(false);
        }
    };

    return (
        <div className="fixed inset-0 bg-black/50 z-30 flex items-center justify-center p-4">
            <div className="bg-card rounded-lg shadow-xl w-full max-w-lg flex flex-col max-h-[90vh]">
                <header className="p-4 border-b border-border flex items-center justify-between">
                    <h2 className="text-lg font-semibold">{t('taskForm.newTask')}</h2>
                    <button onClick={onClose} className="p-1 rounded-full hover:bg-secondary">
                        <CloseIcon className="h-5 w-5 text-muted-foreground" />
                    </button>
                </header>
                
                <div className="p-6 overflow-y-auto">
                    {isGeminiAvailable && (
                        <div className="mb-4 p-4 border border-dashed border-border rounded-lg">
                            <label className="text-sm font-medium text-muted-foreground mb-2 block">{t('taskForm.createWithGemini')}</label>
                            <textarea
                                value={textToAnalyze}
                                onChange={e => setTextToAnalyze(e.target.value)}
                                placeholder={t('taskForm.geminiPlaceholder')}
                                rows={3}
                                className="w-full p-2 bg-secondary/50 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50"
                            />
                            <button onClick={handleAnalyzeText} disabled={isAnalyzing} className="mt-2 w-full text-sm flex items-center justify-center gap-2 px-4 py-2 rounded-md bg-secondary hover:bg-muted transition-colors disabled:opacity-50">
                                {isAnalyzing ? <Spinner /> : <SparklesIcon className="h-4 w-4 text-primary" />}
                                {t('taskForm.analyzeAndFill')}
                            </button>
                        </div>
                    )}

                    <form onSubmit={handleSubmit} className="space-y-4">
                        <div>
                            <label className="text-sm font-medium text-muted-foreground">{t('taskForm.titleLabel')}</label>
                            <input
                                type="text"
                                value={title}
                                onChange={e => setTitle(e.target.value)}
                                placeholder={t('taskForm.titlePlaceholder')}
                                className="mt-1 w-full p-2 bg-secondary/50 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50"
                                required
                            />
                        </div>
                        <div>
                            <label className="text-sm font-medium text-muted-foreground">{t('taskForm.descriptionLabel')}</label>
                            <textarea
                                value={description}
                                onChange={e => setDescription(e.target.value)}
                                rows={3}
                                placeholder={t('taskForm.descriptionPlaceholder')}
                                className="mt-1 w-full p-2 bg-secondary/50 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50"
                            />
                        </div>
                        <div className="grid grid-cols-2 gap-4">
                            <div>
                                <label className="text-sm font-medium text-muted-foreground">{t('taskForm.dueDateLabel')}</label>
                                <input
                                    type="date"
                                    value={dueDate}
                                    onChange={e => setDueDate(e.target.value)}
                                    className="mt-1 w-full p-2 bg-secondary/50 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50"
                                />
                            </div>
                            <div>
                                <label className="text-sm font-medium text-muted-foreground">{t('taskForm.priorityLabel')}</label>
                                <select value={priority} onChange={e => setPriority(parseInt(e.target.value) as Priority)} className="mt-1 w-full p-2 bg-secondary/50 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50">
                                    {Object.entries(PRIORITY_MAP).map(([p, { label }]) => (
                                        <option key={p} value={p}>{t(label)}</option>
                                    ))}
                                </select>
                            </div>
                        </div>
                        <div>
                            <label className="text-sm font-medium text-muted-foreground">{t('taskForm.listLabel')}</label>
                            <select value={listId} onChange={e => setListId(e.target.value)} className="mt-1 w-full p-2 bg-secondary/50 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50">
                                <option value="inbox">{t('specialLists.inbox')}</option>
                                {state.lists.map(list => <option key={list.id} value={list.id}>{list.name}</option>)}
                            </select>
                        </div>
                    </form>
                </div>

                <footer className="p-4 border-t border-border flex justify-end">
                    <button onClick={handleSubmit} type="submit" className="px-4 py-2 bg-primary text-primary-foreground rounded-md text-sm font-semibold hover:bg-primary/90">
                        {t('taskForm.createTask')}
                    </button>
                </footer>
            </div>
        </div>
    );
};

export default TaskForm;

================================================================================

--- FILE: components/task/TaskItem.tsx ---

import React, { useState } from 'react';
import { Task } from '../../types';
import { useTaskManager } from '../../hooks/useTaskManager';
import { PRIORITY_MAP, PlayCircleIcon, BellIcon, RepeatIcon, CheckCircleIcon, ArrowUpIcon, ArrowDownIcon, CheckIcon } from '../../constants';
import { useUser } from '../../hooks/useUser';
import Avatar from '../ui/Avatar';
import { useTranslation } from '../../hooks/useI18n';


// Helper functions to replace date-fns
const isToday = (date: Date): boolean => {
    const today = new Date();
    return date.getDate() === today.getDate() &&
           date.getMonth() === today.getMonth() &&
           date.getFullYear() === today.getFullYear();
};

const isPast = (date: Date): boolean => {
    const today = new Date();
    today.setHours(0, 0, 0, 0); // Compare with start of today
    return date.getTime() < today.getTime();
}

interface TaskItemProps {
    task: Task;
    isDraggable: boolean;
    onDragStart?: (taskId: string) => void;
    onDrop?: (droppedOnId: string) => void;
    listName?: string;
}

const TaskItem: React.FC<TaskItemProps> = ({ task, isDraggable, onDragStart, onDrop, listName }) => {
    const { dispatch } = useTaskManager();
    const { t } = useTranslation();
    const { allUsers } = useUser();
    const [isDragOver, setIsDragOver] = useState(false);
    const [isSubtasksOpen, setIsSubtasksOpen] = useState(true);

    const assignee = allUsers.find(u => u.id === task.assigneeId);

    const handleToggle = (e: React.MouseEvent) => {
        e.stopPropagation();
        dispatch({ type: 'TOGGLE_TASK_COMPLETION', payload: { taskId: task.id } });
    };

    const handleSubtaskToggle = (e: React.MouseEvent, subtaskId: string) => {
        e.stopPropagation();
        const newSubtasks = task.subtasks.map(st => 
            st.id === subtaskId ? { ...st, completed: !st.completed } : st
        );
        dispatch({ type: 'UPDATE_TASK', payload: { ...task, subtasks: newSubtasks } });
    };

    const handleSelect = () => {
        const originalId = task.id.split('_')[0]; // Handle recurring instances
        dispatch({ type: 'SET_SELECTED_TASK', payload: originalId });
    };

    const handleStartFocus = (e: React.MouseEvent) => {
        e.stopPropagation();
        dispatch({ type: 'SET_FOCUSED_TASK', payload: task.id });
        dispatch({ type: 'START_TIMER' });
    };
    
    const handleDragStart = (e: React.DragEvent) => {
        e.stopPropagation();
        if (isDraggable && onDragStart) {
            e.dataTransfer.effectAllowed = 'move';
            onDragStart(task.id);
        }
    };
    
    const handleDrop = (e: React.DragEvent) => {
        e.stopPropagation();
        if (isDraggable && onDrop) {
            onDrop(task.id);
        }
        setIsDragOver(false);
    };

    const handleDragOver = (e: React.DragEvent) => {
        e.preventDefault(); // Necessary for drop to work
        e.stopPropagation();
        if (isDraggable) {
            setIsDragOver(true);
        }
    };
    
    const handleDragLeave = (e: React.DragEvent) => {
        e.stopPropagation();
        setIsDragOver(false);
    };

    const dueDateLabel = () => {
        if (!task.dueDate) return null;
        const date = new Date(task.dueDate);
        const isDuePast = isPast(date) && !isToday(date);
        const color = isDuePast ? 'text-destructive' : 'text-muted-foreground';
        
        return <span className={`text-xs ${color}`}>{date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' })}</span>;
    };
    
    const priorityClasses = PRIORITY_MAP[task.priority];

    const progressIndicator = () => {
        if (task.subtasks && task.subtasks.length > 0) {
            const completed = task.subtasks.filter(st => st.completed).length;
            return (
                <span className="text-xs flex items-center gap-1 text-muted-foreground">
                    <CheckCircleIcon className="h-4 w-4" />
                    {completed}/{task.subtasks.length}
                </span>
            );
        }
        return null;
    };

    return (
        <div>
            <div 
                onClick={handleSelect}
                draggable={isDraggable && !task.completed}
                onDragStart={handleDragStart}
                onDrop={handleDrop}
                onDragOver={handleDragOver}
                onDragLeave={handleDragLeave}
                onDragEnd={() => setIsDragOver(false)}
                className={`
                    group flex items-center p-3 bg-card shadow-sm relative
                    transition-all duration-200 ease-in-out
                    ${isDraggable && !task.completed ? 'cursor-grab' : 'cursor-pointer'}
                    ${task.completed ? 'opacity-50' : 'opacity-100'}
                    ${isDragOver ? 'bg-primary/10 shadow-lg' : 'hover:shadow-md'}
                    ${task.subtasks.length > 0 && isSubtasksOpen ? 'rounded-t-lg' : 'rounded-lg'}
                `}
            >
                <button
                    onClick={handleToggle}
                    aria-label={task.completed ? t('taskItem.aria.markIncomplete') : t('taskItem.aria.markComplete')}
                    className={`
                        h-5 w-5 rounded flex-shrink-0
                        flex items-center justify-center 
                        transition-all duration-150 transform hover:scale-110
                        focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2
                        ${task.completed 
                            ? 'bg-primary border-2 border-primary' 
                            : `bg-transparent border-2 ${priorityClasses.checkboxBorderColor}`
                        }
                    `}
                >
                    {task.completed && <CheckIcon className="h-3.5 w-3.5 text-primary-foreground" />}
                </button>
                <div className="ml-4 flex-grow flex items-center gap-2">
                    <p className={`text-sm ${task.completed ? 'line-through text-muted-foreground' : 'text-foreground'}`}>
                        {task.title}
                    </p>
                    {task.subtasks.length > 0 && (
                        <button onClick={(e) => { e.stopPropagation(); setIsSubtasksOpen(!isSubtasksOpen); }} className="p-1 rounded-full opacity-0 group-hover:opacity-100 hover:bg-secondary transition-opacity">
                            {isSubtasksOpen ? <ArrowUpIcon className="h-4 w-4 text-muted-foreground" /> : <ArrowDownIcon className="h-4 w-4 text-muted-foreground" />}
                        </button>
                    )}
                </div>
                <div className="flex items-center gap-3 ml-auto text-sm text-muted-foreground">
                    {!task.completed && (
                        <button
                            onClick={handleStartFocus}
                            className="opacity-0 group-hover:opacity-100 transition-opacity text-muted-foreground hover:text-primary"
                            aria-label={t('taskItem.aria.startFocus')}
                        >
                            <PlayCircleIcon className="h-6 w-6" />
                        </button>
                    )}
                    <div className="flex items-center gap-2">
                        {listName && <span className="text-xs bg-secondary px-1.5 py-0.5 rounded-md">{listName}</span>}
                        {progressIndicator()}
                        {dueDateLabel()}
                        {task.recurrence && <RepeatIcon className="h-4 w-4" title={t('taskItem.title.repeats', { rule: task.recurrence.rule })} />}
                        {task.reminderMinutes && <BellIcon className="h-4 w-4" title={t('taskItem.title.reminder', { minutes: task.reminderMinutes })} />}
                        {assignee && <Avatar user={assignee} className="w-5 h-5" />}
                    </div>
                </div>
            </div>
            {isSubtasksOpen && task.subtasks.length > 0 && (
                <div className={`bg-card rounded-b-lg pl-6 pr-4 pb-3 pt-2 animate-accordion-down`}>
                    <div className="relative">
                        <div className="absolute left-4 top-0 w-px h-full bg-border"></div>
                        <div className="space-y-2">
                            {task.subtasks.map(subtask => (
                                <div key={subtask.id} className="flex items-center group relative pl-8">
                                    <div className="absolute left-4 top-1/2 w-4 h-px bg-border -translate-y-1/2"></div>
                                    <div className="flex items-center gap-3 w-full">
                                        <button
                                            onClick={(e) => handleSubtaskToggle(e, subtask.id)}
                                            aria-label={subtask.completed ? t('taskItem.aria.markIncomplete') : t('taskItem.aria.markComplete')}
                                            className={`
                                                h-4 w-4 rounded-sm flex-shrink-0
                                                flex items-center justify-center 
                                                transition-all duration-150 transform hover:scale-110
                                                focus:outline-none focus:ring-1 focus:ring-ring
                                                ${subtask.completed 
                                                    ? 'bg-primary border border-primary' 
                                                    : 'bg-transparent border border-muted-foreground/50'
                                                }
                                            `}
                                        >
                                            {subtask.completed && <CheckIcon className="h-2.5 w-2.5 text-primary-foreground" />}
                                        </button>
                                        <p className={`text-sm flex-grow ${subtask.completed ? 'line-through text-muted-foreground' : 'text-foreground'}`}>
                                            {subtask.title}
                                        </p>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
};

export default TaskItem;

================================================================================

--- FILE: components/task/TaskList.tsx ---

import React, { useMemo, useState } from 'react';
import TaskItem from './TaskItem';
import { useTaskManager } from '../../hooks/useTaskManager';
import { Task, SpecialList, SortOrder } from '../../types';
import { PlusIcon, EMPTY_STATE_ILLUSTRATIONS, ArrowUpIcon, ArrowDownIcon } from '../../constants';
import { useTranslation } from '../../hooks/useI18n';

interface TaskListProps {
    onAddTask: () => void;
}

// Helper functions for date calculations
const isToday = (date: Date): boolean => {
    const today = new Date();
    return date.getDate() === today.getDate() &&
           date.getMonth() === today.getMonth() &&
           date.getFullYear() === today.getFullYear();
};

const isTomorrow = (date: Date): boolean => {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    return date.getDate() === tomorrow.getDate() &&
           date.getMonth() === tomorrow.getMonth() &&
           date.getFullYear() === tomorrow.getFullYear();
};

const isFuture = (date: Date): boolean => {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const otherDate = new Date(date);
    otherDate.setHours(0, 0, 0, 0);
    return otherDate.getTime() > today.getTime();
}

const isOverdue = (date: Date): boolean => {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const checkDate = new Date(date);
    checkDate.setHours(0, 0, 0, 0);
    return checkDate.getTime() < today.getTime();
}

const groupUpcomingTasks = (tasks: Task[], t: (key: string) => string): { [key: string]: Task[] } => {
    const groups: { [key: string]: Task[] } = {};
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const tomorrow = new Date(today);
    tomorrow.setDate(today.getDate() + 1);

    const endOfWeek = new Date(today);
    // Set to the upcoming Sunday
    endOfWeek.setDate(today.getDate() + (7 - today.getDay()) % 7);

    tasks.forEach(task => {
        if (!task.dueDate) return;
        const dueDate = new Date(task.dueDate);
        dueDate.setHours(0, 0, 0, 0);

        // Skip non-future tasks
        if (dueDate < today) return;

        let groupKey: string;

        if (isTomorrow(dueDate)) {
            groupKey = t('specialLists.tomorrow'); // Using a key for "Tomorrow"
        } else if (dueDate > tomorrow && dueDate <= endOfWeek) {
            groupKey = dueDate.toLocaleDateString(undefined, { weekday: 'long' });
        } else {
            groupKey = dueDate.toLocaleDateString(undefined, { weekday: 'long', month: 'short', day: 'numeric' });
        }

        if (!groups[groupKey]) {
            groups[groupKey] = [];
        }
        groups[groupKey].push(task);
    });

    return groups;
};


const TaskList: React.FC<TaskListProps> = ({ onAddTask }) => {
    const { state, dispatch } = useTaskManager();
    const { t } = useTranslation();
    const [draggedTaskId, setDraggedTaskId] = useState<string | null>(null);
    const [isCompletedOpen, setIsCompletedOpen] = useState(false);

    const filteredTasks = useMemo(() => {
        if (state.activeTag) {
            return state.tasks.filter(task => task.tags.includes(state.activeTag!));
        }

        switch (state.activeListId as SpecialList | string) {
            case 'today':
                 // A recurring task not completed and overdue should appear in 'Today'
                return state.tasks.filter(task => {
                    if (!task.dueDate) return false;
                    const taskDate = new Date(task.dueDate);
                     if (!task.completed && isOverdue(taskDate)) return true;
                    return isToday(taskDate);
                });
            case 'upcoming':
                return state.tasks.filter(task => task.dueDate && isFuture(new Date(task.dueDate)));
            case 'inbox':
                return state.tasks.filter(task => task.listId === 'inbox');
            default:
                return state.tasks.filter(task => task.listId === state.activeListId);
        }
    }, [state.tasks, state.activeListId, state.activeTag]);

    const sortTasks = (tasks: Task[], sortOrder: SortOrder): Task[] => {
        if (sortOrder === 'default') {
            return [...tasks].sort((a, b) => {
                const aIsRecurringInstance = a.id.includes('_');
                const bIsRecurringInstance = b.id.includes('_');
                const originalAId = aIsRecurringInstance ? a.id.split('_')[0] : a.id;
                const originalBId = bIsRecurringInstance ? b.id.split('_')[0] : b.id;

                const aIndex = state.tasks.findIndex(t => t.id === originalAId);
                const bIndex = state.tasks.findIndex(t => t.id === originalBId);
                return aIndex - bIndex;
            });
        }

        return [...tasks].sort((a, b) => {
            const aHasDate = !!a.dueDate;
            const bHasDate = !!b.dueDate;

            if (aHasDate && !bHasDate) return -1;
            if (!aHasDate && bHasDate) return 1;
            if (!aHasDate && !bHasDate) return 0;

            const dateA = new Date(a.dueDate!).getTime();
            const dateB = new Date(b.dueDate!).getTime();

            return sortOrder === 'dueDateAsc' ? dateA - dateB : dateB - dateA;
        });
    };
    
    const uncompletedTasks = sortTasks(filteredTasks.filter(task => !task.completed), state.sortOrder);
    const completedTasks = sortTasks(filteredTasks.filter(task => task.completed), state.sortOrder);
    
    const groupedUpcomingTasks = useMemo(() => {
        if (state.activeListId !== 'upcoming') return null;
        return groupUpcomingTasks(uncompletedTasks, t);
    }, [state.activeListId, uncompletedTasks, t]);

    const upcomingGroupOrder = useMemo(() => {
        if (!groupedUpcomingTasks) return [];
        return Object.keys(groupedUpcomingTasks).sort((a, b) => {
            const earliestA = Math.min(...groupedUpcomingTasks[a].map(t => new Date(t.dueDate!).getTime()));
            const earliestB = Math.min(...groupedUpcomingTasks[b].map(t => new Date(t.dueDate!).getTime()));
            return earliestA - earliestB;
        });
    }, [groupedUpcomingTasks]);


    const handleDragStart = (taskId: string) => {
        setDraggedTaskId(taskId);
    };

    const handleDrop = (droppedOnId: string) => {
        if (draggedTaskId && draggedTaskId !== droppedOnId) {
            dispatch({ type: 'REORDER_TASKS', payload: { draggedId: draggedTaskId, droppedOnId } });
        }
        setDraggedTaskId(null);
    };

    if (filteredTasks.length === 0) {
        return (
            <div className="flex flex-col items-center justify-center h-full text-center text-muted-foreground">
                {EMPTY_STATE_ILLUSTRATIONS.noTasks}
                <h2 className="text-xl font-semibold">{t('taskList.allDone')}</h2>
                <p>{t('taskList.noTasks')}</p>
            </div>
        );
    }
    
    const renderTaskItems = (tasks: Task[]) => (
        tasks.map(task => (
            <TaskItem 
                key={task.id} 
                task={task}
                isDraggable={state.sortOrder === 'default' && state.activeListId !== 'upcoming'}
                onDragStart={handleDragStart}
                onDrop={handleDrop}
            />
        ))
    );

    return (
        <div className="space-y-4">
            <div
                onDragOver={(e) => e.preventDefault()}
            >
                {groupedUpcomingTasks ? (
                    upcomingGroupOrder.map(groupName => (
                        groupedUpcomingTasks[groupName] && (
                            <div key={groupName} className="mb-6">
                                <h3 className="text-md font-semibold mb-2 text-primary">{groupName}</h3>
                                <div className="space-y-2">
                                    {renderTaskItems(groupedUpcomingTasks[groupName])}
                                </div>
                            </div>
                        )
                    ))
                ) : (
                    <div className="space-y-2">
                        {renderTaskItems(uncompletedTasks)}
                    </div>
                )}
                 <button 
                    onClick={onAddTask}
                    className="w-full flex items-center gap-2 p-3 mt-4 rounded-lg text-primary hover:bg-primary/10 transition-colors"
                >
                    <PlusIcon className="h-5 w-5" />
                    <span className="text-sm font-semibold">{t('taskList.addTask')}</span>
                </button>
            </div>
            {completedTasks.length > 0 && (
                <div>
                    <button 
                        onClick={() => setIsCompletedOpen(!isCompletedOpen)}
                        className="w-full flex items-center justify-between text-sm font-semibold text-muted-foreground mb-2 py-1"
                    >
                        <span>{t('taskList.completed')} ({completedTasks.length})</span>
                        {isCompletedOpen ? <ArrowUpIcon className="h-4 w-4" /> : <ArrowDownIcon className="h-4 w-4" />}
                    </button>
                    {isCompletedOpen && (
                        <div className="space-y-2 animate-accordion-down overflow-hidden">
                            {completedTasks.map(task => (
                                <TaskItem key={task.id} task={task} isDraggable={false} />
                            ))}
                        </div>
                    )}
                </div>
            )}
        </div>
    );
};

export default TaskList;

================================================================================

--- FILE: components/ui/Avatar.tsx ---

import React from 'react';
import { User } from '../../types';

interface AvatarProps {
    user: User | null;
    className?: string;
}

const getInitials = (name: string): string => {
    const names = name.split(' ');
    if (names.length > 1) {
        return `${names[0][0]}${names[names.length - 1][0]}`.toUpperCase();
    }
    return name.substring(0, 2).toUpperCase();
};

const Avatar: React.FC<AvatarProps> = ({ user, className }) => {
    if (!user) {
        return (
            <div className={`flex items-center justify-center w-10 h-10 rounded-full bg-secondary text-muted-foreground ${className}`}>
                ?
            </div>
        );
    }

    if (user.avatarUrl) {
        return (
            <img
                src={user.avatarUrl}
                alt={user.name}
                className={`w-10 h-10 rounded-full object-cover ${className}`}
            />
        );
    }

    return (
        <div className={`flex items-center justify-center w-10 h-10 rounded-full bg-primary/20 text-primary font-bold ${className}`}>
            {getInitials(user.name)}
        </div>
    );
};

export default Avatar;


================================================================================

--- FILE: components/ui/ConfirmationModal.tsx ---

import React from 'react';
import { useConfirmation, ConfirmationOptions } from '../../hooks/useConfirmation';
import { CloseIcon, TrashIcon } from '../../constants';
import { useTranslation } from '../../hooks/useI18n';

const ConfirmationModal: React.FC = () => {
    const { options, proceed, cancel } = useConfirmation();
    const { t } = useTranslation();

    if (!options) {
        return null;
    }

    const {
        title,
        message,
        confirmText = t('taskForm.createTask'), // A generic confirm, might need adjustment
        cancelText = t('board.column.cancel'),
        isDestructive = true,
    } = options;

    return (
        <div 
            className="fixed inset-0 bg-black/60 z-50 flex items-center justify-center p-4 animate-fade-in"
            onClick={cancel}
            aria-modal="true"
            role="dialog"
        >
            <div 
                className="bg-card rounded-lg shadow-xl w-full max-w-md"
                onClick={e => e.stopPropagation()}
            >
                <header className="p-4 border-b border-border flex items-center justify-between">
                    <h2 className="text-lg font-semibold">{title}</h2>
                    <button onClick={cancel} className="p-1 rounded-full hover:bg-secondary">
                        <CloseIcon className="h-5 w-5 text-muted-foreground" />
                    </button>
                </header>
                
                <div className="p-6">
                    <p className="text-sm text-muted-foreground">{message}</p>
                </div>

                <footer className="p-4 bg-secondary/50 rounded-b-lg flex justify-end gap-4">
                    <button 
                        onClick={cancel} 
                        className="px-4 py-2 bg-background border border-border rounded-md text-sm font-semibold hover:bg-muted"
                    >
                        {cancelText}
                    </button>
                    <button 
                        onClick={proceed} 
                        className={`px-4 py-2 rounded-md text-sm font-semibold ${
                            isDestructive 
                                ? 'bg-destructive text-destructive-foreground hover:bg-destructive/90' 
                                : 'bg-primary text-primary-foreground hover:bg-primary/90'
                        }`}
                    >
                        {confirmText}
                    </button>
                </footer>
            </div>
        </div>
    );
};

export default ConfirmationModal;

================================================================================

--- FILE: components/ui/DatePicker.tsx ---

import React, { useState, useRef, useEffect } from 'react';
import { CalendarDayIcon, ChevronLeftIcon, ChevronRightIcon, CloseIcon } from '../../constants';
import { useTranslation } from '../../hooks/useI18n';
import { useSettings } from '../../hooks/useSettings';

interface DatePickerProps {
    value?: string; // ISO string
    onChange: (date: Date | null) => void;
}

// Helper functions to replace date-fns
const addMonths = (date: Date, amount: number): Date => {
    const newDate = new Date(date);
    const d = newDate.getDate();
    newDate.setMonth(newDate.getMonth() + amount);
    // If the new month has fewer days, the month could change.
    // This check corrects for it.
    if (newDate.getDate() !== d) {
        newDate.setDate(0);
    }
    return newDate;
};

const addDays = (date: Date, amount: number): Date => {
    const newDate = new Date(date);
    newDate.setDate(newDate.getDate() + amount);
    return newDate;
};

const isSameMonth = (date1: Date, date2: Date): boolean => {
    return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth();
};

const isSameDay = (date1: Date, date2: Date): boolean => {
    return date1.getFullYear() === date2.getFullYear() &&
           date1.getMonth() === date2.getMonth() &&
           date1.getDate() === date2.getDate();
};

const isToday = (date: Date): boolean => {
    const today = new Date();
    return isSameDay(date, today);
};

const DatePicker: React.FC<DatePickerProps> = ({ value, onChange }) => {
    const [isOpen, setIsOpen] = useState(false);
    const { t } = useTranslation();
    const { language } = useSettings();
    const selectedDate = value ? new Date(value) : null;
    const [currentMonth, setCurrentMonth] = useState(selectedDate || new Date());
    const containerRef = useRef<HTMLDivElement>(null);

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (containerRef.current && !containerRef.current.contains(event.target as Node)) {
                setIsOpen(false);
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, []);
    
    useEffect(() => {
        // If the value prop changes, update the calendar's month
        if (selectedDate) {
            setCurrentMonth(new Date(selectedDate));
        }
    }, [value]);

    const handleDateSelect = (day: Date) => {
        onChange(day);
        setIsOpen(false);
    };
    
    const handleClearDate = (e: React.MouseEvent) => {
        e.stopPropagation();
        onChange(null);
        setIsOpen(false);
    }

    const renderHeader = () => (
        <div className="flex items-center justify-between py-2 px-3">
            <span className="text-sm font-semibold">{currentMonth.toLocaleDateString(language, { month: 'long', year: 'numeric' })}</span>
            <div className="flex items-center space-x-1">
                <button type="button" onClick={() => setCurrentMonth(addMonths(currentMonth, -1))} className="p-1 rounded-md hover:bg-secondary">
                    <ChevronLeftIcon className="h-4 w-4 text-muted-foreground" />
                </button>
                <button type="button" onClick={() => setCurrentMonth(addMonths(currentMonth, 1))} className="p-1 rounded-md hover:bg-secondary">
                    <ChevronRightIcon className="h-4 w-4 text-muted-foreground" />
                </button>
            </div>
        </div>
    );

    const renderDays = () => {
        const dayNames = Array.from({ length: 7 }, (_, i) => {
            // A known Sunday is Jan 7, 2024
            const day = new Date(2024, 0, 7 + i);
            return day.toLocaleDateString(language, { weekday: 'short' });
        });
        return (
            <div className="grid grid-cols-7 text-center text-xs text-muted-foreground">
                {dayNames.map(day => <div key={day} className="py-2">{day}</div>)}
            </div>
        );
    };

    const renderCells = () => {
        const monthStart = new Date(currentMonth.getFullYear(), currentMonth.getMonth(), 1);
        const monthEnd = new Date(currentMonth.getFullYear(), currentMonth.getMonth() + 1, 0);
        
        // Adjust start date to Sunday for the grid
        const startDate = new Date(monthStart);
        startDate.setDate(startDate.getDate() - startDate.getDay());
        
        // Adjust end date to Saturday for the grid
        const endDate = new Date(monthEnd);
        if (endDate.getDay() !== 6) {
             endDate.setDate(endDate.getDate() + (6 - endDate.getDay()));
        }

        const rows = [];
        let days = [];
        let day = new Date(startDate);

        while (day <= endDate) {
            for (let i = 0; i < 7; i++) {
                const cloneDay = new Date(day);
                const isSelected = selectedDate && isSameDay(day, selectedDate);
                const isCurrentMonth = isSameMonth(day, monthStart);
                const isCurrentDay = isToday(day);

                days.push(
                    <div className="p-1 flex justify-center" key={day.toString()}>
                        <button
                            type="button"
                            onClick={() => handleDateSelect(cloneDay)}
                            className={`
                                w-8 h-8 rounded-md text-sm transition-colors
                                ${!isCurrentMonth ? 'text-muted-foreground/50' : ''}
                                ${isCurrentDay && !isSelected ? 'ring-1 ring-primary' : ''}
                                ${isSelected ? 'bg-primary text-primary-foreground hover:bg-primary/90' : 'hover:bg-secondary'}
                            `}
                        >
                            {cloneDay.getDate()}
                        </button>
                    </div>
                );
                day = addDays(day, 1);
            }
            rows.push(
                <div className="grid grid-cols-7" key={day.toString()}>
                    {days}
                </div>
            );
            days = [];
        }
        return <div className="p-2">{rows}</div>;
    };


    return (
        <div className="relative mt-1" ref={containerRef}>
            <button
                type="button"
                onClick={() => setIsOpen(!isOpen)}
                className="w-full flex items-center justify-between p-2 bg-secondary/50 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50"
            >
                <span className={selectedDate ? 'text-foreground' : 'text-muted-foreground'}>
                    {selectedDate ? selectedDate.toLocaleDateString(language, { month: 'long', day: 'numeric', year: 'numeric' }) : t('datePicker.placeholder')}
                </span>
                 <div className="flex items-center">
                    {selectedDate && (
                         <button
                            type="button"
                            onClick={handleClearDate}
                            className="mr-2 p-1 rounded-full hover:bg-muted"
                            aria-label={t('datePicker.aria.clear')}
                        >
                            <CloseIcon className="h-3 w-3" />
                        </button>
                    )}
                    <CalendarDayIcon className="h-4 w-4 text-muted-foreground" />
                </div>
            </button>
            {isOpen && (
                <div className="absolute z-10 mt-2 w-full bg-popover text-popover-foreground rounded-md border border-border shadow-lg animate-fade-in">
                    {renderHeader()}
                    {renderDays()}
                    {renderCells()}
                     <div className="p-2 border-t border-border flex justify-end gap-2">
                        <button type="button" onClick={() => { handleDateSelect(new Date()); }} className="text-xs px-2 py-1 rounded-md hover:bg-secondary">{t('datePicker.today')}</button>
                    </div>
                </div>
            )}
        </div>
    );
};

export default DatePicker;

================================================================================

--- FILE: components/ui/LanguageSwitcher.tsx ---

import React from 'react';
import { useSettings } from '../../hooks/useSettings';
import { GlobeAltIcon } from '../../constants';

interface LanguageSwitcherProps {
    className?: string;
}

const LanguageSwitcher: React.FC<LanguageSwitcherProps> = ({ className }) => {
    const { language, setLanguage } = useSettings();

    return (
        <div className={`relative ${className}`}>
            <GlobeAltIcon className="h-5 w-5 text-muted-foreground absolute left-3 top-1/2 -translate-y-1/2 pointer-events-none" />
            <select
                value={language}
                onChange={(e) => setLanguage(e.target.value as 'en' | 'vi')}
                className="pl-10 pr-4 py-2 bg-secondary/50 rounded-md text-sm font-semibold focus:outline-none focus:ring-2 focus:ring-primary/50 appearance-none"
                aria-label="Select language"
            >
                <option value="en">EN</option>
                <option value="vi">VI</option>
            </select>
        </div>
    );
};

export default LanguageSwitcher;


================================================================================

--- FILE: components/ui/RecurrencePicker.tsx ---

import React from 'react';
import { Task, RecurrenceRule } from '../../types';
import { RepeatIcon } from '../../constants';
import { useTranslation } from '../../hooks/useI18n';

interface RecurrencePickerProps {
    recurrence: Task['recurrence'];
    onChange: (recurrence: Task['recurrence'] | undefined) => void;
}

const RecurrencePicker: React.FC<RecurrencePickerProps> = ({ recurrence, onChange }) => {
    const { t } = useTranslation();
    
    const handleRecurrenceChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
        const value = e.target.value;
        if (value === 'none') {
            onChange(undefined);
        } else {
            onChange({ rule: value as RecurrenceRule });
        }
    };

    return (
        <div>
            <label className="text-sm font-medium text-muted-foreground">{t('recurrence.title')}</label>
            <div className="relative mt-1">
                <RepeatIcon className="h-4 w-4 text-muted-foreground absolute left-3 top-1/2 -translate-y-1/2 pointer-events-none" />
                <select
                    value={recurrence?.rule || 'none'}
                    onChange={handleRecurrenceChange}
                    className="w-full pl-9 p-2 bg-secondary/50 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50 appearance-none"
                >
                    <option value="none">{t('recurrence.none')}</option>
                    <option value="daily">{t('recurrence.daily')}</option>
                    <option value="weekly">{t('recurrence.weekly')}</option>
                    <option value="monthly">{t('recurrence.monthly')}</option>
                </select>
            </div>
        </div>
    );
};

export default RecurrencePicker;

================================================================================

--- FILE: components/ui/ReminderSetter.tsx ---

import React from 'react';
import { BellIcon } from '../../constants';
import { useTranslation } from '../../hooks/useI18n';

interface ReminderSetterProps {
    reminder: number | undefined;
    onChange: (minutes: number | undefined) => void;
}

const ReminderSetter: React.FC<ReminderSetterProps> = ({ reminder, onChange }) => {
    const { t } = useTranslation();

    const REMINDER_OPTIONS = [
        { label: t('reminder.none'), value: 'none' },
        { label: t('reminder.5min'), value: '5' },
        { label: t('reminder.15min'), value: '15' },
        { label: t('reminder.30min'), value: '30' },
        { label: t('reminder.1hour'), value: '60' },
    ];

    const handleReminderChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
        const value = e.target.value;
        if (value === 'none') {
            onChange(undefined);
        } else {
            onChange(parseInt(value, 10));
        }
    };

    return (
        <div>
            <label className="text-sm font-medium text-muted-foreground">{t('reminder.title')}</label>
            <div className="relative mt-1">
                <BellIcon className="h-4 w-4 text-muted-foreground absolute left-3 top-1/2 -translate-y-1/2 pointer-events-none" />
                <select
                    value={reminder || 'none'}
                    onChange={handleReminderChange}
                    className="w-full pl-9 p-2 bg-secondary/50 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50 appearance-none"
                >
                    {REMINDER_OPTIONS.map(opt => (
                        <option key={opt.value} value={opt.value}>{opt.label}</option>
                    ))}
                </select>
            </div>
        </div>
    );
};

export default ReminderSetter;

================================================================================

--- FILE: components/ui/Spinner.tsx ---

import React from 'react';

const Spinner: React.FC<{ className?: string }> = ({ className }) => {
    return (
        <svg
            className={`animate-spin h-5 w-5 text-primary ${className}`}
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
        >
            <circle
                className="opacity-25"
                cx="12"
                cy="12"
                r="10"
                stroke="currentColor"
                strokeWidth="4"
            ></circle>
            <path
                className="opacity-75"
                fill="currentColor"
                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
            ></path>
        </svg>
    );
};

export default Spinner;


================================================================================

--- FILE: components/ui/Toast.tsx ---

import React from 'react';
import { useToastContainer } from '../../hooks/useToast';
import { CheckCircleIcon, CloseIcon } from '../../constants'; // Assuming you have these
import { useTranslation } from '../../hooks/useI18n';

const Toast: React.FC<{ message: string; type: string; onDismiss: () => void }> = ({ message, type, onDismiss }) => {
    const { t } = useTranslation();
    // Basic icon/color mapping
    const styleMap = {
        success: { icon: <CheckCircleIcon className="h-5 w-5 text-green-500" />, bg: 'bg-green-500' },
        error: { icon: <CloseIcon className="h-5 w-5 text-red-500" />, bg: 'bg-red-500' },
        info: { icon: <CheckCircleIcon className="h-5 w-5 text-blue-500" />, bg: 'bg-blue-500' },
    };

    return (
        <div
            className="bg-card shadow-lg rounded-lg pointer-events-auto ring-1 ring-black ring-opacity-5 overflow-hidden mb-4 animate-fade-in"
            role="alert"
        >
            <div className="p-4">
                <div className="flex items-start">
                    <div className="flex-shrink-0">
                        {styleMap[type as keyof typeof styleMap]?.icon || styleMap.info.icon}
                    </div>
                    <div className="ml-3 w-0 flex-1 pt-0.5">
                        <p className="text-sm font-medium text-foreground">{message}</p>
                    </div>
                    <div className="ml-4 flex-shrink-0 flex">
                        <button
                            onClick={onDismiss}
                            className="inline-flex rounded-md bg-card text-muted-foreground hover:text-foreground focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary"
                        >
                            <span className="sr-only">{t('toast.close')}</span>
                            <CloseIcon className="h-5 w-5" />
                        </button>
                    </div>
                </div>
            </div>
        </div>
    );
};


export const ToastContainer: React.FC = () => {
    const { toasts, removeToast } = useToastContainer();
    
    return (
        <div
            aria-live="assertive"
            className="fixed inset-0 flex items-start px-4 py-6 pt-20 sm:pt-6 pointer-events-none sm:p-6 z-50"
        >
            <div className="w-full flex flex-col items-center space-y-4 sm:items-end">
                {toasts.map(toast => (
                    <Toast
                        key={toast.id}
                        message={toast.message}
                        type={toast.type}
                        onDismiss={() => removeToast(toast.id)}
                    />
                ))}
            </div>
        </div>
    );
};

================================================================================

--- FILE: constants.tsx ---

import React from 'react';
import { Achievement, AppState, List, Priority, Task } from './types';

// Icons

export const MenuIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
    </svg>
);

export const HomeIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M2.25 12l8.954-8.955c.44-.439 1.152-.439 1.591 0L21.75 12M4.5 9.75v10.125c0 .621.504 1.125 1.125 1.125H9.75v-4.875c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125V21h4.125c.621 0 1.125-.504 1.125-1.125V9.75M8.25 21h7.5" />
    </svg>
);


export const PlusIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
    </svg>
);

export const InboxIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M2.25 13.5h3.86a2.25 2.25 0 012.012 1.244l.256.512a2.25 2.25 0 002.013 1.244h3.218a2.25 2.25 0 002.013-1.244l.256-.512a2.25 2.25 0 012.013-1.244h3.859m-19.5.338V18a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18v-4.162c0-.224-.034-.447-.1-.661L19.24 5.338a2.25 2.25 0 00-2.12-1.588H6.88a2.25 2.25 0 00-2.12 1.588L2.35 13.177a2.25 2.25 0 00-.1.661z" />
    </svg>
);

export const CalendarDayIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 012.25-2.25h13.5A2.25 2.25 0 0121 7.5v11.25m-18 0A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75m-18 0h18M12 15.75h.008v.008H12v-.008z" />
    </svg>
);

export const CalendarIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 012.25-2.25h13.5A2.25 2.25 0 0121 7.5v11.25m-18 0A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75m-18 0h18M12 12.75h.008v.008H12v-.008zm0 3h.008v.008H12v-.008zm-3-3h.008v.008H9v-.008zm0 3h.008v.008H9v-.008zm-3-3h.008v.008H6v-.008zm0 3h.008v.008H6v-.008zm6-3h.008v.008H12v-.008zm0 3h.008v.008H12v-.008zm3-3h.008v.008H15v-.008zm0 3h.008v.008H15v-.008z" />
    </svg>
);

export const ListBulletIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M8.25 6.75h12M8.25 12h12M8.25 17.25h12M3.75 6.75h.007v.008H3.75V6.75zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zM3.75 12h.007v.008H3.75V12zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm-.375 5.25h.007v.008H3.75v-.008zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0z" />
    </svg>
);

export const TagIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M9.568 3H5.25A2.25 2.25 0 003 5.25v4.318c0 .597.237 1.17.659 1.591l9.581 9.581c.699.699 1.78.872 2.607.33a18.095 18.095 0 005.223-5.223c.542-.827.369-1.908-.33-2.607L11.16 3.66A2.25 2.25 0 009.568 3z" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M6 6h.008v.008H6V6z" />
    </svg>
);

export const CloseIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
    </svg>
);

export const FlagIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M3 3v1.5M3 21v-6m0 0l2.77-.693a9 9 0 016.208.682l.108.054a9 9 0 006.086.71l3.114-.732a48.524 48.524 0 01-.005-10.499l-3.11.732a9 9 0 01-6.085-.711l-.108-.054a9 9 0 00-6.208-.682L3 4.5M3 15V4.5" />
    </svg>
);

export const SparklesIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09zM18.259 8.715L18 9.75l-.259-1.035a3.375 3.375 0 00-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 002.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 00-2.456 2.456zM16.898 20.572L16.5 21.75l-.398-1.178a3.375 3.375 0 00-2.456-2.456L12.5 17.25l1.178-.398a3.375 3.375 0 002.456-2.456L16.5 13.5l.398 1.178a3.375 3.375 0 002.456 2.456l1.178.398-1.178.398a3.375 3.375 0 00-2.456 2.456z" />
    </svg>
);

export const GlobeAltIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M12 21a9.004 9.004 0 008.716-6.747M12 21a9.004 9.004 0 01-8.716-6.747M12 21c.34 0 .672-.023.996-.067M12 21v-4.571M12 3a9.004 9.004 0 018.716 6.747M12 3a9.004 9.004 0 00-8.716 6.747M12 3c.34 0 .672-.023.996-.067M12 3v4.571m0 0a9.004 9.004 0 015.13 4.13M12 7.571a9.004 9.004 0 00-5.13 4.13m10.26 0a9.004 9.004 0 01-10.26 0m10.26 0c.34 0 .672-.023.996-.067" />
    </svg>
);

export const GripVerticalIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M7.5 9.75h.01M7.5 12h.01M7.5 14.25h.01M12 9.75h.01M12 12h.01M12 14.25h.01M16.5 9.75h.01M16.5 12h.01M16.5 14.25h.01" />
    </svg>
);

export const CheckCircleIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
    </svg>
);

export const CheckIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={3} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M4.5 12.75l6 6 9-13.5" />
    </svg>
);

export const PaperAirplaneIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M6 12L3.269 3.126A59.768 59.768 0 0121.485 12 59.77 59.77 0 013.27 20.876L5.999 12zm0 0h7.5" />
    </svg>
);

export const CubeTransparentIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M21 7.5l-9-5.25L3 7.5m18 0l-9 5.25m9-5.25v9l-9 5.25M3 7.5l9 5.25M3 7.5v9l9 5.25m0-9v9" />
    </svg>
);

export const UndoIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M9 15L3 9m0 0l6-6M3 9h12a6 6 0 010 12h-3" />
    </svg>
);

export const RedoIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M15 15l6-6m0 0l-6-6m6 6H9a6 6 0 000 12h3" />
    </svg>
);

export const TrashIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.134-2.036-2.134H8.716C7.58 2.75 6.67 3.704 6.67 4.884v.916m7.5 0a48.667 48.667 0 00-7.5 0" />
    </svg>
);

export const ArrowsUpDownIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M3 7.5L7.5 3m0 0L12 7.5M7.5 3v13.5m13.5 0L16.5 21m0 0L12 16.5m4.5 4.5V7.5" />
    </svg>
);

export const ArrowUpIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M4.5 15.75l7.5-7.5 7.5 7.5" />
    </svg>
);

export const ArrowDownIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
    </svg>
);

export const SearchIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z" />
    </svg>
);

export const ChatBubbleLeftRightIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M20.25 8.511c.884.284 1.5 1.128 1.5 2.097v4.286c0 1.136-.847 2.1-1.98 2.193l-3.722.537a59.731 59.731 0 01-4.908 0l-3.722-.537C3.347 17.1 2.5 16.136 2.5 15v-4.286c0-.97.616-1.813 1.5-2.097M16.5 7.5v3.75m0 0v3.75m0-3.75h.75m-1.5 0h.75m-1.5 0h.75m2.25-3.75h.75m-1.5 0h.75m-1.5 0h.75M6.5 7.5v3.75m0 0v3.75m0-3.75h.75m-1.5 0h.75m-1.5 0h.75M9 7.5h.75m-1.5 0h.75m-1.5 0h.75" />
    </svg>
);

export const PlayCircleIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M15.91 11.672a.375.375 0 010 .656l-5.603 3.113a.375.375 0 01-.557-.328V8.887c0-.286.307-.466.557-.327l5.603 3.112z" />
    </svg>
);

export const StopwatchIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" />
    </svg>
);

export const BellIcon: React.FC<{ className?: string, title?: string }> = ({ className, title }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        {title && <title>{title}</title>}
        <path strokeLinecap="round" strokeLinejoin="round" d="M14.857 17.082a23.848 23.848 0 005.454-1.31A8.967 8.967 0 0118 9.75v-.7V9A6 6 0 006 9v.75a8.967 8.967 0 01-2.312 6.022c1.733.64 3.56 1.085 5.455 1.31m5.714 0a24.255 24.255 0 01-5.714 0m5.714 0a3 3 0 11-5.714 0" />
    </svg>
);

export const RepeatIcon: React.FC<{ className?: string, title?: string }> = ({ className, title }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        {title && <title>{title}</title>}
        <path strokeLinecap="round" strokeLinejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0011.664 0l3.18-3.182m-3.182-4.991v4.99" />
    </svg>
);

export const CalendarDaysIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 012.25-2.25h13.5A2.25 2.25 0 0121 7.5v11.25m-18 0A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75m-18 0h18M12 12.75h.008v.008H12v-.008z" />
    </svg>
);

export const GridIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M3.75 6A2.25 2.25 0 016 3.75h2.25A2.25 2.25 0 0110.5 6v2.25a2.25 2.25 0 01-2.25 2.25H6A2.25 2.25 0 013.75 8.25V6zM3.75 15.75A2.25 2.25 0 016 13.5h2.25a2.25 2.25 0 012.25 2.25v2.25A2.25 2.25 0 018.25 21H6a2.25 2.25 0 01-2.25-2.25v-2.25zM13.5 6A2.25 2.25 0 0115.75 3.75h2.25A2.25 2.25 0 0120.25 6v2.25A2.25 2.25 0 0118 10.5h-2.25A2.25 2.25 0 0113.5 8.25V6zM13.5 15.75A2.25 2.25 0 0115.75 13.5h2.25a2.25 2.25 0 012.25 2.25v2.25a2.25 2.25 0 01-2.25 2.25h-2.25a2.25 2.25 0 01-2.25-2.25v-2.25z" />
    </svg>
);

export const HourglassIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M19.5 12c0-1.232-.046-2.453-.138-3.662a4.006 4.006 0 00-3.7-3.7 48.678 48.678 0 00-7.324 0 4.006 4.006 0 00-3.7 3.7c-.092 1.21-.138 2.43-.138 3.662a4.006 4.006 0 003.7 3.7 48.656 48.656 0 007.324 0 4.006 4.006 0 003.7-3.7z" />
    </svg>
);

export const ViewColumnsIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M9 4.5v15m6-15v15m-10.875 0h15.75c.621 0 1.125-.504 1.125-1.125V5.625c0-.621-.504-1.125-1.125-1.125H4.125C3.504 4.5 3 5.004 3 5.625v12.75c0 .621.504 1.125 1.125 1.125z" />
    </svg>
);

export const SettingsIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.26.716.53 1.003l.822.822c.272.272.67.366 1.036.218l1.282-.213c.542-.09.94.56.94 1.11v2.594c0 .55-.398 1.02-.94 1.11l-1.282.213c-.366.148-.664.564-.798.92l-.213 1.282c-.09.542-.56.94-1.11.94h-2.593c-.55 0-1.02-.398-1.11-.94l-.213-1.282c-.134-.356-.432-.772-.798-.92l-1.282-.213c-.542-.09-.94-.56-.94-1.11v-2.593c0 .55.398-1.02.94-1.11l1.282-.213c.366-.15.664-.565.798-.92l.213-1.281z" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
    </svg>
);
export const SunIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-4.773-4.227l-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z" />
    </svg>
);

export const MoonIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z" />
    </svg>
);

export const ChevronLeftIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
    </svg>
);

export const ChevronRightIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
    </svg>
);

export const UserCircleIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M17.982 18.725A7.488 7.488 0 0012 15.75a7.488 7.488 0 00-5.982 2.975m11.963 0a9 9 0 10-11.963 0m11.963 0A8.966 8.966 0 0112 21a8.966 8.966 0 01-5.982-2.275M15 9.75a3 3 0 11-6 0 3 3 0 016 0z" />
    </svg>
);

export const UserPlusIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M19 7.5v3m0 0v3m0-3h3m-3 0h-3m-2.25-4.125a3.375 3.375 0 11-6.75 0 3.375 3.375 0 016.75 0zM4 19.235v-.11a6.375 6.375 0 0112.75 0v.109A12.318 12.318 0 0110.374 21c-2.331 0-4.512-.645-6.374-1.766z" />
    </svg>
);

export const ChatBubbleOvalLeftEllipsisIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M8.625 12a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H8.25m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H12m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0h-.375M21 12c0 4.556-4.03 8.25-9 8.25a9.76 9.76 0 01-2.555-.337A5.972 5.972 0 015.41 20.97a5.969 5.969 0 01-.474-.065 4.48 4.48 0 00.978-2.025c.09-.455.09-.934.09-1.425v-2.287a6.75 6.75 0 016.75-6.75h2.25l.228.008c.077.012.152.025.226.042A6.75 6.75 0 0121 12z" />
    </svg>
);


export const ArrowLeftOnRectangleIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M15.75 9V5.25A2.25 2.25 0 0013.5 3h-6a2.25 2.25 0 00-2.25 2.25v13.5A2.25 2.25 0 007.5 21h6a2.25 2.25 0 002.25-2.25V15m3 0l3-3m0 0l-3-3m3 3H9" />
    </svg>
);

export const ArchiveBoxIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M20.25 7.5l-.625 10.632a2.25 2.25 0 01-2.247 2.118H6.622a2.25 2.25 0 01-2.247-2.118L3.75 7.5M10 11.25h4M3.375 7.5h17.25c.621 0 1.125-.504 1.125-1.125v-1.5c0-.621-.504-1.125-1.125-1.125H3.375c-.621 0-1.125.504-1.125 1.125v1.5c0 .621.504 1.125 1.125 1.125z" />
    </svg>
);

export const TrophyIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M16.5 18.75h-9a9.75 9.75 0 011.095-4.439c.43-1.033.86-2.066 1.29-3.099.43-.98.86-1.96 1.29-2.94a.75.75 0 011.33 0c.43.98.86 1.96 1.29 2.94.43 1.033.86 2.066 1.29 3.099A9.75 9.75 0 0116.5 18.75z" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M6.75 12.75h10.5M9 21h6m-6 0v-2.25m6 2.25v-2.25" />
    </svg>
);

export const HeroIllustration: React.FC<{ className?: string }> = ({ className }) => (
    <svg viewBox="0 0 512 341" fill="none" xmlns="http://www.w3.org/2000/svg" className={className}>
        <rect x="26" y="24" width="288" height="200" rx="12" fill="hsl(var(--card))" stroke="hsl(var(--border))" strokeWidth="2"/>
        <rect x="34" y="54" width="272" height="12" rx="6" fill="hsl(var(--secondary))"/>
        <rect x="34" y="74" width="180" height="12" rx="6" fill="hsl(var(--secondary))"/>
        <rect x="34" y="104" width="36" height="36" rx="8" fill="hsl(var(--secondary))"/>
        <rect x="82" y="110" width="120" height="12" rx="6" fill="hsl(var(--primary))" fillOpacity="0.1"/>
        <rect x="82" y="128" width="60" height="8" rx="4" fill="hsl(var(--muted))"/>
        <rect x="34" y="152" width="36" height="36" rx="8" fill="hsl(var(--secondary))"/>
        <rect x="82" y="158" width="150" height="12" rx="6" fill="hsl(var(--secondary))"/>
        <rect x="82" y="176" width="80" height="8" rx="4" fill="hsl(var(--muted))"/>
        <path d="M260 118L284 118" stroke="hsl(var(--primary))" strokeWidth="10" strokeLinecap="round"/>
        <path d="M260 166L284 166" stroke="hsl(var(--border))" strokeWidth="10" strokeLinecap="round"/>
        <g filter="url(#filter0_d_10_2)">
            <rect x="180" y="80" width="288" height="200" rx="12" fill="hsl(var(--card))" stroke="hsl(var(--border))" strokeWidth="2"/>
        </g>
        <circle cx="214" cy="114" r="14" fill="hsl(var(--primary))" fillOpacity="0.1"/>
        <path d="M214 106L214 114L220 114" stroke="hsl(var(--primary))" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
        <rect x="240" y="108" width="188" height="12" rx="6" fill="hsl(var(--secondary))"/>
        <rect x="196" y="150" width="272" height="12" rx="6" fill="hsl(var(--muted))"/>
        <rect x="196" y="170" width="180" height="12" rx="6" fill="hsl(var(--muted))"/>
        <rect x="196" y="190" width="220" height="12" rx="6" fill="hsl(var(--muted))"/>
        <rect x="350" y="210" width="100" height="40" rx="20" fill="hsl(var(--primary))"/>
        <path d="M386 225L400 230L386 235" stroke="hsl(var(--primary-foreground))" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
        <defs>
            <filter id="filter0_d_10_2" x="160" y="62" width="328" height="240" filterUnits="userSpaceOnUse" colorInterpolationFilters="sRGB">
                <feFlood floodOpacity="0" result="BackgroundImageFix"/>
                <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
                <feOffset dy="2"/>
                <feGaussianBlur stdDeviation="10"/>
                <feComposite in2="hardAlpha" operator="out"/>
                <feColorMatrix type="matrix" values="0 0 0 0 0.0627451 0 0 0 0 0.0941176 0 0 0 0 0.156863 0 0 0 0.05 0"/>
                <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_10_2"/>
                <feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow_10_2" result="shape"/>
            </filter>
        </defs>
    </svg>
);

export const GoogleIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" className={className}>
        <path fill="#FFC107" d="M43.611,20.083H42V20H24v8h11.303c-1.649,4.657-6.08,8-11.303,8c-6.627,0-12-5.373-12-12c0-6.627,5.373-12,12-12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C12.955,4,4,12.955,4,24c0,11.045,8.955,20,20,20c11.045,0,20-8.955,20-20C44,22.659,43.862,21.35,43.611,20.083z"></path>
        <path fill="#FF3D00" d="M6.306,14.691l6.571,4.819C14.655,15.108,18.961,12,24,12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C16.318,4,9.656,8.337,6.306,14.691z"></path>
        <path fill="#4CAF50" d="M24,44c5.166,0,9.86-1.977,13.409-5.192l-6.19-5.238C29.211,35.091,26.715,36,24,36c-5.223,0-9.657-3.657-11.303-8H24v-8H42v8H43.611c.25-1.26.389-2.58.389-3.917c0-11.045-8.955-20-20-20C12.955,4,4,12.955,4,24C4,35.045,12.955,44,24,44z"></path>
        <path fill="#1976D2" d="M43.611,20.083H42V20H24v8h11.303c-0.792,2.237-2.231,4.166-4.087,5.574l6.19,5.238C39.601,36.456,44,30.825,44,24C44,22.659,43.862,21.35,43.611,20.083z"></path>
    </svg>
);

export const GitHubIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 98 96" className={className}>
        <path fillRule="evenodd" clipRule="evenodd" d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-2.915.324-2.915 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.438-3.148 1.702-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.48-.98-2.184-6.37.584-13.003 0 0 4.125-1.304 13.427 5.052a46.97 46.97 0 0112.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.804 6.633 1.064 12.023.584 13.003 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.48 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z" fill="currentColor"></path>
    </svg>
);

export const AuthIllustration: React.FC<{ className?: string }> = ({ className }) => (
    <svg viewBox="0 0 512 512" fill="none" xmlns="http://www.w3.org/2000/svg" className={className}>
        <path d="M256 512C397.385 512 512 397.385 512 256C512 114.615 397.385 0 256 0C114.615 0 0 114.615 0 256C0 397.385 114.615 512 256 512Z" fill="hsl(var(--primary))" fillOpacity="0.1"/>
        <path d="M401 448C358.5 487 295.5 512 256 512C150.5 512 64 425.5 64 320C64 214.5 150.5 128 256 128C361.5 128 448 214.5 448 320C448 368 429 411.5 401 448Z" fill="hsl(var(--primary))" fillOpacity="0.1"/>
        <path d="M256 128C150.5 128 64 214.5 64 320C64 282 78 247 103 220.5C128 194 163.5 177.5 202.5 171C241.5 164.5 282 169 316 184C350 199 375 223.5 387.5 254.5C396.333 275.5 401.1 297.8 401 320C401 214.7 338.3 128 256 128Z" fill="hsl(var(--primary))" fillOpacity="0.1"/>
    </svg>
);


// Data Constants
export const PRIORITY_MAP: { [key in Priority]: { label: string; icon: React.FC<{ className?: string }>; color: string, checkboxBorderColor: string } } = {
    [Priority.None]: { label: 'priority.none', icon: FlagIcon, color: 'text-muted-foreground', checkboxBorderColor: 'border-muted-foreground/50' },
    [Priority.Low]: { label: 'priority.low', icon: FlagIcon, color: 'text-blue-500', checkboxBorderColor: 'border-blue-500' },
    [Priority.Medium]: { label: 'priority.medium', icon: FlagIcon, color: 'text-yellow-500', checkboxBorderColor: 'border-yellow-500' },
    [Priority.High]: { label: 'priority.high', icon: FlagIcon, color: 'text-red-500', checkboxBorderColor: 'border-red-500' },
};

export const SPECIAL_LISTS_CONFIG = {
    inbox: { id: 'inbox', name: 'specialLists.inbox', icon: <InboxIcon className="h-5 w-5" /> },
    today: { id: 'today', name: 'specialLists.today', icon: <CalendarDayIcon className="h-5 w-5" /> },
    upcoming: { id: 'upcoming', name: 'specialLists.upcoming', icon: <CalendarIcon className="h-5 w-5" /> },
};

export const TAG_COLORS = [
    'bg-red-500', 'bg-yellow-500', 'bg-green-500', 'bg-blue-500',
    'bg-indigo-500', 'bg-purple-500', 'bg-pink-500', 'bg-orange-500'
];

export const INITIAL_TASKS: Task[] = [];
export const INITIAL_LISTS: List[] = [];

export const POMODORO_SETTINGS = {
    pomoDuration: 25 * 60, // 25 minutes
    shortBreakDuration: 5 * 60, // 5 minutes
    longBreakDuration: 15 * 60, // 15 minutes
    longBreakInterval: 4, // 4 pomodoros
};

const EmptyStateIllustration: React.FC<{ className?: string }> = ({ className }) => (
    <svg className={className} viewBox="0 0 150 100" xmlns="http://www.w3.org/2000/svg">
      <path d="M 10 90 C 20 80, 40 80, 50 90 L 90 90 C 100 80, 120 80, 130 90" stroke="hsl(var(--muted-foreground))" strokeWidth="2" fill="transparent" strokeDasharray="5 5" />
      <path d="M 30 70 L 30 50 C 30 30, 70 30, 70 50 L 70 70" stroke="hsl(var(--muted-foreground))" strokeWidth="2" fill="transparent" />
      <circle cx="50" cy="20" r="5" fill="hsl(var(--primary))" opacity="0.5" />
      <path d="M 80 70 L 120 70" stroke="hsl(var(--muted-foreground))" strokeWidth="2" fill="transparent" />
      <path d="M 80 60 L 120 60" stroke="hsl(var(--muted-foreground))" strokeWidth="2" fill="transparent" />
    </svg>
);

export const EMPTY_STATE_ILLUSTRATIONS = {
    noTasks: <EmptyStateIllustration className="w-48 h-32 text-muted-foreground/50 mb-4" />
}

const toYYYYMMDD = (date: Date) => date.toISOString().split('T')[0];

const calculateStreak = (completions: string[]): number => {
    if (completions.length === 0) return 0;
    const sortedDates = completions.map(d => new Date(d)).sort((a, b) => b.getTime() - a.getTime());
    let streak = 0;
    const today = new Date();
    const latestCompletion = sortedDates[0];
    const todayStr = toYYYYMMDD(today);
    const yesterday = new Date(); yesterday.setDate(today.getDate() - 1);
    const yesterdayStr = toYYYYMMDD(yesterday);
    const latestCompletionStr = toYYYYMMDD(latestCompletion);

    if (latestCompletionStr === todayStr || latestCompletionStr === yesterdayStr) {
        streak = 1;
        let currentStreakDate = latestCompletion;
        for (let i = 1; i < sortedDates.length; i++) {
            const nextExpectedDate = new Date(currentStreakDate);
            nextExpectedDate.setDate(nextExpectedDate.getDate() - 1);
            if (toYYYYMMDD(sortedDates[i]) === toYYYYMMDD(nextExpectedDate)) {
                streak++;
                currentStreakDate = sortedDates[i];
            } else if (toYYYYMMDD(sortedDates[i]) !== toYYYYMMDD(currentStreakDate)) {
                break;
            }
        }
    }
    return streak;
};

export const ALL_ACHIEVEMENTS: Achievement[] = [
    { id: 'first_step', title: 'achievements.first_step.title', description: 'achievements.first_step.description', icon: CheckCircleIcon, condition: (state) => state.tasks.some(t => t.completed) },
    { id: 'task_novice', title: 'achievements.task_novice.title', description: 'achievements.task_novice.description', icon: CheckCircleIcon, condition: (state) => state.tasks.filter(t => t.completed).length >= 10 },
    { id: 'task_master', title: 'achievements.task_master.title', description: 'achievements.task_master.description', icon: CheckCircleIcon, condition: (state) => state.tasks.filter(t => t.completed).length >= 100 },
    { id: 'focus_starter', title: 'achievements.focus_starter.title', description: 'achievements.focus_starter.description', icon: StopwatchIcon, condition: (state) => state.pomodoro.focusHistory.length >= 1 },
    { id: 'focus_pro', title: 'achievements.focus_pro.title', description: 'achievements.focus_pro.description', icon: StopwatchIcon, condition: (state) => state.pomodoro.focusHistory.length >= 25 },
    { id: 'habit_builder', title: 'achievements.habit_builder.title', description: 'achievements.habit_builder.description', icon: RepeatIcon, condition: (state) => state.habits.some(h => calculateStreak(h.completions) >= 7) },
    { id: 'habit_hero', title: 'achievements.habit_hero.title', description: 'achievements.habit_hero.description', icon: RepeatIcon, condition: (state) => state.habits.some(h => calculateStreak(h.completions) >= 30) },
    { id: 'ai_assistant', title: 'achievements.ai_assistant.title', description: 'achievements.ai_assistant.description', icon: SparklesIcon, condition: (state) => state.tasks.some(t => t.subtasks.some(st => st.id.startsWith('gen-'))) },
    { id: 'planner', title: 'achievements.planner.title', description: 'achievements.planner.description', icon: CalendarIcon, condition: (state) => state.tasks.filter(t => t.dueDate).length >= 10 },
    { id: 'delegator', title: 'achievements.delegator.title', description: 'achievements.delegator.description', icon: UserPlusIcon, condition: (state) => state.tasks.filter(t => t.assigneeId).length >= 5 },
];

================================================================================

--- FILE: hooks/useConfirmation.tsx ---

import React, { createContext, useContext, useState, useCallback, ReactNode, useMemo, useRef } from 'react';

export interface ConfirmationOptions {
    title: string;
    message: string;
    confirmText?: string;
    cancelText?: string;
    isDestructive?: boolean;
}

interface ConfirmationContextType {
    confirm: (options: ConfirmationOptions) => Promise<boolean>;
    options: ConfirmationOptions | null;
    proceed: () => void;
    cancel: () => void;
}

const ConfirmationContext = createContext<ConfirmationContextType | undefined>(undefined);

export const ConfirmationProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
    const [options, setOptions] = useState<ConfirmationOptions | null>(null);
    const resolvePromiseRef = useRef<((value: boolean) => void) | null>(null);

    const confirm = useCallback((options: ConfirmationOptions): Promise<boolean> => {
        return new Promise((resolve) => {
            setOptions(options);
            resolvePromiseRef.current = resolve;
        });
    }, []);

    const handleConfirm = useCallback((value: boolean) => {
        if (resolvePromiseRef.current) {
            resolvePromiseRef.current(value);
        }
        setOptions(null);
        resolvePromiseRef.current = null;
    }, []);

    const cancel = useCallback(() => {
        handleConfirm(false);
    }, [handleConfirm]);

    const proceed = useCallback(() => {
        handleConfirm(true);
    }, [handleConfirm]);

    const value = useMemo(() => ({
        confirm,
        options,
        proceed,
        cancel
    }), [confirm, options, proceed, cancel]);

    return (
        <ConfirmationContext.Provider value={value}>
            {children}
        </ConfirmationContext.Provider>
    );
};

export const useConfirmation = () => {
    const context = useContext(ConfirmationContext);
    if (context === undefined) {
        throw new Error('useConfirmation must be used within a ConfirmationProvider');
    }
    return context;
};

================================================================================

--- FILE: hooks/useGemini.tsx ---

import React, { createContext, useContext, useState, useEffect, ReactNode, useMemo } from 'react';
import { GoogleGenAI } from '@google/genai';

interface GeminiContextType {
    ai: GoogleGenAI | null;
    isAvailable: boolean;
}

const GeminiContext = createContext<GeminiContextType | undefined>(undefined);

export const GeminiProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
    const [ai, setAi] = useState<GoogleGenAI | null>(null);
    const isAvailable = useMemo(() => !!ai, [ai]);

    useEffect(() => {
        const apiKey = process.env.API_KEY;
        if (apiKey) {
            try {
                const genAI = new GoogleGenAI({ apiKey });
                setAi(genAI);
            } catch (error) {
                console.error("Failed to initialize GoogleGenAI:", error);
                setAi(null);
            }
        } else {
            console.warn("API_KEY environment variable not found. Gemini features will be disabled.");
            setAi(null);
        }
    }, []);
    
    const contextValue = {
        ai,
        isAvailable,
    };

    return (
        <GeminiContext.Provider value={contextValue}>
            {children}
        </GeminiContext.Provider>
    );
};

export const useGemini = (): GeminiContextType => {
    const context = useContext(GeminiContext);
    if (context === undefined) {
        throw new Error('useGemini must be used within a GeminiProvider');
    }
    return context;
};

================================================================================

--- FILE: hooks/useI18n.tsx ---

import React, { createContext, useContext, ReactNode, useState, useEffect } from 'react';
import { useSettings } from './useSettings';

interface Translations {
    [key: string]: string;
}

interface AllTranslations {
    en: Translations;
    vi: Translations;
}

interface I18nContextType {
    t: (key: string, options?: { [key: string]: string | number }) => string;
}

const I18nContext = createContext<I18nContextType | undefined>(undefined);

export const I18nProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
    const { language } = useSettings();
    const [translations, setTranslations] = useState<AllTranslations>({ en: {}, vi: {} });

    useEffect(() => {
        const loadTranslations = async () => {
            try {
                const [enResponse, viResponse] = await Promise.all([
                    fetch('/locales/en.json'),
                    fetch('/locales/vi.json'),
                ]);
                const en = await enResponse.json();
                const vi = await viResponse.json();
                setTranslations({ en, vi });
            } catch (error) {
                console.error("Failed to load translation files:", error);
            }
        };
        loadTranslations();
    }, []);

    const t = (key: string, options?: { [key: string]: string | number }): string => {
        const langDict = translations[language] || translations.en;
        let translation = langDict[key] || key;
        
        if (options) {
            Object.keys(options).forEach(optKey => {
                const regex = new RegExp(`\\{\\{${optKey}\\}\\}`, 'g');
                translation = translation.replace(regex, String(options[optKey]));
            });
        }
        
        return translation;
    };
    
    return (
        <I18nContext.Provider value={{ t }}>
            {children}
        </I18nContext.Provider>
    );
};

export const useTranslation = (): I18nContextType => {
    const context = useContext(I18nContext);
    if (context === undefined) {
        throw new Error('useTranslation must be used within an I18nProvider');
    }
    return context;
};

================================================================================

--- FILE: hooks/useSettings.tsx ---

import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { ViewType } from '../types';

type Theme = 'light' | 'dark';
type Language = 'en' | 'vi';

interface SettingsState {
    theme: Theme;
    language: Language;
    bottomNavActions: ViewType[];
    setTheme: (theme: Theme) => void;
    setLanguage: (language: Language) => void;
    setBottomNavActions: (actions: ViewType[]) => void;
}

const SettingsContext = createContext<SettingsState | undefined>(undefined);

const DEFAULT_BOTTOM_NAV: ViewType[] = ['dashboard', 'list', 'calendar', 'pomodoro'];

export const SettingsProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
    const [theme, setTheme] = useState<Theme>(() => {
        const storedTheme = localStorage.getItem('taskflowTheme') as Theme | null;
        if (storedTheme) return storedTheme;
        return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    });

    const [language, setLanguage] = useState<Language>(() => {
        const storedLanguage = localStorage.getItem('taskflowLanguage') as Language | null;
        return storedLanguage || 'en';
    });

    const [bottomNavActions, setBottomNavActions] = useState<ViewType[]>(() => {
        try {
            const stored = localStorage.getItem('taskflowBottomNav');
            return stored ? JSON.parse(stored) : DEFAULT_BOTTOM_NAV;
        } catch {
            return DEFAULT_BOTTOM_NAV;
        }
    });

    useEffect(() => {
        localStorage.setItem('taskflowTheme', theme);
        const body = window.document.body;
        body.classList.remove('light', 'dark');
        body.classList.add(theme);
    }, [theme]);

    useEffect(() => {
        localStorage.setItem('taskflowLanguage', language);
    }, [language]);

    useEffect(() => {
        localStorage.setItem('taskflowBottomNav', JSON.stringify(bottomNavActions));
    }, [bottomNavActions]);


    return (
        <SettingsContext.Provider value={{ theme, setTheme, language, setLanguage, bottomNavActions, setBottomNavActions }}>
            {children}
        </SettingsContext.Provider>
    );
};

export const useSettings = (): SettingsState => {
    const context = useContext(SettingsContext);
    if (context === undefined) {
        throw new Error('useSettings must be used within a SettingsProvider');
    }
    return context;
};

================================================================================

--- FILE: hooks/useTaskManager.tsx ---

import React, { createContext, useContext, useReducer, useEffect, ReactNode, useRef } from 'react';
import { AppState, Action, PomodoroState, List, Habit, CountdownEvent, PomodoroFocusRecord, Task, Priority, Comment, Column } from '../types';
import { ALL_ACHIEVEMENTS, INITIAL_LISTS, INITIAL_TASKS, POMODORO_SETTINGS, TAG_COLORS } from '../constants';
import { useToast } from './useToast';
import { useTranslation } from './useI18n';

const initialPomodoroState: PomodoroState = {
    isActive: false,
    isPaused: false,
    remainingTime: POMODORO_SETTINGS.pomoDuration,
    currentSession: 'pomo',
    currentCycle: 0,
    focusedTaskId: null,
    focusHistory: [],
    settings: POMODORO_SETTINGS,
};

const initialAppState: AppState = {
    tasks: [],
    lists: [],
    columns: [],
    tags: [],
    habits: [],
    countdownEvents: [],
    unlockedAchievements: [],
    activeListId: 'today',
    selectedTaskId: null,
    sortOrder: 'default',
    activeTag: null,
    pomodoro: initialPomodoroState,
    view: 'dashboard',
};

interface HistoryState {
    past: AppState[];
    present: AppState;
    future: AppState[];
}

const initialHistoryState: HistoryState = {
    past: [],
    present: initialAppState,
    future: [],
};

const UNDOABLE_ACTIONS = new Set([
    'ADD_TASK',
    'UPDATE_TASK',
    'DELETE_TASK',
    'TOGGLE_TASK_COMPLETION',
    'ADD_LIST',
    'DELETE_LIST',
    'REORDER_TASKS',
    'ADD_HABIT',
    'TOGGLE_HABIT_COMPLETION',
    'DELETE_HABIT',
    'ADD_COUNTDOWN',
    'DELETE_COUNTDOWN',
    'SET_TASK_RECURRENCE',
    'SET_TASK_REMINDER',
    'UPDATE_POMODORO_SETTINGS',
    'ADD_TAG',
    'DELETE_TAG',
    'ASSIGN_TASK',
    'ADD_COMMENT',
    'UPDATE_LIST_MEMBERS',
    'ADD_COLUMN',
    'UPDATE_COLUMN',
    'DELETE_COLUMN',
    'REORDER_COLUMNS',
    'MOVE_TASK_TO_COLUMN',
]);

const playNotificationSound = () => {
    const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
    if (!audioContext) return;

    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();

    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);

    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
    gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);

    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + 0.2);
};

const sendNotification = (title: string, body: string) => {
    if ('Notification' in window && Notification.permission === 'granted') {
        new Notification(title, { body, silent: false });
    } else if ('Notification' in window && Notification.permission === 'default') {
        Notification.requestPermission();
    }
};

const getNextDueDate = (task: Task): string | undefined => {
    if (!task.recurrence || !task.dueDate) return undefined;
    
    const currentDate = new Date(task.dueDate);
    switch (task.recurrence.rule) {
        case 'daily':
            currentDate.setDate(currentDate.getDate() + 1);
            break;
        case 'weekly':
            currentDate.setDate(currentDate.getDate() + 7);
            break;
        case 'monthly':
            currentDate.setMonth(currentDate.getMonth() + 1);
            break;
    }
    return currentDate.toISOString();
}

const appReducer = (state: AppState, action: Action): AppState => {
    switch (action.type) {
        case 'ADD_TASK': {
            const newTags = action.payload.tags.filter(tag => !state.tags.includes(tag));
            return { 
                ...state, 
                tasks: [...state.tasks, action.payload],
                tags: [...state.tags, ...newTags]
            };
        }
        case 'UPDATE_TASK': {
            const newTags = action.payload.tags.filter(tag => !state.tags.includes(tag));
            return { 
                ...state, 
                tasks: state.tasks.map(task => task.id === action.payload.id ? action.payload : task),
                tags: [...state.tags, ...newTags] 
            };
        }
        case 'DELETE_TASK':
            return { ...state, tasks: state.tasks.filter(task => task.id !== action.payload) };
        case 'TOGGLE_TASK_COMPLETION': {
            const { taskId } = action.payload;
            const newTasks = state.tasks.flatMap(task => {
                if (task.id === taskId) {
                    const isCompleting = !task.completed;
                    // If it is a recurring task being marked as complete
                    if (task.recurrence && isCompleting) {
                        const nextDueDate = getNextDueDate(task);
                        
                        // Create the next occurrence, keeping the same ID and recurrence rule
                        const nextOccurrence = { ...task, dueDate: nextDueDate, completed: false, completedAt: undefined };
                        
                        // Create a completed one-time instance for history
                        const completedInstance: Task = {
                            ...task,
                            id: `${task.id}_${new Date(task.dueDate!).toISOString()}`, // Unique ID for this instance
                            completed: true,
                            completedAt: new Date().toISOString(),
                            recurrence: undefined, // This instance doesn't recur
                        };
                        
                        // Return both the new occurrence and the completed instance
                        return [nextOccurrence, completedInstance];
                    }
                    // For non-recurring tasks or un-completing any task
                    return { ...task, completed: isCompleting, completedAt: isCompleting ? new Date().toISOString() : undefined };
                }
                return task;
            });
            return { ...state, tasks: newTasks };
        }
        case 'REORDER_TASKS': {
            const { draggedId, droppedOnId } = action.payload;
            if (draggedId === droppedOnId) return state;

            const tasks = [...state.tasks];
            const draggedIndex = tasks.findIndex(t => t.id === draggedId);
            const droppedOnIndex = tasks.findIndex(t => t.id === droppedOnId);

            if (draggedIndex === -1 || droppedOnIndex === -1) return state;

            const [draggedItem] = tasks.splice(draggedIndex, 1);
            tasks.splice(droppedOnIndex, 0, draggedItem);

            return { ...state, tasks };
        }
        case 'ADD_LIST': {
            const newList: List = {
                id: Date.now().toString(),
                name: action.payload.name,
                color: TAG_COLORS[state.lists.length % TAG_COLORS.length],
                members: ['user-001'], // Creator is always a member
            };
            // Automatically add default columns for the new list
            const newColumns: Column[] = [
                { id: `col-${newList.id}-1`, name: 'To Do', listId: newList.id },
                { id: `col-${newList.id}-2`, name: 'In Progress', listId: newList.id },
                { id: `col-${newList.id}-3`, name: 'Done', listId: newList.id },
            ];
            return { ...state, lists: [...state.lists, newList], columns: [...state.columns, ...newColumns] };
        }
        case 'DELETE_LIST': {
            const listIdToDelete = action.payload;
            const newLists = state.lists.filter(list => list.id !== listIdToDelete);
            const newTasks = state.tasks.filter(task => task.listId !== listIdToDelete);
            const newColumns = state.columns.filter(c => c.listId !== listIdToDelete);
            let newActiveListId = state.activeListId;
            if (state.activeListId === listIdToDelete) {
                newActiveListId = 'inbox'; // Default to inbox if active list is deleted
            }
            return { 
                ...state, 
                lists: newLists, 
                tasks: newTasks,
                columns: newColumns,
                activeListId: newActiveListId,
                view: newActiveListId !== state.activeListId ? 'list' : state.view,
            };
        }
        case 'ADD_TAG': {
            const newTagName = action.payload.name.trim().toLowerCase();
            if (newTagName && !state.tags.includes(newTagName)) {
                return { ...state, tags: [...state.tags, newTagName] };
            }
            return state;
        }
        case 'DELETE_TAG': {
            const tagToDelete = action.payload;
            return {
                ...state,
                tags: state.tags.filter(tag => tag !== tagToDelete),
                tasks: state.tasks.map(task => ({
                    ...task,
                    tags: task.tags.filter(tag => tag !== tagToDelete)
                })),
                activeTag: state.activeTag === tagToDelete ? null : state.activeTag,
            };
        }
        case 'ASSIGN_TASK': {
            return {
                ...state,
                tasks: state.tasks.map(task =>
                    task.id === action.payload.taskId
                        ? { ...task, assigneeId: action.payload.userId || undefined }
                        : task
                ),
            };
        }
        case 'ADD_COMMENT': {
            return {
                ...state,
                tasks: state.tasks.map(task =>
                    task.id === action.payload.taskId
                        ? { ...task, comments: [...(task.comments || []), action.payload.comment] }
                        : task
                ),
            };
        }
        case 'UPDATE_LIST_MEMBERS': {
            return {
                ...state,
                lists: state.lists.map(list =>
                    list.id === action.payload.listId
                        ? { ...list, members: action.payload.memberIds }
                        : list
                ),
            };
        }
        case 'ADD_COLUMN': {
            const newColumn: Column = {
                id: `col-${Date.now()}`,
                name: action.payload.name,
                listId: action.payload.listId,
            };
            return { ...state, columns: [...state.columns, newColumn] };
        }
        case 'UPDATE_COLUMN': {
            return {
                ...state,
                columns: state.columns.map(c => c.id === action.payload.columnId ? { ...c, name: action.payload.name } : c)
            }
        }
        case 'DELETE_COLUMN': {
            const { columnId, listId } = action.payload;
            const columnsForList = state.columns.filter(c => c.listId === listId);
            const firstColumnId = columnsForList.length > 1 ? columnsForList.find(c => c.id !== columnId)?.id : undefined;

            return {
                ...state,
                columns: state.columns.filter(c => c.id !== columnId),
                tasks: state.tasks.map(t => t.columnId === columnId ? { ...t, columnId: firstColumnId } : t)
            }
        }
        case 'REORDER_COLUMNS': {
            const { listId, draggedId, droppedOnId } = action.payload;
            if (draggedId === droppedOnId) return state;

            const otherColumns = state.columns.filter(c => c.listId !== listId);
            const listColumns = [...state.columns.filter(c => c.listId === listId)];

            const draggedIndex = listColumns.findIndex(c => c.id === draggedId);
            const droppedOnIndex = listColumns.findIndex(c => c.id === droppedOnId);

            if (draggedIndex === -1 || droppedOnIndex === -1) return state;
            
            const [draggedItem] = listColumns.splice(draggedIndex, 1);
            listColumns.splice(droppedOnIndex, 0, draggedItem);

            return { ...state, columns: [...otherColumns, ...listColumns] };
        }
        case 'MOVE_TASK_TO_COLUMN': {
            return {
                ...state,
                tasks: state.tasks.map(task =>
                    task.id === action.payload.taskId
                        ? { ...task, columnId: action.payload.newColumnId }
                        : task
                )
            };
        }
        case 'SET_ACTIVE_LIST':
            return { ...state, activeListId: action.payload, selectedTaskId: null, activeTag: null, view: 'list' };
        case 'SET_SELECTED_TASK':
            return { ...state, selectedTaskId: action.payload };
        case 'SET_SORT_ORDER':
            return { ...state, sortOrder: action.payload };
        case 'SET_ACTIVE_TAG':
            return { ...state, activeTag: action.payload, activeListId: 'inbox', selectedTaskId: null, view: 'list' };
        case 'SET_VIEW':
            return { ...state, view: action.payload, selectedTaskId: null };
        
        case 'SET_TASK_RECURRENCE':
            return {
                ...state,
                tasks: state.tasks.map(t => t.id === action.payload.taskId ? { ...t, recurrence: action.payload.recurrence } : t)
            };
        case 'SET_TASK_REMINDER':
             return {
                ...state,
                tasks: state.tasks.map(t => t.id === action.payload.taskId ? { ...t, reminderMinutes: action.payload.reminderMinutes } : t)
            };
        case 'UNLOCK_ACHIEVEMENT':
            if (state.unlockedAchievements.includes(action.payload)) {
                return state; // Already unlocked
            }
            return {
                ...state,
                unlockedAchievements: [...state.unlockedAchievements, action.payload]
            };


        // Pomodoro Actions
        case 'UPDATE_POMODORO_SETTINGS':
            return {
                ...state,
                pomodoro: {
                    ...state.pomodoro,
                    settings: {
                        ...state.pomodoro.settings,
                        ...action.payload
                    }
                }
            }
        case 'SET_FOCUSED_TASK':
            return { ...state, pomodoro: { ...state.pomodoro, focusedTaskId: action.payload } };
        case 'START_TIMER': {
            if (Notification.permission === 'default') {
                Notification.requestPermission();
            }
            return {
                ...state,
                pomodoro: {
                    ...state.pomodoro,
                    isActive: true,
                    isPaused: false,
                    remainingTime: state.pomodoro.remainingTime > 0 ? state.pomodoro.remainingTime : state.pomodoro.settings.pomoDuration,
                },
            };
        }
        case 'PAUSE_TIMER':
            return { ...state, pomodoro: { ...state.pomodoro, isPaused: true } };
        case 'STOP_TIMER':
            return { 
                ...state, 
                pomodoro: { 
                    ...initialPomodoroState, 
                    settings: state.pomodoro.settings, // Keep custom settings
                    focusedTaskId: state.pomodoro.focusedTaskId, 
                    focusHistory: state.pomodoro.focusHistory 
                } 
            };
        case 'TICK': {
            if (state.pomodoro.isPaused || !state.pomodoro.isActive) return state;

            const newState = {
                ...state,
                pomodoro: { ...state.pomodoro, remainingTime: state.pomodoro.remainingTime - 1 },
            };
        
            if (state.pomodoro.focusedTaskId && state.pomodoro.currentSession === 'pomo') {
                newState.tasks = newState.tasks.map(task => 
                    task.id === state.pomodoro.focusedTaskId 
                        ? { ...task, totalFocusTime: (task.totalFocusTime || 0) + 1 } 
                        : task
                );
            }
            
            return newState;
        }
        case 'SWITCH_SESSION': {
            const { pomodoro } = state;
            const { settings } = pomodoro;
            let nextSession: PomodoroState['currentSession'] = 'pomo';
            let nextCycle = pomodoro.currentCycle;
            let newFocusHistory = [...pomodoro.focusHistory];
            let notificationTitle = '';
            let notificationBody = '';

            if (pomodoro.currentSession === 'pomo') {
                nextCycle++;
                
                const sessionRecord: PomodoroFocusRecord = {
                    startTime: new Date(Date.now() - settings.pomoDuration * 1000).toISOString(),
                    endTime: new Date().toISOString(),
                    duration: settings.pomoDuration,
                    taskId: pomodoro.focusedTaskId
                };
                newFocusHistory.push(sessionRecord);

                if (nextCycle % settings.longBreakInterval === 0) {
                    nextSession = 'longBreak';
                    notificationTitle = 'Time for a long break!';
                    notificationBody = `Great work! Take a ${settings.longBreakDuration / 60}-minute break.`;
                } else {
                    nextSession = 'shortBreak';
                    notificationTitle = "Time for a short break!";
                    notificationBody = `Good job! Take a ${settings.shortBreakDuration / 60}-minute break.`;
                }
            } else {
                nextSession = 'pomo';
                notificationTitle = "Time to focus!";
                notificationBody = `Let's get back to it. Next session starting now.`;
            }

            const remainingTimeMap = {
                pomo: settings.pomoDuration,
                shortBreak: settings.shortBreakDuration,
                longBreak: settings.longBreakDuration,
            };
            
            playNotificationSound();
            sendNotification(notificationTitle, notificationBody);

            return {
                ...state,
                pomodoro: {
                    ...pomodoro,
                    currentSession: nextSession,
                    currentCycle: nextCycle,
                    remainingTime: remainingTimeMap[nextSession],
                    isPaused: false,
                    focusHistory: newFocusHistory,
                }
            };
        }

        // Habit Actions
        case 'ADD_HABIT': {
            const newHabit: Habit = {
                id: Date.now().toString(),
                name: action.payload.name,
                completions: [],
                createdAt: new Date().toISOString(),
            };
            return { ...state, habits: [...state.habits, newHabit] };
        }
        case 'TOGGLE_HABIT_COMPLETION': {
            const { habitId, date } = action.payload;
            return {
                ...state,
                habits: state.habits.map(habit => {
                    if (habit.id === habitId) {
                        const newCompletions = habit.completions.includes(date)
                            ? habit.completions.filter(d => d !== date)
                            : [...habit.completions, date];
                        return { ...habit, completions: newCompletions };
                    }
                    return habit;
                }),
            };
        }
        case 'DELETE_HABIT':
            return { ...state, habits: state.habits.filter(h => h.id !== action.payload) };

        // Countdown Actions
        case 'ADD_COUNTDOWN':
            return { ...state, countdownEvents: [...state.countdownEvents, action.payload] };
        case 'DELETE_COUNTDOWN':
            return { ...state, countdownEvents: state.countdownEvents.filter(c => c.id !== action.payload) };

        default:
            return state;
    }
};

const historyReducer = (state: HistoryState, action: Action): HistoryState => {
    const { past, present, future } = state;

    if (UNDOABLE_ACTIONS.has(action.type)) {
        const newPresent = appReducer(present, action);
        if (newPresent === present) {
            return state;
        }
        return {
            past: [...past, present],
            present: newPresent,
            future: [],
        };
    }

    switch (action.type) {
        case 'LOAD_STATE':
            return {
                past: [],
                present: action.payload,
                future: [],
            };
        case 'UNDO':
            if (past.length === 0) return state;
            const previous = past[past.length - 1];
            const newPast = past.slice(0, past.length - 1);
            return {
                past: newPast,
                present: previous,
                future: [present, ...future],
            };
        case 'REDO':
            if (future.length === 0) return state;
            const next = future[0];
            const newFuture = future.slice(1);
            return {
                past: [...past, present],
                present: next,
                future: newFuture,
            };
        case 'CLEAR_HISTORY':
            return {
                ...state,
                past: [],
                future: [],
            };
        default:
            const newPresent = appReducer(present, action);
            return {
                ...state,
                present: newPresent,
            };
    }
};

const TaskManagerContext = createContext<{
    state: AppState;
    dispatch: React.Dispatch<Action>;
    canUndo: boolean;
    canRedo: boolean;
} | undefined>(undefined);

const toYYYYMMDD = (date: Date) => date.toISOString().split('T')[0];

export const TaskManagerProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
    const [historyState, dispatch] = useReducer(historyReducer, initialHistoryState);
    const addToast = useToast();
    const { t } = useTranslation();
    const timerRef = useRef<number | null>(null);
    const reminderCheckRef = useRef<number | null>(null);
    const notifiedTaskIds = useRef<Set<string>>(new Set());
    const { pomodoro, tasks } = historyState.present;
    
    // Achievement checking logic moved to a useEffect to use toasts
    const previousStateRef = useRef<AppState>(historyState.present);

    useEffect(() => {
        const currentState = historyState.present;
        const previousState = previousStateRef.current;

        // Check for new achievements only if state has changed meaningfully
        if (currentState !== previousState) {
            const newlyUnlocked = ALL_ACHIEVEMENTS.filter(ach => 
                !previousState.unlockedAchievements.includes(ach.id) && ach.condition(currentState)
            );

            newlyUnlocked.forEach(ach => {
                dispatch({ type: 'UNLOCK_ACHIEVEMENT', payload: ach.id });
                addToast(`🏆 Achievement Unlocked: ${t(ach.title)}`, 'success');
            });
        }
        
        previousStateRef.current = currentState;

    }, [historyState.present, t, addToast]);


    useEffect(() => {
        try {
            const storedState = localStorage.getItem('taskflowState');
            if (storedState) {
                const parsedState = JSON.parse(storedState);
                
                const safeTasks = (parsedState.tasks || []).map((t: any) => ({
                    ...t,
                    totalFocusTime: t.totalFocusTime || 0,
                    assigneeId: t.assigneeId,
                    comments: t.comments || [],
                }));

                const safeLists = (parsedState.lists || []).map((l: any) => ({
                    ...l,
                    members: l.members || ['user-001'],
                }));
                
                let tags = parsedState.tags || [];
                // Backward compatibility: if tags array doesn't exist, create it from tasks
                if (!parsedState.tags && parsedState.tasks) {
                    const derivedTags = new Set<string>();
                    parsedState.tasks.forEach((task: Task) => task.tags.forEach(tag => derivedTags.add(tag)));
                    tags = Array.from(derivedTags);
                }


                const loadedPomodoroState = {
                    ...initialPomodoroState,
                    focusHistory: parsedState.pomodoro?.focusHistory || [],
                    settings: {
                        ...POMODORO_SETTINGS,
                        ...(parsedState.pomodoro?.settings)
                    }
                };

                const loadedState: AppState = { 
                    ...initialAppState, 
                    ...parsedState,
                    tasks: safeTasks,
                    lists: safeLists,
                    columns: parsedState.columns || [],
                    tags: tags,
                    habits: parsedState.habits || [],
                    countdownEvents: parsedState.countdownEvents || [],
                    unlockedAchievements: parsedState.unlockedAchievements || [],
                    pomodoro: loadedPomodoroState,
                    sortOrder: parsedState.sortOrder || 'default', 
                    activeTag: null,
                    view: 'dashboard', // Start with dashboard
                };
                
                dispatch({ type: 'LOAD_STATE', payload: loadedState });
            } else {
                 const mockLists: List[] = [
                    { id: 'list-1', name: 'Work', color: 'bg-blue-500', members: ['user-001', 'user-002'] },
                    { id: 'list-2', name: 'Personal', color: 'bg-green-500', members: ['user-001'] },
                    { id: 'list-3', name: 'Shopping', color: 'bg-yellow-500', members: ['user-001', 'user-003'] },
                ];
                
                const mockColumns: Column[] = [
                    { id: 'col-list-1-1', name: 'To Do', listId: 'list-1' },
                    { id: 'col-list-1-2', name: 'In Progress', listId: 'list-1' },
                    { id: 'col-list-1-3', name: 'Done', listId: 'list-1' },
                    { id: 'col-list-2-1', name: 'To Buy', listId: 'list-3' },
                    { id: 'col-list-2-2', name: 'Purchased', listId: 'list-3' },
                ];

                const today = new Date();
                const yesterday = new Date(); yesterday.setDate(today.getDate() - 1);
                const tomorrow = new Date(); tomorrow.setDate(today.getDate() + 1);
                const nextWeek = new Date(); nextWeek.setDate(today.getDate() + 7);

                const mockTasks: Task[] = [
                    { id: 'task-1', title: 'Finalize quarterly report', description: 'Compile all data and finalize the Q3 report for the review meeting.', completed: false, dueDate: tomorrow.toISOString(), priority: Priority.High, listId: 'list-1', columnId: 'col-list-1-2', tags: ['reporting', 'urgent'], subtasks: [ {id: 's-1', title: 'Gather sales data', completed: true}, {id: 's-2', title: 'Get marketing feedback', completed: false}], createdAt: new Date().toISOString(), totalFocusTime: 3600, assigneeId: 'user-002', comments: [{id: 'c-1', userId: 'user-002', content: "I'll get the marketing feedback by EOD.", createdAt: new Date().toISOString()}] },
                    { id: 'task-2', title: 'Call the vet for appointment', description: '', completed: false, dueDate: today.toISOString(), priority: Priority.Medium, listId: 'list-2', tags: [], subtasks: [], createdAt: new Date().toISOString(), totalFocusTime: 0 },
                    { id: 'task-3', title: 'Buy groceries', description: 'Milk, bread, eggs, and cheese.', completed: true, completedAt: yesterday.toISOString(), dueDate: yesterday.toISOString(), priority: Priority.Low, listId: 'list-3', columnId: 'col-list-2-2', tags: [], subtasks: [], createdAt: new Date().toISOString(), totalFocusTime: 0, assigneeId: 'user-003' },
                    { id: 'task-4', title: 'Daily Standup Meeting', description: 'Quick sync with the team.', completed: false, dueDate: today.toISOString(), priority: Priority.Medium, listId: 'list-1', columnId: 'col-list-1-1', tags: [], subtasks: [], createdAt: new Date().toISOString(), totalFocusTime: 0, recurrence: { rule: 'daily' } },
                    { id: 'task-5', title: 'Pay electricity bill', description: 'Due by the end of the week', completed: false, dueDate: nextWeek.toISOString(), priority: Priority.High, listId: 'inbox', tags: ['bills'], subtasks: [], createdAt: new Date().toISOString(), totalFocusTime: 0 },
                    { id: 'task-6', title: 'Research new project ideas', description: '', completed: false, priority: Priority.Low, listId: 'list-1', columnId: 'col-list-1-1', tags: ['research'], subtasks: [], createdAt: new Date().toISOString(), totalFocusTime: 7200, assigneeId: 'user-001' },
                    { id: 'task-7', title: 'Schedule dentist appointment', description: '', completed: true, completedAt: today.toISOString(), priority: Priority.None, listId: 'list-2', tags: [], subtasks: [], createdAt: new Date().toISOString(), totalFocusTime: 0 },
                    { id: 'task-8', title: 'Renew gym membership', description: 'Membership expires next month.', completed: false, dueDate: nextWeek.toISOString(), priority: Priority.Medium, listId: 'list-2', tags: [], subtasks: [], createdAt: new Date().toISOString(), totalFocusTime: 0 },
                    { id: 'task-9', title: 'Submit TPS reports', description: 'Remember the new cover sheet.', completed: false, dueDate: yesterday.toISOString(), priority: Priority.High, listId: 'list-1', columnId: 'col-list-1-3', tags: ['reporting'], subtasks: [], createdAt: new Date().toISOString(), totalFocusTime: 0, assigneeId: 'user-002' },
                ];
                
                const allMockTags = new Set<string>();
                mockTasks.forEach(task => task.tags.forEach(tag => allMockTags.add(tag)));

                const dayBeforeYesterday = new Date(); dayBeforeYesterday.setDate(today.getDate() - 2);
                const mockHabits: Habit[] = [
                    { id: 'habit-1', name: 'Read for 15 minutes', completions: [toYYYYMMDD(yesterday), toYYYYMMDD(dayBeforeYesterday)], createdAt: new Date().toISOString() },
                    { id: 'habit-2', name: 'Drink 8 glasses of water', completions: [toYYYYMMDD(yesterday)], createdAt: new Date().toISOString() }
                ];

                const nextYear = new Date(); nextYear.setFullYear(today.getFullYear()); nextYear.setMonth(11); nextYear.setDate(31);
                const mockCountdowns: CountdownEvent[] = [
                    { id: 'cd-1', name: 'New Year\'s Eve', targetDate: nextYear.toISOString() }
                ];

                const mockDataState: AppState = {
                    ...initialAppState,
                    tasks: mockTasks,
                    tags: Array.from(allMockTags),
                    lists: mockLists,
                    columns: mockColumns,
                    habits: mockHabits,
                    countdownEvents: mockCountdowns,
                    view: 'dashboard',
                };
                
                dispatch({ type: 'LOAD_STATE', payload: mockDataState });
            }
        } catch (error) {
            console.error("Could not load state from localStorage", error);
            dispatch({ type: 'LOAD_STATE', payload: { ...initialAppState, tasks: INITIAL_TASKS, lists: INITIAL_LISTS, view: 'dashboard' } });
        }
    }, []);

    useEffect(() => {
        try {
            localStorage.setItem('taskflowState', JSON.stringify(historyState.present));
        } catch (error) {
            console.error("Could not save state to localStorage", error);
        }
    }, [historyState.present]);

    useEffect(() => {
        if (pomodoro.isActive && !pomodoro.isPaused) {
            timerRef.current = window.setInterval(() => {
                dispatch({ type: 'TICK' });
            }, 1000);
        }
        return () => {
            if (timerRef.current) {
                clearInterval(timerRef.current);
            }
        };
    }, [pomodoro.isActive, pomodoro.isPaused]);

    useEffect(() => {
        if (pomodoro.remainingTime < 0 && pomodoro.isActive) {
            dispatch({ type: 'SWITCH_SESSION' });
        }
    }, [pomodoro.remainingTime, pomodoro.isActive]);

    useEffect(() => {
        const checkReminders = () => {
            const now = new Date().getTime();
            tasks.forEach(task => {
                if (task.dueDate && task.reminderMinutes && !task.completed) {
                    const dueDate = new Date(task.dueDate).getTime();
                    const reminderTime = dueDate - task.reminderMinutes * 60 * 1000;

                    if (now >= reminderTime && now < dueDate) {
                        if (!notifiedTaskIds.current.has(task.id)) {
                            sendNotification(
                                `Reminder: ${task.title}`,
                                `This task is due in ${task.reminderMinutes} minutes.`
                            );
                            notifiedTaskIds.current.add(task.id);
                        }
                    } else if (now >= dueDate) {
                        // clear notification if past due
                        notifiedTaskIds.current.delete(task.id);
                    }
                }
            });
        };
        
        // check every 30 seconds
        reminderCheckRef.current = window.setInterval(checkReminders, 30000);
        
        return () => {
            if(reminderCheckRef.current) {
                clearInterval(reminderCheckRef.current);
            }
        }
    }, [tasks]);


    const contextValue = {
        state: historyState.present,
        dispatch,
        canUndo: historyState.past.length > 0,
        canRedo: historyState.future.length > 0,
    };

    return (
        <TaskManagerContext.Provider value={contextValue}>
            {children}
        </TaskManagerContext.Provider>
    );
};

export const useTaskManager = () => {
    const context = useContext(TaskManagerContext);
    if (context === undefined) {
        throw new Error('useTaskManager must be used within a TaskManagerProvider');
    }
    return context;
};

================================================================================

--- FILE: hooks/useToast.tsx ---

import React, { createContext, useContext, useState, useCallback, ReactNode } from 'react';

type ToastType = 'success' | 'error' | 'info';

interface ToastMessage {
    id: number;
    message: string;
    type: ToastType;
}

interface ToastContextType {
    addToast: (message: string, type?: ToastType) => void;
    toasts: ToastMessage[];
    removeToast: (id: number) => void;
}

const ToastContext = createContext<ToastContextType | undefined>(undefined);

export const ToastProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
    const [toasts, setToasts] = useState<ToastMessage[]>([]);

    const removeToast = useCallback((id: number) => {
        setToasts(prevToasts => prevToasts.filter(toast => toast.id !== id));
    }, []);

    const addToast = useCallback((message: string, type: ToastType = 'info') => {
        const id = Date.now();
        setToasts(prevToasts => [...prevToasts, { id, message, type }]);
        setTimeout(() => removeToast(id), 5000); // Auto-dismiss after 5 seconds
    }, [removeToast]);
    
    return (
        <ToastContext.Provider value={{ addToast, toasts, removeToast }}>
            {children}
        </ToastContext.Provider>
    );
};

export const useToast = (): ((message: string, type?: ToastType) => void) => {
    const context = useContext(ToastContext);
    if (!context) {
        throw new Error('useToast must be used within a ToastProvider');
    }
    return context.addToast;
};

// This hook is for the container component to get all toasts
export const useToastContainer = () => {
     const context = useContext(ToastContext);
    if (!context) {
        throw new Error('useToastContainer must be used within a ToastProvider');
    }
    return { toasts: context.toasts, removeToast: context.removeToast };
}


================================================================================

--- FILE: hooks/useUser.tsx ---

import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { User } from '../types';

interface UserState {
    user: User | null;
    allUsers: User[];
    isAuthenticated: boolean;
    login: (email: string, password: string) => void;
    register: (name: string, email: string, password: string) => void;
    logout: () => void;
    updateUser: (updatedData: Partial<User>) => void;
}

const MOCK_USER: User = {
    id: 'user-001',
    name: 'Alex Ryder',
    email: 'alex.ryder@example.com',
    avatarUrl: `https://api.dicebear.com/8.x/initials/svg?seed=Alex%20Ryder`,
};

const MOCK_USERS: User[] = [
    MOCK_USER,
    { id: 'user-002', name: 'Jane Doe', email: 'jane.doe@example.com', avatarUrl: `https://api.dicebear.com/8.x/initials/svg?seed=Jane%20Doe` },
    { id: 'user-003', name: 'John Smith', email: 'john.smith@example.com', avatarUrl: `https://api.dicebear.com/8.x/initials/svg?seed=John%20Smith` },
    { id: 'user-004', name: 'Emily White', email: 'emily.white@example.com', avatarUrl: `https://api.dicebear.com/8.x/initials/svg?seed=Emily%20White` },
];


const UserContext = createContext<UserState | undefined>(undefined);

export const UserProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
    const [user, setUser] = useState<User | null>(null);
    const isAuthenticated = !!user;

    useEffect(() => {
        // Check for saved user session on initial load
        try {
            const savedUser = localStorage.getItem('taskflowUser');
            if (savedUser) {
                setUser(JSON.parse(savedUser));
            }
        } catch (error) {
            console.error('Failed to load user from localStorage', error);
            localStorage.removeItem('taskflowUser');
        }
    }, []);

    const login = (email: string, password: string) => {
        // Mock login - in a real app, you'd call an API
        console.log(`Attempting login with email: ${email}`);
        setUser(MOCK_USER);
        localStorage.setItem('taskflowUser', JSON.stringify(MOCK_USER));
    };

    const register = (name: string, email: string, password: string) => {
        // Mock register - logs info and then logs in the user
        console.log('Mock registration:', { name, email, password });
        login(email, password);
    };

    const logout = () => {
        setUser(null);
        localStorage.removeItem('taskflowUser');
    };

    const updateUser = (updatedData: Partial<User>) => {
        if (user) {
            const updatedUser = { ...user, ...updatedData };
            setUser(updatedUser);
            localStorage.setItem('taskflowUser', JSON.stringify(updatedUser));
        }
    };

    return (
        <UserContext.Provider value={{ user, allUsers: MOCK_USERS, isAuthenticated, login, register, logout, updateUser }}>
            {children}
        </UserContext.Provider>
    );
};

export const useUser = (): UserState => {
    const context = useContext(UserContext);
    if (context === undefined) {
        throw new Error('useUser must be used within a UserProvider');
    }
    return context;
};

================================================================================

--- FILE: index.html ---

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TaskFlow - Powered by Gemini</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              background: 'hsl(var(--background))',
              foreground: 'hsl(var(--foreground))',
              card: 'hsl(var(--card))',
              'card-foreground': 'hsl(var(--card-foreground))',
              popover: 'hsl(var(--popover))',
              'popover-foreground': 'hsl(var(--popover-foreground))',
              primary: 'hsl(var(--primary))',
              'primary-foreground': 'hsl(var(--primary-foreground))',
              secondary: 'hsl(var(--secondary))',
              'secondary-foreground': 'hsl(var(--secondary-foreground))',
              muted: 'hsl(var(--muted))',
              'muted-foreground': 'hsl(var(--muted-foreground))',
              accent: 'hsl(var(--accent))',
              'accent-foreground': 'hsl(var(--accent-foreground))',
              destructive: 'hsl(var(--destructive))',
              'destructive-foreground': 'hsl(var(--destructive-foreground))',
              border: 'hsl(var(--border))',
              input: 'hsl(var(--input))',
              ring: 'hsl(var(--ring))',
            },
            borderRadius: {
              lg: `var(--radius)`,
              md: `calc(var(--radius) - 2px)`,
              sm: 'calc(var(--radius) - 4px)',
            },
            keyframes: {
                "accordion-down": {
                    from: { height: 0 },
                    to: { height: "var(--radix-accordion-content-height)" },
                },
                "accordion-up": {
                    from: { height: "var(--radix-accordion-content-height)" },
                    to: { height: 0 },
                },
                "slide-in": {
                    from: { transform: "translateX(100%)" },
                    to: { transform: "translateX(0)" },
                },
                "fade-in": {
                    from: { opacity: 0 },
                    to: { opacity: 1 },
                }
            },
            animation: {
                "accordion-down": "accordion-down 0.2s ease-out",
                "accordion-up": "accordion-up 0.2s ease-out",
                "slide-in": "slide-in 0.3s ease-out",
                "fade-in": "fade-in 0.2s ease-out",
            },
          }
        }
      }
    </script>
    <style>
      :root {
        --background: 0 0% 100%;
        --foreground: 222.2 84% 4.9%;
        --card: 0 0% 100%;
        --card-foreground: 222.2 84% 4.9%;
        --popover: 0 0% 100%;
        --popover-foreground: 222.2 84% 4.9%;
        --primary: 222.2 47.4% 11.2%;
        --primary-foreground: 210 40% 98%;
        --secondary: 210 40% 96.1%;
        --secondary-foreground: 222.2 47.4% 11.2%;
        --muted: 210 40% 96.1%;
        --muted-foreground: 215.4 16.3% 46.9%;
        --accent: 210 40% 96.1%;
        --accent-foreground: 222.2 47.4% 11.2%;
        --destructive: 0 84.2% 60.2%;
        --destructive-foreground: 210 40% 98%;
        --border: 214.3 31.8% 91.4%;
        --input: 214.3 31.8% 91.4%;
        --ring: 222.2 84% 4.9%;
        --radius: 0.5rem;
        --scrollbar-track: hsl(var(--secondary));
        --scrollbar-thumb: hsl(var(--muted-foreground));
        --scrollbar-thumb-hover: hsl(var(--primary));
      }
      .dark {
        --background: 222.2 84% 4.9%;
        --foreground: 210 40% 98%;
        --card: 222.2 84% 4.9%;
        --card-foreground: 210 40% 98%;
        --popover: 222.2 84% 4.9%;
        --popover-foreground: 210 40% 98%;
        --primary: 210 40% 98%;
        --primary-foreground: 222.2 47.4% 11.2%;
        --secondary: 217.2 32.6% 17.5%;
        --secondary-foreground: 210 40% 98%;
        --muted: 217.2 32.6% 17.5%;
        --muted-foreground: 215 20.2% 65.1%;
        --accent: 217.2 32.6% 17.5%;
        --accent-foreground: 210 40% 98%;
        --destructive: 0 62.8% 30.6%;
        --destructive-foreground: 210 40% 98%;
        --border: 217.2 32.6% 17.5%;
        --input: 217.2 32.6% 17.5%;
        --ring: 212.7 26.8% 83.9%;
        --scrollbar-track: hsl(var(--secondary));
        --scrollbar-thumb: hsl(var(--muted-foreground));
        --scrollbar-thumb-hover: hsl(var(--primary));
      }
      body {
        background-color: hsl(var(--background));
        color: hsl(var(--foreground));
      }
      /* Custom Scrollbar */
      ::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }
      ::-webkit-scrollbar-track {
        background: transparent;
      }
      ::-webkit-scrollbar-thumb {
        background: var(--scrollbar-thumb);
        border-radius: 10px;
        border: 2px solid hsl(var(--background));
      }
      ::-webkit-scrollbar-thumb:hover {
        background: var(--scrollbar-thumb-hover);
      }
    </style>
  <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "@google/genai": "https://esm.sh/@google/genai@0.14.0",
    "react-dom/": "https://esm.sh/react-dom@18.2.0/",
    "react/": "https://esm.sh/react@18.2.0/"
  }
}
</script>
<script type="module" src="/index.tsx"></script>
<link rel="stylesheet" href="/index.css">
</head>
  <body class="bg-background">
    <div id="root"></div>
  </body>
</html>

================================================================================

--- FILE: index.tsx ---

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import { SettingsProvider } from './hooks/useSettings';
import { I18nProvider } from './hooks/useI18n';
import { ToastProvider } from './hooks/useToast';
import { TaskManagerProvider } from './hooks/useTaskManager';
import { ConfirmationProvider } from './hooks/useConfirmation';
import { GeminiProvider } from './hooks/useGemini';
import { UserProvider } from './hooks/useUser';


const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <UserProvider>
      <SettingsProvider>
        <I18nProvider>
          <ToastProvider>
            <TaskManagerProvider>
              <ConfirmationProvider>
                <GeminiProvider>
                  <App />
                </GeminiProvider>
              </ConfirmationProvider>
            </TaskManagerProvider>
          </ToastProvider>
        </I18nProvider>
      </SettingsProvider>
    </UserProvider>
  </React.StrictMode>
);

================================================================================

--- FILE: locales/en.json ---


{
    "specialLists.inbox": "Inbox",
    "specialLists.today": "Today",
    "specialLists.upcoming": "Upcoming",
    "specialLists.tomorrow": "Tomorrow",
    "priority.none": "None",
    "priority.low": "Low",
    "priority.medium": "Medium",
    "priority.high": "High",
    "sidebar.myLists": "My Lists",
    "sidebar.addNewList": "Add a new list...",
    "sidebar.tags": "Tags",
    "sidebar.addNewTag": "Add a new tag...",
    "sidebar.chatWithGemini": "Chat with Gemini",
    "sidebar.deleteList.confirm.title": "Delete \"{{listName}}\"?",
    "sidebar.deleteList.confirm.message": "This will permanently delete the list and all of its tasks. This action cannot be undone.",
    "sidebar.deleteList.confirm.button": "Delete List",
    "sidebar.deleteList.success": "List \"{{listName}}\" deleted",
    "sidebar.deleteTag.confirm.title": "Delete tag \"#{{tagName}}\"?",
    "sidebar.deleteTag.confirm.message": "This will permanently remove the tag from all tasks. This action cannot be undone.",
    "sidebar.deleteTag.confirm.button": "Delete Tag",
    "sidebar.deleteTag.success": "Tag \"#{{tagName}}\" deleted",
    "sidebar.aria.shareList": "Share list {{listName}}",
    "sidebar.aria.deleteList": "Delete list {{listName}}",
    "sidebar.aria.deleteTag": "Delete tag {{tagName}}",
    "mainContent.dailyBriefing": "Daily Briefing",
    "taskList.allDone": "All done!",
    "taskList.noTasks": "You have no tasks here. Add one to get started.",
    "taskList.addTask": "Add Task",
    "taskList.completed": "Completed",
    "taskDetail.recurringInfo": "This is a recurring task ({{rule}}).",
    "taskDetail.completed": "Completed",
    "taskDetail.markComplete": "Mark as complete",
    "taskDetail.focusTime": "Focused for <strong>{{time}}</strong>",
    "taskDetail.descriptionLabel": "Description",
    "taskDetail.descriptionPlaceholder": "Add a description...",
    "taskDetail.sourcesLabel": "Sources",
    "taskDetail.priorityLabel": "Priority",
    "taskDetail.tagsLabel": "Tags",
    "taskDetail.tagsPlaceholder": "Add a tag...",
    "taskDetail.tagsHelper": "Press Enter to add a tag.",
    "taskDetail.subtasksLabel": "Subtasks",
    "taskDetail.generateButton": "Generate",
    "taskDetail.progressLabel": "Progress",
    "taskDetail.addSubtaskPlaceholder": "Add subtask...",
    "taskDetail.addButton": "Add",
    "taskDetail.getInfoButton": "Get Info",
    "taskDetail.startFocusButton": "Start Focus",
    "taskItem.aria.markIncomplete": "Mark task as incomplete",
    "taskItem.aria.markComplete": "Mark task as complete",
    "taskItem.aria.startFocus": "Start focus session",
    "taskItem.title.repeats": "Repeats {{rule}}",
    "taskItem.title.reminder": "Reminder {{minutes}} minutes before",
    "recurrence.title": "Recurrence",
    "recurrence.none": "None",
    "recurrence.daily": "Daily",
    "recurrence.weekly": "Weekly",
    "recurrence.monthly": "Monthly",
    "reminder.title": "Reminder",
    "reminder.none": "None",
    "reminder.5min": "5 minutes before",
    "reminder.15min": "15 minutes before",
    "reminder.30min": "30 minutes before",
    "reminder.1hour": "1 hour before",
    "habitView.title": "Habit Tracker",
    "habitView.subtitle": "Build consistency one day at a time.",
    "habitView.addPlaceholder": "Add a new habit... (e.g., Read for 15 minutes)",
    "habitView.emptyState.title": "No Habits Yet",
    "habitView.emptyState.subtitle": "Add your first habit to start building a streak.",
    "habit.streak": "{{count}} Day Streak",
    "habit.noStreak": "No current streak",
    "habit.deleteConfirm.title": "Delete \"{{habitName}}\"?",
    "habit.deleteConfirm.message": "This will permanently delete this habit and its history. This action cannot be undone.",
    "habit.deleteConfirm.confirmText": "Delete Habit",
    "habit.deleteSuccess": "Habit \"{{habitName}}\" deleted",
    "habit.heatmap.tooltip.completed": "{{date}}: Completed",
    "habit.heatmap.tooltip.notCompleted": "{{date}}: Not completed",
    "countdownView.title": "Countdowns",
    "countdownView.subtitle": "Track your most anticipated events.",
    "countdownView.add": "Add Countdown",
    "countdownView.emptyState.title": "No Countdowns Yet",
    "countdownView.emptyState.subtitle": "Click \"Add Countdown\" to get started.",
    "countdown.modal.title": "New Countdown",
    "countdown.modal.nameLabel": "Event Name",
    "countdown.modal.namePlaceholder": "e.g., Summer Vacation",
    "countdown.modal.dateLabel": "Target Date",
    "countdown.modal.create": "Create Countdown",
    "countdown.card.expired": "Expired",
    "countdown.card.dayRemaining": "Day remaining",
    "countdown.card.daysRemaining": "Days remaining",
    "countdown.deleteConfirm.title": "Delete \"{{eventName}}\"?",
    "countdown.deleteConfirm.message": "This will permanently delete this countdown. This action cannot be undone.",
    "countdown.deleteConfirm.confirmText": "Delete Countdown",
    "countdown.deleteSuccess": "Countdown \"{{eventName}}\" deleted",
    "settings.title": "Settings",
    "settings.subtitle": "Customize your TaskFlow experience.",
    "settings.appearance": "Appearance",
    "settings.theme": "Theme",
    "settings.theme.light": "Light",
    "settings.theme.dark": "Dark",
    "settings.language": "Language",
    "settings.language.en": "English",
    "settings.language.vi": "Vietnamese (Tiếng Việt)",
    "settings.pomodoro.title": "Pomodoro Timer",
    "settings.pomodoro.focusDuration": "Focus Duration (minutes)",
    "settings.pomodoro.shortBreak": "Short Break (minutes)",
    "settings.pomodoro.longBreak": "Long Break (minutes)",
    "settings.pomodoro.longBreakInterval": "Long Break Interval (sessions)",
    "settings.bottomNav.title": "Customize Bottom Navigation",
    "settings.bottomNav.subtitle": "Drag & drop to reorder or hide items in the mobile navigation bar.",
    "settings.bottomNav.visible": "Visible Items (Max 4)",
    "settings.bottomNav.hidden": "Hidden Items",
    "chatbot.title": "Gemini Assistant",
    "chatbot.initialMessage": "Hello! How can I help you be more productive today?",
    "chatbot.sources": "Sources:",
    "chatbot.thinkingMode": "Thinking Mode",
    "chatbot.searchWeb": "Search the web",
    "chatbot.placeholder": "Ask Gemini anything...",
    "dashboard.greeting.morning": "Good morning!",
    "dashboard.greeting.afternoon": "Good afternoon!",
    "dashboard.greeting.evening": "Good evening!",
    "dashboard.subtitle": "Here's your productivity dashboard for today.",
    "dashboard.stat.today": "Tasks for Today",
    "dashboard.stat.upcoming": "Upcoming Tasks",
    "dashboard.stat.habits": "Habits Completed",
    "dashboard.cta.title": "Ready to plan your day?",
    "dashboard.cta.subtitle": "Let Gemini analyze your tasks and habits to create a personalized, actionable plan to help you stay focused and productive.",
    "dashboard.cta.button": "Get My Daily Briefing",
    "dashboard.heatmapTitle": "Productivity Heatmap",
    "heatmap.tooltip.noActivity": "No activity on {{date}}",
    "heatmap.tooltip.activity": "{{date}}\n- {{tasksCount}} task(s) completed\n- {{pomosCount}} Pomodoro session(s)",
    "heatmap.tooltip.future": "Future date",
    "achievements.title": "Achievements",
    "achievements.subtitle": "Unlock badges for your hard work and consistency.",
    "achievements.locked.description": "???",
    "achievements.locked.status": "Locked",
    "achievements.first_step.title": "First Step",
    "achievements.first_step.description": "Complete your very first task.",
    "achievements.task_novice.title": "Task Novice",
    "achievements.task_novice.description": "Complete 10 tasks.",
    "achievements.task_master.title": "Task Master",
    "achievements.task_master.description": "Complete 100 tasks.",
    "achievements.focus_starter.title": "Focus Starter",
    "achievements.focus_starter.description": "Complete your first Pomodoro session.",
    "achievements.focus_pro.title": "Focus Pro",
    "achievements.focus_pro.description": "Complete 25 Pomodoro sessions.",
    "achievements.habit_builder.title": "Habit Builder",
    "achievements.habit_builder.description": "Maintain a 7-day streak on any habit.",
    "achievements.habit_hero.title": "Habit Hero",
    "achievements.habit_hero.description": "Maintain a 30-day streak on any habit.",
    "achievements.ai_assistant.title": "AI Collaborator",
    "achievements.ai_assistant.description": "Use Gemini to generate subtasks.",
    "achievements.planner.title": "The Planner",
    "achievements.planner.description": "Create 10 tasks with a due date.",
    "achievements.delegator.title": "The Delegator",
    "achievements.delegator.description": "Assign 5 tasks to team members.",
    "auth.welcome": "Welcome back! Please sign in.",
    "auth.emailLabel": "Email address",
    "auth.passwordLabel": "Password",
    "auth.signIn": "Sign in",
    "auth.noAccount": "Don't have an account?",
    "auth.signUp": "Sign up",
    "auth.mockLoginInfo": "(This is a mock login. Any input will work.)",
    "auth.createAccountPrompt": "Create your account to get started.",
    "auth.fullNameLabel": "Full Name",
    "auth.alreadyHaveAccount": "Already have an account?",
    "auth.tagline": "From chaos to clarity. Your ultimate productivity partner.",
    "auth.signInWithGoogle": "Sign in with Google",
    "auth.signInWithGitHub": "Sign in with GitHub",
    "auth.orContinueWith": "Or continue with",
    "profile.viewProfile": "View Profile",
    "profile.settings": "Settings",
    "profile.achievements": "Achievements",
    "profile.logout": "Logout",
    "profile.editProfile": "Edit Profile",
    "profile.stats.title": "Productivity Stats",
    "profile.stats.tasksCompleted": "Tasks Completed",
    "profile.stats.focusTime": "Total Focus",
    "profile.stats.achievementsUnlocked": "Achievements Unlocked",
    "profile.weeklyActivity": "Weekly Activity",
    "profile.tasksCompleted": "Tasks Completed",
    "profile.recentActivity": "Recent Activity",
    "profile.noRecentActivity": "No recent activity to show.",
    "profile.recentAchievements": "Recent Achievements",
    "profile.noAchievements": "No achievements unlocked yet. Keep going!",
    "profile.editModal.title": "Edit Profile",
    "profile.editModal.nameLabel": "Full Name",
    "profile.editModal.emailLabel": "Email Address",
    "profile.editModal.saveButton": "Save Changes",
    "profile.updateSuccess": "Profile updated successfully!",
    "feature.toggleSidebar": "Toggle Sidebar",
    "feature.dashboard": "Dashboard",
    "feature.listView": "List View",
    "feature.boardView": "Board View",
    "feature.calendarView": "Calendar View",
    "feature.matrixView": "Matrix View",
    "feature.habitTracker": "Habit Tracker",
    "feature.pomodoro": "Pomodoro",
    "feature.countdown": "Countdown",
    "feature.more": "More",
    "mainContent.tasksDefault": "Tasks",
    "mainContent.searchTasks": "Search tasks",
    "mainContent.sortTasks": "Sort tasks",
    "mainContent.undo": "Undo",
    "mainContent.redo": "Redo",
    "mainContent.clearHistory": "Clear History",
    "board.title": "Board View",
    "board.noLists": "No Lists for Board View",
    "board.noListsSubtitle": "Create a custom list to use the board view feature.",
    "board.addColumn": "Add another column",
    "board.column.dragHandle": "Drag to reorder column",
    "board.column.namePlaceholder": "Enter column name...",
    "board.column.addColumn": "Add Column",
    "board.column.cancel": "Cancel",
    "board.column.addCard": "Add a card",
    "board.column.menu.rename": "Rename",
    "board.column.menu.delete": "Delete",
    "board.column.deleteConfirm.title": "Delete column \"{{columnName}}\"?",
    "board.column.deleteConfirm.message": "All tasks in this column will be moved to the first column. This action cannot be undone.",
    "board.column.deleteConfirm.confirmText": "Delete Column",
    "board.column.deleteSuccess": "Column \"{{columnName}}\" deleted",
    "calendar.today": "Today",
    "calendar.month": "Month",
    "calendar.week": "Week",
    "calendar.allDay": "All-day",
    "calendar.moreTasks": "+ {{count}} more",
    "pomodoro.view.title": "Pomodoro",
    "pomodoro.focus": "Focus",
    "pomodoro.shortBreak": "Short Break",
    "pomodoro.longBreak": "Long Break",
    "pomodoro.selectTask": "Select a task",
    "pomodoro.focusingOn": "Focusing on: {{taskTitle}}",
    "pomodoro.stop": "Stop",
    "pomodoro.start": "Start",
    "pomodoro.pause": "Pause",
    "pomodoro.overview": "Overview",
    "pomodoro.todayPomos": "Today's Pomos",
    "pomodoro.totalFocus": "Total Focus",
    "pomodoro.focusRecord": "Focus Record",
    "pomodoro.noRecords": "No focus sessions recorded today.",
    "pomodoro.generalFocus": "General Focus",
    "taskForm.newTask": "New Task",
    "taskForm.createWithGemini": "Create task from text with Gemini",
    "taskForm.geminiPlaceholder": "e.g., Remind me to call John about the project proposal tomorrow at 2 PM",
    "taskForm.analyzeAndFill": "Analyze and Fill",
    "taskForm.titleLabel": "Title",
    "taskForm.titlePlaceholder": "e.g., Pay electricity bill",
    "taskForm.descriptionLabel": "Description",
    "taskForm.descriptionPlaceholder": "Add details...",
    "taskForm.dueDateLabel": "Due Date",
    "taskForm.priorityLabel": "Priority",
    "taskForm.listLabel": "List",
    "taskForm.createTask": "Create Task",
    "briefing.error.unavailable": "Gemini API is not available.",
    "briefing.title": "Your AI Daily Briefing",
    "briefing.loading": "Gemini is analyzing your day...",
    "briefing.error.failed": "Failed to generate briefing",
    "briefing.button.gotIt": "Got it!",
    "assigneePicker.label": "Assignee",
    "assigneePicker.unassigned": "Unassigned",
    "assigneePicker.unassign": "Unassign",
    "comments.title": "Activity",
    "comments.unknownUser": "Unknown User",
    "comments.empty": "No comments yet.",
    "comments.placeholder": "Add a comment...",
    "timeAgo.year": "{{count}}y ago",
    "timeAgo.month": "{{count}}mo ago",
    "timeAgo.day": "{{count}}d ago",
    "timeAgo.hour": "{{count}}h ago",
    "timeAgo.minute": "{{count}}m ago",
    "timeAgo.now": "just now",
    "shareList.title": "Share \"{{listName}}\"",
    "shareList.subtitle": "Manage who can access this list.",
    "shareList.members": "Members",
    "shareList.owner": "Owner",
    "shareList.invite": "Invite others",
    "shareList.empty": "Everyone is already in this list.",
    "shareList.done": "Done",
    "landing.nav.launch": "Launch App",
    "landing.hero.title": "Unleash Your Productivity",
    "landing.hero.subtitle": "TaskFlow combines modern task management with the power of Gemini AI to help you organize, prioritize, and achieve your goals faster than ever.",
    "landing.hero.cta": "Get Started for Free",
    "landing.features.title": "Everything You Need, All in One Place",
    "landing.features.subtitle": "A complete toolkit to master your workflow.",
    "landing.feature1.title": "Smart Management",
    "landing.feature1.description": "Let Gemini analyze your notes to create tasks, suggest subtasks, and provide daily briefings to keep you on track.",
    "landing.feature2.title": "Flexible Views",
    "landing.feature2.description": "From simple lists and calendars to the powerful Eisenhower Matrix, visualize your tasks in the way that works best for you.",
    "landing.feature3.title": "Productivity Toolkit",
    "landing.feature3.description": "Integrated Pomodoro timer, habit tracker, and event countdowns to help you build focus and maintain momentum.",
    "landing.testimonials.title": "Loved by Productive People",
    "landing.testimonials.subtitle": "See what our users are saying about TaskFlow.",
    "landing.testimonial1.quote": "\"TaskFlow has completely changed how I organize my work. The AI features are a game-changer for breaking down big projects.\"",
    "landing.testimonial1.author": "Sarah J.",
    "landing.testimonial1.role": "Freelance Designer",
    "landing.testimonial2.quote": "\"I've tried every task manager out there. TaskFlow is the first one that actually sticks. The pomodoro timer and habit tracker are perfectly integrated.\"",
    "landing.testimonial2.author": "Mike R.",
    "landing.testimonial2.role": "Software Engineer",
    "landing.cta.title": "Ready to Boost Your Productivity?",
    "landing.cta.subtitle": "Stop juggling apps and start achieving your goals. Launch TaskFlow and experience a smarter way to work.",
    "landing.cta.button": "Launch App for Free",
    "landing.footer.copyright": "© {{year}} TaskFlow. All rights reserved.",
    "matrix.title": "Eisenhower Matrix",
    "matrix.subtitle": "Prioritize your tasks based on urgency and importance.",
    "matrix.q1.title": "Urgent & Important",
    "matrix.q1.subtitle": "Do these tasks first.",
    "matrix.q2.title": "Not Urgent & Important",
    "matrix.q2.subtitle": "Schedule these tasks.",
    "matrix.q3.title": "Urgent & Not Important",
    "matrix.q3.subtitle": "Delegate these tasks.",
    "matrix.q4.title": "Not Urgent & Not Important",
    "matrix.q4.subtitle": "Eliminate these tasks.",
    "matrix.empty": "No tasks in this quadrant.",
    "focusPicker.title": "Select a Task to Focus On",
    "focusPicker.general": "General Focus (No specific task)",
    "search.placeholder": "Search tasks by title, description, or tag...",
    "search.noResults": "No tasks found for \"{{searchTerm}}\"",
    "datePicker.placeholder": "Select a date",
    "datePicker.aria.clear": "Clear date",
    "datePicker.today": "Today",
    "toast.close": "Close"
}

================================================================================

--- FILE: locales/vi.json ---


{
    "specialLists.inbox": "Hộp thư đến",
    "specialLists.today": "Hôm nay",
    "specialLists.upcoming": "Sắp tới",
    "specialLists.tomorrow": "Ngày mai",
    "priority.none": "Không có",
    "priority.low": "Thấp",
    "priority.medium": "Vừa",
    "priority.high": "Cao",
    "sidebar.myLists": "Danh sách của tôi",
    "sidebar.addNewList": "Thêm danh sách mới...",
    "sidebar.tags": "Thẻ",
    "sidebar.addNewTag": "Thêm thẻ mới...",
    "sidebar.chatWithGemini": "Trò chuyện với Gemini",
    "sidebar.deleteList.confirm.title": "Xóa \"{{listName}}\"?",
    "sidebar.deleteList.confirm.message": "Thao tác này sẽ xóa vĩnh viễn danh sách và tất cả các công việc trong đó. Không thể hoàn tác.",
    "sidebar.deleteList.confirm.button": "Xóa danh sách",
    "sidebar.deleteList.success": "Đã xóa danh sách \"{{listName}}\"",
    "sidebar.deleteTag.confirm.title": "Xóa thẻ \"#{{tagName}}\"?",
    "sidebar.deleteTag.confirm.message": "Thao tác này sẽ xóa vĩnh viễn thẻ khỏi tất cả các công việc. Không thể hoàn tác.",
    "sidebar.deleteTag.confirm.button": "Xóa thẻ",
    "sidebar.deleteTag.success": "Đã xóa thẻ \"#{{tagName}}\"",
    "sidebar.aria.shareList": "Chia sẻ danh sách {{listName}}",
    "sidebar.aria.deleteList": "Xóa danh sách {{listName}}",
    "sidebar.aria.deleteTag": "Xóa thẻ {{tagName}}",
    "mainContent.dailyBriefing": "Báo cáo trong ngày",
    "taskList.allDone": "Tất cả đã xong!",
    "taskList.noTasks": "Bạn không có công việc nào ở đây. Hãy thêm một công việc để bắt đầu.",
    "taskList.addTask": "Thêm công việc",
    "taskList.completed": "Đã hoàn thành",
    "taskDetail.recurringInfo": "Đây là một công việc lặp lại ({{rule}}).",
    "taskDetail.completed": "Đã hoàn thành",
    "taskDetail.markComplete": "Đánh dấu hoàn thành",
    "taskDetail.focusTime": "Đã tập trung trong <strong>{{time}}</strong>",
    "taskDetail.descriptionLabel": "Mô tả",
    "taskDetail.descriptionPlaceholder": "Thêm mô tả...",
    "taskDetail.sourcesLabel": "Nguồn",
    "taskDetail.priorityLabel": "Mức ưu tiên",
    "taskDetail.tagsLabel": "Thẻ",
    "taskDetail.tagsPlaceholder": "Thêm thẻ...",
    "taskDetail.tagsHelper": "Nhấn Enter để thêm thẻ.",
    "taskDetail.subtasksLabel": "Công việc phụ",
    "taskDetail.generateButton": "Tạo",
    "taskDetail.progressLabel": "Tiến độ",
    "taskDetail.addSubtaskPlaceholder": "Thêm công việc phụ...",
    "taskDetail.addButton": "Thêm",
    "taskDetail.getInfoButton": "Lấy thông tin",
    "taskDetail.startFocusButton": "Bắt đầu tập trung",
    "taskItem.aria.markIncomplete": "Đánh dấu chưa hoàn thành",
    "taskItem.aria.markComplete": "Đánh dấu đã hoàn thành",
    "taskItem.aria.startFocus": "Bắt đầu phiên tập trung",
    "taskItem.title.repeats": "Lặp lại {{rule}}",
    "taskItem.title.reminder": "Nhắc trước {{minutes}} phút",
    "recurrence.title": "Lặp lại",
    "recurrence.none": "Không có",
    "recurrence.daily": "Hàng ngày",
    "recurrence.weekly": "Hàng tuần",
    "recurrence.monthly": "Hàng tháng",
    "reminder.title": "Lời nhắc",
    "reminder.none": "Không có",
    "reminder.5min": "5 phút trước",
    "reminder.15min": "15 phút trước",
    "reminder.30min": "30 phút trước",
    "reminder.1hour": "1 giờ trước",
    "habitView.title": "Theo dõi thói quen",
    "habitView.subtitle": "Xây dựng sự nhất quán mỗi ngày.",
    "habitView.addPlaceholder": "Thêm thói quen mới... (ví dụ: Đọc sách 15 phút)",
    "habitView.emptyState.title": "Chưa có thói quen nào",
    "habitView.emptyState.subtitle": "Thêm thói quen đầu tiên để bắt đầu xây dựng chuỗi.",
    "habit.streak": "Chuỗi {{count}} ngày",
    "habit.noStreak": "Chưa có chuỗi hiện tại",
    "habit.deleteConfirm.title": "Xóa \"{{habitName}}\"?",
    "habit.deleteConfirm.message": "Thao tác này sẽ xóa vĩnh viễn thói quen này và lịch sử của nó. Không thể hoàn tác.",
    "habit.deleteConfirm.confirmText": "Xóa thói quen",
    "habit.deleteSuccess": "Đã xóa thói quen \"{{habitName}}\"",
    "habit.heatmap.tooltip.completed": "{{date}}: Đã hoàn thành",
    "habit.heatmap.tooltip.notCompleted": "{{date}}: Chưa hoàn thành",
    "countdownView.title": "Đếm ngược",
    "countdownView.subtitle": "Theo dõi các sự kiện được mong đợi nhất của bạn.",
    "countdownView.add": "Thêm đếm ngược",
    "countdownView.emptyState.title": "Chưa có đếm ngược",
    "countdownView.emptyState.subtitle": "Nhấp vào \"Thêm đếm ngược\" để bắt đầu.",
    "countdown.modal.title": "Đếm ngược mới",
    "countdown.modal.nameLabel": "Tên sự kiện",
    "countdown.modal.namePlaceholder": "ví dụ: Kỳ nghỉ hè",
    "countdown.modal.dateLabel": "Ngày diễn ra",
    "countdown.modal.create": "Tạo đếm ngược",
    "countdown.card.expired": "Đã hết hạn",
    "countdown.card.dayRemaining": "Ngày còn lại",
    "countdown.card.daysRemaining": "Ngày còn lại",
    "countdown.deleteConfirm.title": "Xóa \"{{eventName}}\"?",
    "countdown.deleteConfirm.message": "Thao tác này sẽ xóa vĩnh viễn bộ đếm ngược này. Không thể hoàn tác.",
    "countdown.deleteConfirm.confirmText": "Xóa đếm ngược",
    "countdown.deleteSuccess": "Đã xóa đếm ngược \"{{eventName}}\"",
    "settings.title": "Cài đặt",
    "settings.subtitle": "Tùy chỉnh trải nghiệm TaskFlow của bạn.",
    "settings.appearance": "Giao diện",
    "settings.theme": "Chủ đề",
    "settings.theme.light": "Sáng",
    "settings.theme.dark": "Tối",
    "settings.language": "Ngôn ngữ",
    "settings.language.en": "English (Tiếng Anh)",
    "settings.language.vi": "Vietnamese (Tiếng Việt)",
    "settings.pomodoro.title": "Hẹn giờ Pomodoro",
    "settings.pomodoro.focusDuration": "Thời gian tập trung (phút)",
    "settings.pomodoro.shortBreak": "Nghỉ ngắn (phút)",
    "settings.pomodoro.longBreak": "Nghỉ dài (phút)",
    "settings.pomodoro.longBreakInterval": "Khoảng nghỉ dài (phiên)",
    "settings.bottomNav.title": "Tùy chỉnh Thanh điều hướng dưới cùng",
    "settings.bottomNav.subtitle": "Kéo và thả để sắp xếp lại hoặc ẩn các mục trong thanh điều hướng di động.",
    "settings.bottomNav.visible": "Mục hiển thị (Tối đa 4)",
    "settings.bottomNav.hidden": "Mục bị ẩn",
    "chatbot.title": "Trợ lý Gemini",
    "chatbot.initialMessage": "Xin chào! Tôi có thể giúp gì để bạn làm việc năng suất hơn hôm nay?",
    "chatbot.sources": "Nguồn:",
    "chatbot.thinkingMode": "Chế độ Suy nghĩ",
    "chatbot.searchWeb": "Tìm kiếm trên web",
    "chatbot.placeholder": "Hỏi Gemini bất cứ điều gì...",
    "dashboard.greeting.morning": "Chào buổi sáng!",
    "dashboard.greeting.afternoon": "Chào buổi chiều!",
    "dashboard.greeting.evening": "Chào buổi tối!",
    "dashboard.subtitle": "Đây là bảng điều khiển năng suất của bạn hôm nay.",
    "dashboard.stat.today": "Công việc hôm nay",
    "dashboard.stat.upcoming": "Công việc sắp tới",
    "dashboard.stat.habits": "Thói quen đã hoàn thành",
    "dashboard.cta.title": "Sẵn sàng để lên kế hoạch cho ngày của bạn?",
    "dashboard.cta.subtitle": "Hãy để Gemini phân tích công việc và thói quen của bạn để tạo ra một kế hoạch được cá nhân hóa, có thể hành động để giúp bạn tập trung và làm việc hiệu quả.",
    "dashboard.cta.button": "Nhận báo cáo trong ngày",
    "dashboard.heatmapTitle": "Bản đồ nhiệt Năng suất",
    "heatmap.tooltip.noActivity": "Không có hoạt động vào ngày {{date}}",
    "heatmap.tooltip.activity": "{{date}}\n- {{tasksCount}} công việc đã hoàn thành\n- {{pomosCount}} phiên Pomodoro",
    "heatmap.tooltip.future": "Ngày trong tương lai",
    "achievements.title": "Thành tựu",
    "achievements.subtitle": "Mở khóa huy hiệu cho sự chăm chỉ và nhất quán của bạn.",
    "achievements.locked.description": "???",
    "achievements.locked.status": "Đã khóa",
    "achievements.first_step.title": "Bước đầu tiên",
    "achievements.first_step.description": "Hoàn thành công việc đầu tiên của bạn.",
    "achievements.task_novice.title": "Người mới",
    "achievements.task_novice.description": "Hoàn thành 10 công việc.",
    "achievements.task_master.title": "Bậc thầy Công việc",
    "achievements.task_master.description": "Hoàn thành 100 công việc.",
    "achievements.focus_starter.title": "Người bắt đầu Tập trung",
    "achievements.focus_starter.description": "Hoàn thành phiên Pomodoro đầu tiên của bạn.",
    "achievements.focus_pro.title": "Chuyên gia Tập trung",
    "achievements.focus_pro.description": "Hoàn thành 25 phiên Pomodoro.",
    "achievements.habit_builder.title": "Người xây dựng Thói quen",
    "achievements.habit_builder.description": "Duy trì chuỗi 7 ngày cho bất kỳ thói quen nào.",
    "achievements.habit_hero.title": "Anh hùng Thói quen",
    "achievements.habit_hero.description": "Duy trì chuỗi 30 ngày cho bất kỳ thói quen nào.",
    "achievements.ai_assistant.title": "Cộng tác viên AI",
    "achievements.ai_assistant.description": "Sử dụng Gemini để tạo công việc phụ.",
    "achievements.planner.title": "Nhà hoạch định",
    "achievements.planner.description": "Tạo 10 công việc có ngày hết hạn.",
    "achievements.delegator.title": "Người ủy thác",
    "achievements.delegator.description": "Giao 5 công việc cho thành viên trong nhóm.",
    "auth.welcome": "Chào mừng trở lại! Vui lòng đăng nhập.",
    "auth.emailLabel": "Địa chỉ email",
    "auth.passwordLabel": "Mật khẩu",
    "auth.signIn": "Đăng nhập",
    "auth.noAccount": "Chưa có tài khoản?",
    "auth.signUp": "Đăng ký",
    "auth.mockLoginInfo": "(Đây là đăng nhập giả. Mọi thông tin đều hợp lệ.)",
    "auth.createAccountPrompt": "Tạo tài khoản của bạn để bắt đầu.",
    "auth.fullNameLabel": "Họ và tên",
    "auth.alreadyHaveAccount": "Đã có tài khoản?",
    "auth.tagline": "Từ hỗn loạn đến rõ ràng. Đối tác năng suất cuối cùng của bạn.",
    "auth.signInWithGoogle": "Đăng nhập với Google",
    "auth.signInWithGitHub": "Đăng nhập với GitHub",
    "auth.orContinueWith": "Hoặc tiếp tục với",
    "profile.viewProfile": "Xem hồ sơ",
    "profile.settings": "Cài đặt",
    "profile.achievements": "Thành tựu",
    "profile.logout": "Đăng xuất",
    "profile.editProfile": "Chỉnh sửa Hồ sơ",
    "profile.stats.title": "Thống kê Năng suất",
    "profile.stats.tasksCompleted": "Công việc đã hoàn thành",
    "profile.stats.focusTime": "Tổng thời gian tập trung",
    "profile.stats.achievementsUnlocked": "Thành tựu đã mở khóa",
    "profile.weeklyActivity": "Hoạt động hàng tuần",
    "profile.tasksCompleted": "Công việc đã hoàn thành",
    "profile.recentActivity": "Hoạt động gần đây",
    "profile.noRecentActivity": "Không có hoạt động gần đây để hiển thị.",
    "profile.recentAchievements": "Thành tựu gần đây",
    "profile.noAchievements": "Chưa mở khóa thành tựu nào. Cố gắng lên!",
    "profile.editModal.title": "Chỉnh sửa Hồ sơ",
    "profile.editModal.nameLabel": "Họ và tên",
    "profile.editModal.emailLabel": "Địa chỉ Email",
    "profile.editModal.saveButton": "Lưu thay đổi",
    "profile.updateSuccess": "Cập nhật hồ sơ thành công!",
    "feature.toggleSidebar": "Mở/Đóng thanh bên",
    "feature.dashboard": "Bảng điều khiển",
    "feature.listView": "Dạng danh sách",
    "feature.boardView": "Dạng bảng",
    "feature.calendarView": "Dạng lịch",
    "feature.matrixView": "Ma trận",
    "feature.habitTracker": "Theo dõi thói quen",
    "feature.pomodoro": "Pomodoro",
    "feature.countdown": "Đếm ngược",
    "feature.more": "Thêm",
    "mainContent.tasksDefault": "Công việc",
    "mainContent.searchTasks": "Tìm kiếm công việc",
    "mainContent.sortTasks": "Sắp xếp công việc",
    "mainContent.undo": "Hoàn tác",
    "mainContent.redo": "Làm lại",
    "mainContent.clearHistory": "Xóa lịch sử",
    "board.title": "Dạng bảng",
    "board.noLists": "Không có danh sách cho dạng bảng",
    "board.noListsSubtitle": "Hãy tạo một danh sách tùy chỉnh để sử dụng tính năng này.",
    "board.addColumn": "Thêm cột khác",
    "board.column.dragHandle": "Kéo để sắp xếp lại cột",
    "board.column.namePlaceholder": "Nhập tên cột...",
    "board.column.addColumn": "Thêm cột",
    "board.column.cancel": "Hủy",
    "board.column.addCard": "Thêm thẻ",
    "board.column.menu.rename": "Đổi tên",
    "board.column.menu.delete": "Xóa",
    "board.column.deleteConfirm.title": "Xóa cột \"{{columnName}}\"?",
    "board.column.deleteConfirm.message": "Tất cả công việc trong cột này sẽ được chuyển đến cột đầu tiên. Hành động này không thể hoàn tác.",
    "board.column.deleteConfirm.confirmText": "Xóa cột",
    "board.column.deleteSuccess": "Đã xóa cột \"{{columnName}}\"",
    "calendar.today": "Hôm nay",
    "calendar.month": "Tháng",
    "calendar.week": "Tuần",
    "calendar.allDay": "Cả ngày",
    "calendar.moreTasks": "+ {{count}} thêm",
    "pomodoro.view.title": "Pomodoro",
    "pomodoro.focus": "Tập trung",
    "pomodoro.shortBreak": "Nghỉ ngắn",
    "pomodoro.longBreak": "Nghỉ dài",
    "pomodoro.selectTask": "Chọn một công việc",
    "pomodoro.focusingOn": "Đang tập trung vào: {{taskTitle}}",
    "pomodoro.stop": "Dừng",
    "pomodoro.start": "Bắt đầu",
    "pomodoro.pause": "Tạm dừng",
    "pomodoro.overview": "Tổng quan",
    "pomodoro.todayPomos": "Pomo hôm nay",
    "pomodoro.totalFocus": "Tổng tập trung",
    "pomodoro.focusRecord": "Lịch sử tập trung",
    "pomodoro.noRecords": "Chưa có phiên tập trung nào hôm nay.",
    "pomodoro.generalFocus": "Tập trung chung",
    "taskForm.newTask": "Công việc mới",
    "taskForm.createWithGemini": "Tạo công việc từ văn bản với Gemini",
    "taskForm.geminiPlaceholder": "VD: Nhắc tôi gọi cho John về đề xuất dự án vào 2 giờ chiều mai",
    "taskForm.analyzeAndFill": "Phân tích và điền",
    "taskForm.titleLabel": "Tiêu đề",
    "taskForm.titlePlaceholder": "VD: Thanh toán hóa đơn tiền điện",
    "taskForm.descriptionLabel": "Mô tả",
    "taskForm.descriptionPlaceholder": "Thêm chi tiết...",
    "taskForm.dueDateLabel": "Ngày hết hạn",
    "taskForm.priorityLabel": "Mức ưu tiên",
    "taskForm.listLabel": "Danh sách",
    "taskForm.createTask": "Tạo công việc",
    "briefing.error.unavailable": "API Gemini không khả dụng.",
    "briefing.title": "Báo cáo trong ngày của AI",
    "briefing.loading": "Gemini đang phân tích ngày của bạn...",
    "briefing.error.failed": "Không thể tạo báo cáo",
    "briefing.button.gotIt": "Đã hiểu!",
    "assigneePicker.label": "Người thực hiện",
    "assigneePicker.unassigned": "Chưa giao",
    "assigneePicker.unassign": "Bỏ giao việc",
    "comments.title": "Hoạt động",
    "comments.unknownUser": "Người dùng không xác định",
    "comments.empty": "Chưa có bình luận nào.",
    "comments.placeholder": "Thêm bình luận...",
    "timeAgo.year": "{{count}}năm trước",
    "timeAgo.month": "{{count}}th trước",
    "timeAgo.day": "{{count}}ng trước",
    "timeAgo.hour": "{{count}}g trước",
    "timeAgo.minute": "{{count}}p trước",
    "timeAgo.now": "vừa xong",
    "shareList.title": "Chia sẻ \"{{listName}}\"",
    "shareList.subtitle": "Quản lý người có thể truy cập danh sách này.",
    "shareList.members": "Thành viên",
    "shareList.owner": "Chủ sở hữu",
    "shareList.invite": "Mời người khác",
    "shareList.empty": "Mọi người đã có trong danh sách này.",
    "shareList.done": "Xong",
    "landing.nav.launch": "Mở ứng dụng",
    "landing.hero.title": "Giải phóng năng suất của bạn",
    "landing.hero.subtitle": "TaskFlow kết hợp quản lý công việc hiện đại với sức mạnh của Gemini AI để giúp bạn tổ chức, ưu tiên và đạt được mục tiêu nhanh hơn bao giờ hết.",
    "landing.hero.cta": "Bắt đầu miễn phí",
    "landing.features.title": "Mọi thứ bạn cần, tất cả ở một nơi",
    "landing.features.subtitle": "Một bộ công cụ hoàn chỉnh để làm chủ quy trình làm việc của bạn.",
    "landing.feature1.title": "Quản lý thông minh",
    "landing.feature1.description": "Hãy để Gemini phân tích ghi chú của bạn để tạo công việc, đề xuất công việc phụ và cung cấp báo cáo hàng ngày để giúp bạn đi đúng hướng.",
    "landing.feature2.title": "Giao diện linh hoạt",
    "landing.feature2.description": "Từ danh sách đơn giản, lịch, đến Ma trận Eisenhower mạnh mẽ, hãy hình dung công việc của bạn theo cách phù hợp nhất.",
    "landing.feature3.title": "Bộ công cụ năng suất",
    "landing.feature3.description": "Tích hợp hẹn giờ Pomodoro, theo dõi thói quen và đếm ngược sự kiện để giúp bạn tập trung và duy trì động lực.",
    "landing.testimonials.title": "Được những người năng suất yêu thích",
    "landing.testimonials.subtitle": "Xem người dùng của chúng tôi nói gì về TaskFlow.",
    "landing.testimonial1.quote": "\"TaskFlow đã thay đổi hoàn toàn cách tôi tổ chức công việc. Các tính năng AI là một yếu tố thay đổi cuộc chơi để phân chia các dự án lớn.\"",
    "landing.testimonial1.author": "Sarah J.",
    "landing.testimonial1.role": "Nhà thiết kế tự do",
    "landing.testimonial2.quote": "\"Tôi đã thử mọi trình quản lý công việc. TaskFlow là trình quản lý đầu tiên thực sự hiệu quả. Hẹn giờ pomodoro và theo dõi thói quen được tích hợp hoàn hảo.\"",
    "landing.testimonial2.author": "Mike R.",
    "landing.testimonial2.role": "Kỹ sư phần mềm",
    "landing.cta.title": "Sẵn sàng để tăng năng suất của bạn?",
    "landing.cta.subtitle": "Ngừng sử dụng nhiều ứng dụng và bắt đầu đạt được mục tiêu của bạn. Khởi chạy TaskFlow và trải nghiệm một cách làm việc thông minh hơn.",
    "landing.cta.button": "Mở ứng dụng miễn phí",
    "landing.footer.copyright": "© {{year}} TaskFlow. Mọi quyền được bảo lưu.",
    "matrix.title": "Ma trận Eisenhower",
    "matrix.subtitle": "Ưu tiên công việc của bạn dựa trên tính khẩn cấp và tầm quan trọng.",
    "matrix.q1.title": "Khẩn cấp & Quan trọng",
    "matrix.q1.subtitle": "Làm những công việc này trước tiên.",
    "matrix.q2.title": "Không khẩn cấp & Quan trọng",
    "matrix.q2.subtitle": "Lên lịch cho những công việc này.",
    "matrix.q3.title": "Khẩn cấp & Không quan trọng",
    "matrix.q3.subtitle": "Ủy thác những công việc này.",
    "matrix.q4.title": "Không khẩn cấp & Không quan trọng",
    "matrix.q4.subtitle": "Loại bỏ những công việc này.",
    "matrix.empty": "Không có công việc nào trong góc phần tư này.",
    "focusPicker.title": "Chọn một công việc để tập trung",
    "focusPicker.general": "Tập trung chung (Không có công việc cụ thể)",
    "search.placeholder": "Tìm kiếm công việc theo tiêu đề, mô tả hoặc thẻ...",
    "search.noResults": "Không tìm thấy công việc nào cho \"{{searchTerm}}\"",
    "datePicker.placeholder": "Chọn một ngày",
    "datePicker.aria.clear": "Xóa ngày",
    "datePicker.today": "Hôm nay",
    "toast.close": "Đóng"
}

================================================================================

--- FILE: metadata.json ---

{
  "name": "TaskFlow",
  "description": "A modern task management application inspired by TickTick, designed with a clean, mobile-first interface. TaskFlow integrates the power of Gemini to help you analyze, create, and refine tasks, get up-to-date information with Search Grounding, and chat with an AI assistant to boost your productivity.",
  "requestFramePermissions": []
}

================================================================================

--- FILE: package.json ---

{
  "name": "taskflow",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "18.2.0",
    "@google/genai": "0.14.0",
    "react-dom": "18.2.0"
  },
  "devDependencies": {
    "@types/node": "^22.14.0",
    "@vitejs/plugin-react": "^5.0.0",
    "typescript": "~5.8.2",
    "vite": "^6.2.0"
  }
}


================================================================================

--- FILE: services/geminiService.ts ---

import { GoogleGenAI, GenerateContentResponse } from "@google/genai";
import { Task, GroundingSource, Habit, ChatMessage } from '../types';

const generativeModelNotAvailableError = "Generative AI model is not available. Please configure the API key.";

export const analyzeTextForTask = async (ai: GoogleGenAI, text: string): Promise<Partial<Task>> => {
    try {
        const model = 'gemini-2.5-pro';
        const prompt = `Analyze the following text and extract task details. Provide the output in a clean JSON format with keys: "title", "description", "dueDate" (in ISO 8601 format if found, otherwise null), and "subtasks" (an array of strings).

Text to analyze: "${text}"

Example output:
{
  "title": "Book flights to Paris",
  "description": "Book flights for the conference in Paris from Oct 10 to Oct 15.",
  "dueDate": "2024-10-15T00:00:00.000Z",
  "subtasks": ["Check flight prices", "Confirm dates with team", "Book the flights"]
}`;

        const response = await ai.models.generateContent({
            model,
            contents: prompt,
            config: {
                responseMimeType: "application/json",
            }
        });
        
        const jsonString = response.text.trim();
        const parsedJson = JSON.parse(jsonString);
        
        return {
            title: parsedJson.title || '',
            description: parsedJson.description || '',
            dueDate: parsedJson.dueDate || undefined,
            subtasks: parsedJson.subtasks ? parsedJson.subtasks.map((s: string, i: number) => ({ id: `s-${Date.now()}-${i}`, title: s, completed: false })) : [],
        };
    } catch (error) {
        console.error("Error analyzing text with Gemini:", error);
        throw new Error("Failed to analyze text. Please try again.");
    }
};

export const generateSubtasks = async (ai: GoogleGenAI, taskTitle: string): Promise<string[]> => {
    try {
        const model = 'gemini-2.5-flash';
        const prompt = `Generate a list of actionable subtasks for the following main task. Provide only a JSON array of strings.

Main Task: "${taskTitle}"

Example for "Plan birthday party":
["Create guest list", "Send invitations", "Order cake", "Plan menu", "Buy decorations"]`;

        const response = await ai.models.generateContent({
            model,
            contents: prompt,
            config: {
                responseMimeType: "application/json",
            }
        });

        const jsonString = response.text.trim();
        return JSON.parse(jsonString);
    } catch (error) {
        console.error("Error generating subtasks with Gemini:", error);
        throw new Error("Failed to generate subtasks.");
    }
};

export const getGroundedInfo = async (ai: GoogleGenAI, query: string): Promise<{ summary: string, sources: GroundingSource[] }> => {
    try {
        const model = 'gemini-2.5-flash';
        const response = await ai.models.generateContent({
            model,
            contents: `Provide a concise summary based on up-to-date web information for the following query: "${query}"`,
            config: {
                tools: [{ googleSearch: {} }],
            },
        });
        
        const summary = response.text;
        const groundingChunks = response.candidates?.[0]?.groundingMetadata?.groundingChunks || [];
        
        const sources: GroundingSource[] = groundingChunks
            .map((chunk: any) => ({
                uri: chunk.web?.uri || '',
                title: chunk.web?.title || 'Source',
            }))
            .filter((source: GroundingSource) => source.uri);

        return { summary, sources };
    } catch (error) {
        console.error("Error with Search Grounding:", error);
        throw new Error("Failed to get information from the web.");
    }
};

interface ChatResponse {
    text: string;
    sources: GroundingSource[];
}

export const getChatResponseStream = async (
    ai: GoogleGenAI,
    history: { role: string, parts: { text: string }[] }[], 
    newMessage: string, 
    { useThinkingMode, useSearchGrounding }: { useThinkingMode: boolean, useSearchGrounding: boolean }
): Promise<AsyncGenerator<GenerateContentResponse>> => {
    try {
        let model: string;
        if (useThinkingMode) {
            model = 'gemini-2.5-pro';
        } else if (useSearchGrounding) {
            model = 'gemini-2.5-flash'; // Search grounding works best with flash
        } else {
            model = 'gemini-2.5-flash-lite'; // Lite for fastest response
        }
        
        const chat = ai.chats.create({
            model,
            config: {
                ...(useThinkingMode && { thinkingConfig: { thinkingBudget: 32768 } }),
                ...(useSearchGrounding && { tools: [{ googleSearch: {} }] }),
            },
            history: history,
        });

        const result = await chat.sendMessageStream({ message: newMessage });
        return result;
    } catch (error) {
        console.error("Error getting chat response from Gemini:", error);
        throw new Error("Failed to get chat response. Please check your connection or API key.");
    }
};


export const generateDailyBriefing = async (ai: GoogleGenAI, tasks: Task[], habits: Habit[]): Promise<string> => {
    try {
        const model = 'gemini-2.5-pro';
        const today = new Date().toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
        
        const uncompletedTasks = tasks.filter(t => !t.completed);
        
        // Sanitize for prompt
        const taskData = uncompletedTasks.map(t => ({ title: t.title, dueDate: t.dueDate, priority: t.priority }));
        const habitData = habits.map(h => ({ name: h.name, completions: h.completions.length }));

        const prompt = `
        As a world-class productivity assistant, analyze the user's current tasks and habits to create a "Daily Briefing" for today, ${today}.
        The output must be in clear, encouraging, and actionable markdown format.

        Here is the user's data:
        Tasks: ${JSON.stringify(taskData)}
        Habits: ${JSON.stringify(habitData)}
        
        Your briefing should include the following sections:
        1.  **Top 3 Priorities:** Identify the three most critical tasks for today. Consider due dates (closer is more critical) and priority level (High > Medium > Low).
        2.  **Today's Schedule Suggestion:** Create a simple, suggested schedule. For example, "Morning: Tackle [Task 1]. Afternoon: Focus on [Task 2] and [Task 3]."
        3.  **Heads-up:** Point out any tasks due today or tomorrow that are not in the top priorities.
        4.  **Habit Corner:** Mention one of the habits and give a short, encouraging nudge.
        5.  **Quote of the Day:** End with an inspiring productivity quote.

        Keep the tone positive and motivating. Structure the output cleanly with markdown headings.
        `;

        const response = await ai.models.generateContent({ model, contents: prompt });
        return response.text;

    } catch (error) {
        console.error("Error generating daily briefing with Gemini:", error);
        throw new Error("Failed to generate your daily briefing. Please try again later.");
    }
};

================================================================================

--- FILE: tsconfig.json ---

{
  "compilerOptions": {
    "target": "ES2022",
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "module": "ESNext",
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "skipLibCheck": true,
    "types": [
      "node"
    ],
    "moduleResolution": "bundler",
    "isolatedModules": true,
    "moduleDetection": "force",
    "allowJs": true,
    "jsx": "react-jsx",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "allowImportingTsExtensions": true,
    "noEmit": true
  }
}

================================================================================

--- FILE: types.ts ---

import React from 'react';

export interface Subtask {
  id: string;
  title: string;
  completed: boolean;
}

export enum Priority {
  None = 0,
  Low = 1,
  Medium = 2,
  High = 3,
}

export type RecurrenceRule = 'daily' | 'weekly' | 'monthly';

export interface Comment {
  id: string;
  userId: string;
  content: string;
  createdAt: string;
}

export interface Column {
  id: string;
  name: string;
  listId: string;
}

export interface Task {
  id: string;
  title: string;
  description?: string;
  completed: boolean;
  completedAt?: string; // ISO string when completed
  dueDate?: string;
  priority: Priority;
  listId: string;
  columnId?: string;
  tags: string[];
  subtasks: Subtask[];
  createdAt: string;
  groundingSources?: GroundingSource[];
  totalFocusTime: number; // in seconds
  recurrence?: {
    rule: RecurrenceRule;
  };
  reminderMinutes?: number; // e.g. 5, 15, 30
  assigneeId?: string;
  comments?: Comment[];
}

export interface GroundingSource {
    uri: string;
    title: string;
}

export interface List {
  id: string;
  name: string;
  color: string;
  members?: string[]; // Array of user IDs
}

export interface Habit {
  id: string;
  name: string;
  completions: string[]; // Array of 'YYYY-MM-DD' date strings
  createdAt: string;
}

export interface CountdownEvent {
  id: string;
  name: string;
  targetDate: string; // ISO string
}

export interface Achievement {
    id: string;
    title: string;
    description: string;
    icon: React.FC<{className?: string}>;
    condition: (state: AppState) => boolean;
}


export type SpecialList = 'inbox' | 'today' | 'upcoming';

export type SortOrder = 'default' | 'dueDateAsc' | 'dueDateDesc';

export type PomodoroSessionType = 'pomo' | 'shortBreak' | 'longBreak';

export interface PomodoroFocusRecord {
    startTime: string;
    endTime: string;
    duration: number; // in seconds
    taskId: string | null;
}

export interface PomodoroState {
    isActive: boolean;
    isPaused: boolean;
    remainingTime: number; // in seconds
    currentSession: PomodoroSessionType;
    currentCycle: number;
    focusedTaskId: string | null;
    focusHistory: PomodoroFocusRecord[];
    settings: {
        pomoDuration: number;
        shortBreakDuration: number;
        longBreakDuration: number;
        longBreakInterval: number; // in cycles
    };
}

// FIX: Added 'profile' to ViewType to allow it as a valid view.
export type ViewType = 'list' | 'calendar' | 'pomodoro' | 'matrix' | 'habit' | 'countdown' | 'settings' | 'dashboard' | 'achievements' | 'board' | 'profile';

export type Action =
  | { type: 'LOAD_STATE'; payload: AppState }
  | { type: 'ADD_TASK'; payload: Task }
  | { type: 'UPDATE_TASK'; payload: Task }
  | { type: 'DELETE_TASK'; payload: string }
  | { type: 'TOGGLE_TASK_COMPLETION'; payload: { taskId: string } }
  | { type: 'ADD_LIST'; payload: { name: string } }
  | { type: 'DELETE_LIST'; payload: string }
  | { type: 'SET_ACTIVE_LIST'; payload: string | SpecialList }
  | { type: 'SET_SELECTED_TASK'; payload: string | null }
  | { type: 'SET_SORT_ORDER'; payload: SortOrder }
  | { type: 'REORDER_TASKS'; payload: { draggedId: string; droppedOnId: string } }
  | { type: 'SET_ACTIVE_TAG'; payload: string | null }
  | { type: 'SET_VIEW'; payload: ViewType }
  | { type: 'SET_TASK_RECURRENCE', payload: { taskId: string, recurrence: Task['recurrence'] } }
  | { type: 'SET_TASK_REMINDER', payload: { taskId: string, reminderMinutes: number | undefined } }
  | { type: 'ADD_TAG', payload: { name: string } }
  | { type: 'DELETE_TAG', payload: string }
  | { type: 'ASSIGN_TASK'; payload: { taskId: string; userId: string | null } }
  | { type: 'ADD_COMMENT'; payload: { taskId: string; comment: Comment } }
  | { type: 'UPDATE_LIST_MEMBERS'; payload: { listId: string; memberIds: string[] } }
  | { type: 'UNLOCK_ACHIEVEMENT'; payload: string }
  | { type: 'ADD_COLUMN'; payload: { listId: string; name: string } }
  | { type: 'UPDATE_COLUMN'; payload: { columnId: string; name: string } }
  | { type: 'DELETE_COLUMN'; payload: { columnId: string; listId: string } }
  | { type: 'REORDER_COLUMNS'; payload: { listId: string; draggedId: string; droppedOnId: string } }
  | { type: 'MOVE_TASK_TO_COLUMN'; payload: { taskId: string; newColumnId: string; listId: string } }
  | { type: 'UNDO' }
  | { type: 'REDO' }
  | { type: 'CLEAR_HISTORY' }
  | { type: 'START_TIMER' }
  | { type: 'PAUSE_TIMER' }
  | { type: 'STOP_TIMER' }
  | { type: 'TICK' }
  | { type: 'SWITCH_SESSION' }
  | { type: 'SET_FOCUSED_TASK', payload: string | null }
  | { type: 'ADD_HABIT', payload: { name: string } }
  | { type: 'TOGGLE_HABIT_COMPLETION', payload: { habitId: string, date: string } }
  | { type: 'DELETE_HABIT', payload: string }
  | { type: 'ADD_COUNTDOWN', payload: CountdownEvent }
  | { type: 'DELETE_COUNTDOWN', payload: string }
  | { type: 'UPDATE_POMODORO_SETTINGS', payload: Partial<PomodoroState['settings']> };


export interface AppState {
  tasks: Task[];
  lists: List[];
  columns: Column[];
  tags: string[];
  habits: Habit[];
  countdownEvents: CountdownEvent[];
  unlockedAchievements: string[];
  activeListId: string | SpecialList;
  selectedTaskId: string | null;
  sortOrder: SortOrder;
  activeTag: string | null;
  pomodoro: PomodoroState;
  view: ViewType;
}

export interface ChatMessage {
  id: string;
  role: 'user' | 'model';
  text: string;
  timestamp: number;
  groundingSources?: GroundingSource[];
}

export interface User {
  id: string;
  name: string;
  email: string;
  avatarUrl?: string;
}


================================================================================

--- FILE: vite.config.ts ---

import path from 'path';
import { defineConfig, loadEnv } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig(({ mode }) => {
    const env = loadEnv(mode, '.', '');
    return {
      server: {
        port: 3000,
        host: '0.0.0.0',
      },
      plugins: [react()],
      define: {
        'process.env.API_KEY': JSON.stringify(env.GEMINI_API_KEY),
        'process.env.GEMINI_API_KEY': JSON.stringify(env.GEMINI_API_KEY)
      },
      resolve: {
        alias: {
          '@': path.resolve(__dirname, '.'),
        }
      }
    };
});


================================================================================
